<!doctype html>
<html lang="en">
<head>
<!-- Required meta tags -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<style>
.body {
	background-color: black;
}

.canvas {
	display: grid;
	grid-template-columns: auto 340px auto;

	width:  340px;
	height: auto;

	padding: 0px;
	border: 0px;
	margin-left: auto;
	margin-right: auto;
	margin-top: 0px;
	margin-bottom: 0px;

	overflow: hidden;
}

.container {
	width:  inherit;
	height: inherit;
	padding: 0px;
	border: 0px;
	margin: 0px;
	grid-row: 1;
	grid-column: 2;

	background-color: #000000;
}

.container-log {
	display: flex;
	flex-direction: column;
	align-items: stretch;
	flex-basis: auto;
	flex-grow: 1;

	width: inherit;
	height: 340px;

	border: inherit;
	margin: inherit;
	padding: inherit;
	padding-bottom: 2px;

	background-color: black;
}

.log{
	overflow-y:scroll;
	height: auto;
	width: inherit;
	background-color: white;
	border-radius: 10px;

	flex-direction: row;
	align-items: stretch;
	flex-basis: auto;
	flex-grow: 1 ;
}

.button {
	height: 42px;
	display: flex;
	flex-direction: row;
	align-items: stretch;
	flex-basis: auto;
	flex-grow: 1;

	margin: 2px;
	padding: 2px;
	border: 2px;
	border-radius: 10px;
	border-color: black;
}

.container-map {
	display: grid;
	grid-template-columns: 48px 244px 48px;
	height: 244px;
	margin-top: 0px;
	margin-bottom: 4px;
	padding-top: 0px;
	padding-bottom: 0px;
	border-radius: 10px;
	background-color: white;
}

.map {
  display: grid;
  grid-template-rows: 244px 1fr;
	height: 244px;
	margin-top: 0px;
	margin-bottom: 4px;
	padding-top: 0px;
	padding-bottom: 0px;
}

.map .overlay {
	grid-area: 1/1/1/1;
}

.areas {
	display: grid;
	grid-template-columns: 5;
	height: 240px;
	width:  240px;
	margin: auto;
	background-color: white;
}
.doors {
	display: grid;
	grid-template-columns: 9;
	height: 216px;
	width:  216px;
	margin: auto;
	background-color: transparent;
}

.option-column-buttons {
	display: grid;
	grid-template-columns: 1;
	height: 244px;
	width: 48px;
	padding: 0px;
	margin: 0px;
	margin-bottom: 4px;
}

.cell {
	float:left;
	position: relative;
	background-position:center center;
	background-repeat:no-repeat;
	height: 48px;
	width:  48px;
}

.cell-mini {
	float:left;
	position: relative;
	background-position:center center;
	background-repeat:no-repeat;
	height: 24px;
	width:  24px;
}

.row-1 {
	grid-row: 1;
}
.row-2 {
	grid-row: 2;
}
.row-3 {
	grid-row: 3;
}
.row-4 {
	grid-row: 4;
}
.row-5 {
	grid-row: 5;
}
.row-6 {
	grid-row: 6;
}
.row-7 {
	grid-row: 7;
}
.row-8 {
	grid-row: 8;
}
.row-9 {
	grid-row: 9;
}



</style>

<style>
.sidebar-open-button {
	height: 64;
	width: 64;
}

.sidebar-container {
	display: none;
	width:  inherit;
	height: inherit;

	grid-row: 1;
	grid-column: 2;

	border: 0px;
	padding: 0px;
	margin: 0px;

	background-color: #111;
	z-index: 2;
}

.sidebar-content {
	width:  inherit;
	height: inherit;
	border: inherit;
	padding: inherit;
	margin: inherit;
	top: 0;
}

.sidebar-content span {
	color: white;
	transition: 0.3s;
	font-size: 16px;
}

.sidebar .closebtn {
	height: 64;
	width: 64;
	font-size: 36px;
}

.tabs {
	margin: auto;
	display: flex;
	height: 50px;
	flex-direction: row;
	align-items: stretch;
	flex-basis: auto ;
	flex-grow: 1 ;
	padding: 4px;
}

.sidebar-content .tab-button {
	margin: auto;
	display: flex;
	height: 48px;
	flex-direction: row;
	align-items: stretch;
	flex-basis: auto ;
	flex-grow: 1 ;
}

.sidebar-bread-crumbs {
	margin: inherit;
	display: flex;
	height: 24px;
	flex-direction: row;
	align-items: stretch;
	flex-basis: auto ;
	flex-grow: 1 ;
}

.sidebar-body {
	overflow: auto;
	height: 540px;
}
</style>

<style>
.modal-container {
	display: none;

	width:  inherit;
	height: inherit;

	grid-row: 1;
	grid-column: 2;

	border: 0px;
	padding: 0px;
	margin: 0px;

  background-color: rgb(0,0,0); /* Fallback color */
  background-color: rgba(0,0,0,0.4); /* Black w/ opacity */

	z-index: 3; /* Sit on top */
}

.modal-content{
	flex-direction: column;
	align-items: stretch;
	flex-basis: auto;
	flex-grow: 1;

	width:  inherit - 20%;
	height: inherit;

	border: inherit + 10px;
	padding: inherit;
	margin: auto 10% auto 10%;

	background-color: #111;
	border-radius: 10px;

	overflow:hidden;
}

.modal-header {
	width:  inherit;
	height: inherit;
	background-color: whitesmoke;
}

.modal-body {
	width:  inherit;
	height: inherit;
	padding-top: 10px;
	padding-bottom: 10px;
	color: whitesmoke;
}
</style>

<style>
.boss-icon {
	height: 48px;
	width:  48px;
	mask-repeat: no-repeat;
	mask-size: 100%;
	background: lightgray;
	mask-image: url('data:image/svg+xml;utf8, <svg width="100%" height="100%" viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="Boss"><path d="M32,16c8.831,0 16,7.169 16,16c0,8.831 -7.169,16 -16,16c-8.831,0 -16,-7.169 -16,-16c0,-8.831 7.169,-16 16,-16Zm0,2.083c-7.681,0 -13.917,6.236 -13.917,13.917c0,7.681 6.236,13.917 13.917,13.917c7.681,-0 13.917,-6.236 13.917,-13.917c-0,-7.681 -6.236,-13.917 -13.917,-13.917Z"/><path d="M36,18l4,2l4,4l0,8l-6,4l0,6l-2,2l-8,0l-2,-2l0,-6l-6,-4l0,-8l4,-4l4,-2l8,0Zm5,9l-7,2l1,2l6,0l0,-4Zm-8,4l-2,0l-1,4l4,0l-1,-4Zm-3,6l-2,2l0,2l8,0l0,-2l-2,-2l-4,0Zm-7,-10l0,4l6,0l1,-2l-7,-2Z"/><path d="M36,18l4,2l4,4l0,8l-6,4l0,6l-2,2l-8,0l-2,-2l0,-6l-6,-4l0,-8l4,-4l4,-2l8,0Zm-0.098,0.417l-7.804,-0l-3.851,1.925c-0,0 -3.83,3.831 -3.83,3.831l-0,7.604l5.814,3.876c0.116,0.078 0.186,0.208 0.186,0.347l-0,5.827c-0,0 1.756,1.756 1.756,1.756l7.654,0l1.756,-1.756l0,-5.827c0,-0.139 0.07,-0.269 0.186,-0.347l5.814,-3.876l0,-7.604l-3.83,-3.831l-3.851,-1.925Zm-12.788,8.182l7,2c0.12,0.034 0.217,0.12 0.267,0.233c0.05,0.114 0.047,0.243 -0.008,0.354l-1,2c-0.071,0.141 -0.215,0.231 -0.373,0.231l-6,-0c-0.23,-0 -0.417,-0.187 -0.417,-0.417l0,-4c0,-0.131 0.062,-0.254 0.166,-0.333c0.104,-0.078 0.24,-0.104 0.365,-0.068Zm-0.114,0.401l0,4l6,0l1,-2l-7,-2Zm18.417,0l-0,4c-0,0.23 -0.187,0.417 -0.417,0.417l-6,-0c-0.158,-0 -0.302,-0.09 -0.373,-0.231l-1,-2c-0.055,-0.111 -0.058,-0.24 -0.008,-0.354c0.05,-0.113 0.147,-0.199 0.267,-0.233l7,-2c0.125,-0.036 0.261,-0.01 0.365,0.068c0.104,0.079 0.166,0.202 0.166,0.333Zm-0.417,0l-7,2l1,2l6,0l0,-4Zm-11,9.583l4,0c0.111,0 0.216,0.044 0.295,0.122l2,2c0.078,0.079 0.122,0.184 0.122,0.295l-0,2c-0,0.23 -0.187,0.417 -0.417,0.417l-8,-0c-0.23,-0 -0.417,-0.187 -0.417,-0.417l0,-2c0,-0.111 0.044,-0.216 0.122,-0.295l2,-2c0.079,-0.078 0.184,-0.122 0.295,-0.122Zm0,0.417l-2,2l0,2l8,0l0,-2l-2,-2l-4,0Zm3.404,-6.101l1,4c0.031,0.124 0.003,0.256 -0.076,0.357c-0.079,0.102 -0.2,0.161 -0.328,0.161l-4,-0c-0.128,-0 -0.249,-0.059 -0.328,-0.161c-0.079,-0.101 -0.107,-0.233 -0.076,-0.357l1,-4c0.046,-0.186 0.213,-0.316 0.404,-0.316l2,0c0.191,0 0.358,0.13 0.404,0.316Zm-0.404,0.101l-2,0l-1,4l4,0l-1,-4Z"/></g></svg>');
}
.encounter-icon {
	height: 48px;
	width:  48px;
	mask-repeat: no-repeat;
	mask-size: 100%;
	background: lightgray;
	mask-image: url('data:image/svg+xml;utf8, <svg width="100%" height="100%" viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="Encounter"><path d="M41.899,22.101l-3.535,0.707l-12.021,12.02l-1.414,-1.414l-1.414,0l-0,1.414l1.414,1.415l-0,1.414l-1.414,1.414l-2.122,0.707l0.708,2.121l2.121,0.708l0.707,-2.122l1.414,-1.414l1.414,0l1.415,1.414l1.414,0l-0,-1.414l-1.414,-1.414l12.02,-12.021l0.707,-3.535Z"/><path d="M41.899,22.101l-0.707,3.535l-12.02,12.021l1.414,1.414l-0,1.414l-1.414,0l-1.415,-1.414l-1.414,0l-1.414,1.414l-0.707,2.122l-2.121,-0.708l-0.708,-2.121l2.122,-0.707l1.414,-1.414l-0,-1.414l-1.414,-1.415l-0,-1.414l1.414,0l1.414,1.414l12.021,-12.02l3.535,-0.707Zm-14.887,14.887l0.186,-0c0.039,-0.114 0.087,-0.225 0.146,-0.332c-0.107,0.059 -0.218,0.107 -0.332,0.146l0,0.186Z"/><path d="M22.101,22.101l0.707,3.535l12.02,12.021l-1.414,1.414l0,1.414l1.414,0l1.415,-1.414l1.414,0l1.414,1.414l0.707,2.122l2.121,-0.708l0.708,-2.121l-2.122,-0.707l-1.414,-1.414l0,-1.414l1.414,-1.415l0,-1.414l-1.414,0l-1.414,1.414l-12.021,-12.02l-3.535,-0.707Z"/><path d="M22.101,22.101l3.535,0.707l12.021,12.02l1.414,-1.414l1.414,0l0,1.414l-1.414,1.415l0,1.414l1.414,1.414l2.122,0.707l-0.708,2.121l-2.121,0.708l-0.707,-2.122l-1.414,-1.414l-1.414,0l-1.415,1.414l-1.414,0l0,-1.414l1.414,-1.414l-12.02,-12.021l-0.707,-3.535Zm14.555,14.555c0.059,0.107 0.107,0.218 0.146,0.332l0.186,-0l-0,-0.186c-0.114,-0.039 -0.225,-0.087 -0.332,-0.146Z"/><path d="M32,16c8.831,0 16,7.169 16,16c0,8.831 -7.169,16 -16,16c-8.831,0 -16,-7.169 -16,-16c0,-8.831 7.169,-16 16,-16Zm0,2.083c-7.681,0 -13.917,6.236 -13.917,13.917c0,7.681 6.236,13.917 13.917,13.917c7.681,-0 13.917,-6.236 13.917,-13.917c-0,-7.681 -6.236,-13.917 -13.917,-13.917Z"/></g></svg>');
}
.event-icon {
	height: 48px;
	width:  48px;
	mask-repeat: no-repeat;
	mask-size: 100%;
	background: lightgray;
	mask-image: url('data:image/svg+xml;utf8, <svg width="100%" height="100%" viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="Event"><path d="M16,32l10.667,0l5.333,13.333l5.333,-13.333l10.667,0c-0,8.831 -7.169,16 -16,16c-8.831,0 -16,-7.169 -16,-16Z"/><path d="M16,32l10.667,0l5.333,13.333l5.333,-13.333l10.667,0c-0,8.831 -7.169,16 -16,16c-8.831,0 -16,-7.169 -16,-16Zm13.928,13.763l-4.672,-11.68l-7.017,0c0.905,6.019 5.669,10.78 11.689,11.68Zm4.144,0c6.02,-0.9 10.784,-5.661 11.689,-11.68l-7.017,0l-4.672,11.68Z"/><path d="M32,48c-8.831,0 -16,-7.169 -16,-16c-0,-8.831 7.169,-16 16,-16c8.831,0 16,7.169 16,16c-0,8.831 -7.169,16 -16,16Zm-0,-2.083c7.681,-0 13.917,-6.236 13.917,-13.917c-0,-7.681 -6.236,-13.917 -13.917,-13.917c-7.681,0 -13.917,6.236 -13.917,13.917c0,7.681 6.236,13.917 13.917,13.917Z"/><path d="M37.333,32l-10.666,0l5.333,-13.333l5.333,13.333Z"/><path d="M37.333,32l-10.666,0l5.333,-13.333l5.333,13.333Zm-3.077,-2.083l-2.256,-5.641l-2.256,5.641l4.512,-0Z"/></g></svg>');
}
.stairs-down-icon {
	height: 48px;
	width:  48px;
	mask-repeat: no-repeat;
	mask-size: 100%;
	background: lightgray;
	mask-image: url('data:image/svg+xml;utf8, <svg width="100%" height="100%" viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="Stairs_Down"><path d="M26,28l-6,-4l6,0l-0,4Zm6,4l-6,-4l6,0l0,4Zm6,4l-6,-4l6,0l0,4Zm0,0l6,0l0,4l-6,-4Z"/><path d="M32,48c-8.831,-0 -16,-7.169 -16,-16c-0,-8.831 7.169,-16 16,-16c8.831,-0 16,7.169 16,16c-0,8.831 -7.169,16 -16,16Zm-0,-2.083c7.681,-0 13.917,-6.236 13.917,-13.917c-0,-7.681 -6.236,-13.917 -13.917,-13.917c-7.681,0 -13.917,6.236 -13.917,13.917c0,7.681 6.236,13.917 13.917,13.917Z"/><path d="M45.3,40.893c-2.872,4.284 -7.759,7.107 -13.3,7.107c-8.831,-0 -16,-7.169 -16,-16c0,-3.285 0.992,-6.34 2.693,-8.882l26.607,17.775Zm-13.3,5.107l4,-5l-2,-0l0,-5l-4,0l0,5l-2,-0l4,5Z"/><path d="M45.3,40.893c-2.872,4.284 -7.759,7.107 -13.3,7.107c-8.831,-0 -16,-7.169 -16,-16c0,-3.285 0.992,-6.34 2.693,-8.882l26.607,17.775Zm-13.3,5.107l4,-5l-2,-0l0,-5l-4,0l0,5l-2,-0l4,5Zm4.083,-8.759l0,1.677c0.768,0.031 1.46,0.483 1.795,1.18c0.347,0.721 0.249,1.578 -0.251,2.203l-2.634,3.292c2.854,-0.626 5.381,-2.131 7.284,-4.214l-6.194,-4.138Zm-7.076,8.352l-2.634,-3.292c-0.5,-0.625 -0.598,-1.482 -0.251,-2.203c0.335,-0.697 1.027,-1.149 1.795,-1.18l-0,-2.918c-0,-1.151 0.932,-2.083 2.083,-2.083l1.107,-0c-5.808,-3.881 -11.71,-7.824 -11.71,-7.824c-0.843,1.794 -1.314,3.796 -1.314,5.907c0,6.653 4.679,12.223 10.924,13.593Z"/></g></svg>');
}
.stairs-up-icon {
	height: 48px;
	width:  48px;
	mask-repeat: no-repeat;
	mask-size: 100%;
	background: lightgray;
	mask-image: url('data:image/svg+xml;utf8, <svg width="100%" height="100%" viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="Stairs_Up"><path d="M26,28l-6,-4l6,0l-0,4Zm6,4l-6,-4l6,0l0,4Zm6,4l-6,-4l6,0l0,4Zm0,0l6,0l0,4l-6,-4Z"/><path d="M32,48c-8.831,-0 -16,-7.169 -16,-16c-0,-8.831 7.169,-16 16,-16c8.831,-0 16,7.169 16,16c-0,8.831 -7.169,16 -16,16Zm-0,-2.083c7.681,-0 13.917,-6.236 13.917,-13.917c-0,-7.681 -6.236,-13.917 -13.917,-13.917c-7.681,0 -13.917,6.236 -13.917,13.917c0,7.681 6.236,13.917 13.917,13.917Z"/><path d="M45.3,40.893c-2.872,4.284 -7.759,7.107 -13.3,7.107c-8.831,-0 -16,-7.169 -16,-16c0,-3.285 0.992,-6.34 2.693,-8.882l26.607,17.775Zm-13.3,-4.893l-4,5l2,0l-0,5l4,0l0,-5l2,0l-4,-5Z"/><path d="M45.3,40.893c-2.872,4.284 -7.759,7.107 -13.3,7.107c-8.831,-0 -16,-7.169 -16,-16c0,-3.285 0.992,-6.34 2.693,-8.882l26.607,17.775Zm-17.383,4.414l-0,-2.225c-0.768,-0.031 -1.46,-0.483 -1.795,-1.18c-0.347,-0.721 -0.249,-1.578 0.251,-2.203l4,-5c0.243,-0.304 0.563,-0.53 0.92,-0.659c-5.868,-3.92 -11.896,-7.947 -11.896,-7.947c-0.843,1.794 -1.314,3.796 -1.314,5.907c0,6.26 4.143,11.56 9.834,13.307Zm7.259,-8.672l2.451,3.064c0.5,0.625 0.598,1.482 0.251,2.203c-0.335,0.697 -1.027,1.149 -1.795,1.18l0,2.225c2.407,-0.739 4.537,-2.114 6.194,-3.928l-7.101,-4.744Zm-3.176,-0.635l-4,5l2,-0l-0,5l4,-0l0,-5l2,-0l-4,-5Z"/></g></svg>');
}

.locked-icon {
	height: 24px;
	width:  24px;
	mask-repeat: no-repeat;
	mask-size: 100%;
	background: lightgray;
	mask-image: url('data:image/svg+xml;utf8, <svg width="100%" height="100%" viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="Locked"><path d="M32,0c17.661,0 32,14.339 32,32c-0,17.661 -14.339,32 -32,32c-17.661,-0 -32,-14.339 -32,-32c0,-17.661 14.339,-32 32,-32Zm-0,2.083c-16.511,0 -29.917,13.406 -29.917,29.917c0,16.511 13.406,29.917 29.917,29.917c16.511,-0 29.917,-13.406 29.917,-29.917c-0,-16.511 -13.406,-29.917 -29.917,-29.917Z"/><path d="M16,48l0,-18l6,-4l20,0l6,4l0,18l-8,4l-14,0l-10,-4Zm13.779,-10.674l-1.779,10.674l8,0l-1.779,-10.674c1.072,-0.717 1.779,-1.94 1.779,-3.326c0,-2.208 -1.751,-4 -3.958,-4c-2.208,-0 -4.042,1.792 -4.042,4c0,1.386 0.707,2.609 1.779,3.326Z"/><path d="M16,48l0,-18l6,-4l20,0l6,4l0,18l-8,4l-14,0l-10,-4Zm0.417,-0.282l9.663,3.865l13.822,0l7.681,-3.841l0,-17.519l-5.709,-3.806l-15.763,-0l-3.985,-0l-5.709,3.806l-0,17.495Zm12.908,-10.204c-1.058,-0.807 -1.742,-2.081 -1.742,-3.514c0,-2.436 2.022,-4.417 4.459,-4.417c2.438,0 4.375,1.978 4.375,4.417c-0,1.433 -0.684,2.707 -1.742,3.514l1.736,10.418c0.02,0.12 -0.014,0.244 -0.093,0.337c-0.079,0.094 -0.196,0.148 -0.318,0.148l-8,-0c-0.122,-0 -0.239,-0.054 -0.318,-0.148c-0.079,-0.093 -0.113,-0.217 -0.093,-0.337l1.736,-10.418Zm0.454,-0.188l-1.779,10.674l8,0l-1.779,-10.674c1.072,-0.717 1.779,-1.94 1.779,-3.326c0,-2.208 -1.751,-4 -3.958,-4c-2.208,-0 -4.042,1.792 -4.042,4c0,1.386 0.707,2.609 1.779,3.326Z"/><path d="M22,28l0,-6c0,0 0,-10 10,-10c10,0 10,10 10,10l0,6l-4,0l0,-6c0,0 0,-6 -6,-6c-6,0 -6,6 -6,6l0,6l-4,0Z"/></g></svg>');
}

.trapped-icon {
	height: 24px;
	width:  24px;
	mask-repeat: no-repeat;
	mask-size: 100%;
	background: lightgray;
	mask-image: url('data:image/svg+xml;utf8, <svg width="100%" height="100%" viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="Trapped"><path d="M32,0c17.661,0 32,14.339 32,32c-0,17.661 -14.339,32 -32,32c-17.661,-0 -32,-14.339 -32,-32c0,-17.661 14.339,-32 32,-32Zm0,2.083c-16.511,0 -29.917,13.406 -29.917,29.917c0,16.511 13.406,29.917 29.917,29.917c16.511,-0 29.917,-13.406 29.917,-29.917c-0,-16.511 -13.406,-29.917 -29.917,-29.917Z"/><path d="M-0,32c-0,-2.92 0.392,-5.749 1.126,-8.437l3.195,4.437l13.679,-6l-4,16l12,-4l-3.101,10.852c-0.407,0.891 -0.687,1.852 -0.817,2.86l-0.082,0.288l0.049,0c-0.032,0.329 -0.049,0.663 -0.049,1c0,5.519 4.481,10 10,10c5.519,-0 10,-4.481 10,-10c-0,-0.337 -0.017,-0.671 -0.049,-1l0.049,-0l-0.082,-0.288c-0.13,-1.008 -0.41,-1.969 -0.817,-2.86l-3.101,-10.852l12,4l-4,-16l13.736,6l3.142,-4.422c0.732,2.684 1.122,5.508 1.122,8.422c-0,13.74 -8.678,25.469 -20.848,30l-22.304,-0c-12.17,-4.531 -20.848,-16.26 -20.848,-30Zm32,10c3.756,-0 6.806,3.05 6.806,6.806c0,3.757 -3.05,6.806 -6.806,6.806c-3.756,0 -6.806,-3.049 -6.806,-6.806c-0,-3.756 3.05,-6.806 6.806,-6.806Z"/><path d="M32,42c3.756,-0 6.806,3.05 6.806,6.806c0,3.757 -3.05,6.806 -6.806,6.806c-3.756,0 -6.806,-3.049 -6.806,-6.806c-0,-3.756 3.05,-6.806 6.806,-6.806Zm-0,3.125c-2.032,-0 -3.681,1.65 -3.681,3.681c-0,2.032 1.649,3.681 3.681,3.681c2.032,0 3.681,-1.649 3.681,-3.681c0,-2.031 -1.649,-3.681 -3.681,-3.681Zm9.843,5.646c0.103,-0.575 0.157,-1.167 0.157,-1.771c-0,-0.337 -0.017,-0.671 -0.049,-1l0.049,-0l-0.082,-0.288c-0.13,-1.008 -0.41,-1.969 -0.817,-2.86l-3.101,-10.852l12,4l-4,-16l13.736,6l3.142,-4.422c0.732,2.684 1.122,5.508 1.122,8.422c-0,13.74 -8.678,25.469 -20.848,30l-22.304,-0c-12.17,-4.531 -20.848,-16.26 -20.848,-30c-0,-2.92 0.392,-5.749 1.126,-8.437l3.195,4.437l13.679,-6l-4,16l12,-4l-3.101,10.852c-0.407,0.891 -0.687,1.852 -0.817,2.86l-0.082,0.288l0.049,0c-0.032,0.329 -0.049,0.663 -0.049,1c0,0.677 0.067,1.338 0.196,1.977l-0.147,0.111l0,0.037l0.149,-0.135c0.924,4.567 4.964,8.01 9.802,8.01c4.792,-0 8.801,-3.378 9.774,-7.88c0.059,0.003 0.117,0.005 0.177,0.005l-0,-0.037l-0.147,-0.111c0.013,-0.066 0.026,-0.131 0.038,-0.197l0.076,0.057l-0.075,-0.066Zm-18.485,8.104c-2.747,-2.406 -4.483,-5.94 -4.483,-9.875c0,-0.442 0.022,-0.879 0.065,-1.309l0.017,0.019c0,-0.132 0.009,-0.265 0.026,-0.398c0.007,-0.055 0.015,-0.111 0.023,-0.166l-0.009,-0.011l0.02,-0.071c0.171,-1.151 0.491,-2.253 0.938,-3.281c-0,0 1.413,-4.945 1.413,-4.945l-6.38,2.127c-1.082,0.36 -2.274,0.103 -3.111,-0.672c-0.837,-0.775 -1.185,-1.944 -0.909,-3.051l2.456,-9.822l-7.848,3.442c-0.795,0.349 -1.669,0.342 -2.43,0.034c-0.014,0.366 -0.021,0.734 -0.021,1.104c-0,12.205 7.588,22.651 18.301,26.875l1.932,-0Zm21.625,-11.811l0.02,0.071l-0.009,0.011c0.008,0.055 0.016,0.111 0.023,0.166l-1.023,1.164l-1.75,2.325l2.816,-3.11c0.043,0.43 0.065,0.867 0.065,1.309c-0,3.935 -1.736,7.468 -4.482,9.875c1.197,-0.001 1.933,-0.001 1.933,-0.001c10.711,-4.224 18.299,-14.67 18.299,-26.874c-0,-0.362 -0.007,-0.723 -0.02,-1.082c-0.746,0.286 -1.595,0.284 -2.37,-0.054l-7.912,-3.456l2.459,9.834c0.276,1.107 -0.072,2.276 -0.909,3.051c-0.837,0.775 -2.029,1.032 -3.111,0.672l-6.38,-2.127c0,0 1.41,4.934 1.411,4.94c0.449,1.033 0.769,2.135 0.94,3.286Z"/></g></svg>');
}
</style>

<style>
.corridor-bar-fill-icon {
	height: 48px;
	width:  48px;
	mask-repeat: no-repeat;
	mask-size: 100%;
	background: black;
	mask-image: url('data:image/svg+xml;utf8, <svg width="100%" height="100%" viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="Corridor_Bar_Fill"><rect x="0" y="20" width="64" height="24"/><path d="M0,20l64,0l0,24l-64,0l0,-24Zm2.083,2.083l0,19.834l59.834,-0l-0,-19.834l-59.834,0Z"/></g></svg>');
}
.corridor-end-fill-icon {
	height: 48px;
	width:  48px;
	mask-repeat: no-repeat;
	mask-size: 100%;
	background: black;
	mask-image: url('data:image/svg+xml;utf8, <svg width="100%" height="100%" viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="Corridor_End_Fill"><rect x="20" y="20" width="44" height="24"/><path d="M20,20l44,0l0,24l-44,0l0,-24Zm2.083,2.083l0,19.834l39.834,-0l-0,-19.834l-39.834,0Z"/></g></svg>');
}
.corridor-plus-fill-icon {
	height: 48px;
	width:  48px;
	mask-repeat: no-repeat;
	mask-size: 100%;
	background: black;
	mask-image: url('data:image/svg+xml;utf8, <svg width="100%" height="100%" viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="Corridor_Plus_Fill"><path d="M44,0l0,20l20,0l0,24l-20,0l0,20l-24,0l0,-20l-20,0l0,-24l20,0l0,-20l24,0Z"/><path d="M44,0l0,20l20,0l0,24l-20,0l0,20l-24,0l0,-20l-20,0l0,-24l20,0l0,-20l24,0Zm-2.083,2.083c-0,0 -19.834,0 -19.834,0l0,17.917c0,1.151 -0.932,2.083 -2.083,2.083l-17.917,0c0,0 0,19.834 0,19.834l17.917,-0c1.151,-0 2.083,0.932 2.083,2.083l0,17.917c0,-0 19.834,-0 19.834,-0l-0,-17.917c-0,-1.151 0.932,-2.083 2.083,-2.083l17.917,-0c-0,-0 -0,-19.834 -0,-19.834l-17.917,0c-1.151,0 -2.083,-0.932 -2.083,-2.083l-0,-17.917Z"/></g></svg>');
}
.corridor-tee-fill-icon {
	height: 48px;
	width:  48px;
	mask-repeat: no-repeat;
	mask-size: 100%;
	background: black;
	mask-image: url('data:image/svg+xml;utf8, <svg width="100%" height="100%" viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="Corridor_Tee_Fill"><path d="M0,20l64,0l0,24l-20,0l0,20l-24,0l0,-20l-20,0l0,-24Z"/><path d="M0,20l64,0l0,24l-20,0l0,20l-24,0l0,-20l-20,0l0,-24Zm2.083,2.083c0,0 0,19.834 0,19.834l17.917,-0c1.151,-0 2.083,0.932 2.083,2.083l0,17.917c0,-0 19.834,-0 19.834,-0l-0,-17.917c-0,-1.151 0.932,-2.083 2.083,-2.083l17.917,-0l-0,-19.834l-59.834,0Z"/></g></svg>');
}
.corridor-turn-fill-icon {
	height: 48px;
	width:  48px;
	mask-repeat: no-repeat;
	mask-size: 100%;
	background: black;
	mask-image: url('data:image/svg+xml;utf8, <svg width="100%" height="100%" viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="Corridor_Turn_Fill"><path d="M20,20l44,0l0,24l-20,0l0,20l-24,0l0,-44Z"/><path d="M20,20l44,0l0,24l-20,0l0,20l-24,0l0,-44Zm2.083,2.083l0,39.834c0,-0 19.834,-0 19.834,-0l-0,-17.917c-0,-1.151 0.932,-2.083 2.083,-2.083l17.917,-0l-0,-19.834l-39.834,0Z"/></g></svg>');
}
.room-bar-fill-icon {
	height: 48px;
	width:  48px;
	mask-repeat: no-repeat;
	mask-size: 100%;
	background: black;
	mask-image: url('data:image/svg+xml;utf8, <svg width="100%" height="100%" viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="Room_Bar_Fill"><path d="M0,20l4,0l0,-16l56,0l0,16l4,0l0,24l-4,-0l0,16l-56,0l0,-16l-4,0l0,-24Z"/><path d="M0,20l4,0l0,-16l56,0l0,16l4,0l0,24l-4,-0l0,16l-56,0l0,-16l-4,0l0,-24Zm2.083,2.083l0,19.834l1.917,-0c1.151,-0 2.083,0.932 2.083,2.083c0,0 0,13.917 0,13.917l51.834,-0l-0,-13.917c-0,-1.151 0.932,-2.083 2.083,-2.083l1.917,-0l-0,-19.834l-1.917,0c-1.151,0 -2.083,-0.932 -2.083,-2.083c-0,0 -0,-13.917 -0,-13.917l-51.834,0l0,13.917c0,1.151 -0.932,2.083 -2.083,2.083l-1.917,0Z"/></g></svg>');
}
.room-end-fill-icon {
	height: 48px;
	width:  48px;
	mask-repeat: no-repeat;
	mask-size: 100%;
	background: black;
	mask-image: url('data:image/svg+xml;utf8, <svg width="100%" height="100%" viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="Room_End_Fill"><path d="M4,4l56,0l0,16l4,0l0,24l-4,0l0,16l-56,0l0,-56Z"/><path d="M4,4l56,0l0,16l4,0l0,24l-4,0l0,16l-56,0l0,-56Zm2.083,2.083c0,0 0,51.834 0,51.834l51.834,-0l-0,-13.917c-0,-1.151 0.932,-2.083 2.083,-2.083l1.917,-0l-0,-19.834l-1.917,0c-1.151,0 -2.083,-0.932 -2.083,-2.083c-0,0 -0,-13.917 -0,-13.917l-51.834,0Z"/></g></svg>');
}
.room-plus-fill-icon {
	height: 48px;
	width:  48px;
	mask-repeat: no-repeat;
	mask-size: 100%;
	background: black;
	mask-image: url('data:image/svg+xml;utf8, <svg width="100%" height="100%" viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="Room_Plus_Fill"><path d="M44,0l0,4l16,0l-0,16l4,0l0,24l-4,0l0,16l-16,-0l0,4l-24,0l0,-4l-16,0l0,-16l-4,0l0,-24l4,0l0,-16l16,0l0,-4l24,0Z"/><path d="M44,0l0,4l16,0l-0,16l4,0l0,24l-4,0l0,16l-16,-0l0,4l-24,0l0,-4l-16,0l0,-16l-4,0l0,-24l4,0l0,-16l16,0l0,-4l24,0Zm-2.083,2.083l-19.834,0l0,1.917c0,1.151 -0.932,2.083 -2.083,2.083l-13.917,0l0,13.917c0,1.151 -0.932,2.083 -2.083,2.083l-1.917,0l0,19.834l1.917,-0c1.151,-0 2.083,0.932 2.083,2.083l0,13.917l13.917,-0c1.151,-0 2.083,0.932 2.083,2.083l0,1.917l19.834,-0l-0,-1.917c-0,-1.151 0.932,-2.083 2.083,-2.083l13.917,-0l-0,-13.917c-0,-1.151 0.932,-2.083 2.083,-2.083l1.917,-0l-0,-19.834l-1.917,0c-1.151,0 -2.083,-0.932 -2.083,-2.083l-0,-13.917l-13.917,0c-1.151,0 -2.083,-0.932 -2.083,-2.083l-0,-1.917Z"/></g></svg>');
}
.room-tee-fill-icon {
	height: 48px;
	width:  48px;
	mask-repeat: no-repeat;
	mask-size: 100%;
	background: black;
	mask-image: url('data:image/svg+xml;utf8, <svg width="100%" height="100%" viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="Room_Tee_Fill"><path d="M0,20l4,0l0,-16l56,0l0,16l4,0l0,24l-4,0l0,16l-16,0l0,4l-24,0l-0,-4l-16,0l-0,-16l-4,0l0,-24Z"/><path d="M0,20l4,0l0,-16l56,0l0,16l4,0l0,24l-4,0l0,16l-16,0l0,4l-24,0l-0,-4l-16,0l-0,-16l-4,0l0,-24Zm2.083,2.083l0,19.834l1.917,-0c1.151,-0 2.083,0.932 2.083,2.083l0,13.917l13.917,-0c1.151,-0 2.083,0.932 2.083,2.083l0,1.917l19.834,-0l-0,-1.917c-0,-1.151 0.932,-2.083 2.083,-2.083l13.917,-0l-0,-13.917c-0,-1.151 0.932,-2.083 2.083,-2.083l1.917,-0l-0,-19.834l-1.917,0c-1.151,0 -2.083,-0.932 -2.083,-2.083c-0,0 -0,-13.917 -0,-13.917l-51.834,0l0,13.917c0,1.151 -0.932,2.083 -2.083,2.083l-1.917,0Z"/></g></svg>');
}
.room-turn-fill-icon {
	height: 48px;
	width:  48px;
	mask-repeat: no-repeat;
	mask-size: 100%;
	background: black;
	mask-image: url('data:image/svg+xml;utf8, <svg width="100%" height="100%" viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="Room_Turn_Fill"><path d="M4,4l56,0l0,16l4,0l0,24l-4,0l0,16l-16,0l0,4l-24,0l0,-4l-16,0l0,-56Z"/><path d="M4,4l56,0l0,16l4,0l0,24l-4,0l0,16l-16,0l0,4l-24,0l0,-4l-16,0l0,-56Zm2.083,2.083l0,51.834l13.917,-0c1.151,-0 2.083,0.932 2.083,2.083l0,1.917l19.834,-0l-0,-1.917c-0,-1.151 0.932,-2.083 2.083,-2.083l13.917,-0l-0,-13.917c-0,-1.151 0.932,-2.083 2.083,-2.083l1.917,-0l-0,-19.834l-1.917,0c-1.151,0 -2.083,-0.932 -2.083,-2.083c-0,0 -0,-13.917 -0,-13.917l-51.834,0Z"/></g></svg>');
}
</style>

<style>
.back-icon {
	height: 48px;
	width:  48px;
	mask-repeat: no-repeat;
	mask-size: 100%;
	background: black;
	mask-image: url('data:image/svg+xml;utf8, <svg width="100%" height="100%" viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="Back"><path d="M32,16c8.831,0 16,7.169 16,16c0,8.831 -7.169,16 -16,16c-8.831,0 -16,-7.169 -16,-16c0,-8.831 7.169,-16 16,-16Zm0,2.083c-7.681,0 -13.917,6.236 -13.917,13.917c0,7.681 6.236,13.917 13.917,13.917c7.681,-0 13.917,-6.236 13.917,-13.917c-0,-7.681 -6.236,-13.917 -13.917,-13.917Z"/><path d="M23,32l8,-8l0,4l-4,4l4,4l0,4l-8,-8Z"/><path d="M23,32l8,-8l0,4l-4,4l4,4l0,4l-8,-8Zm1.768,-0l4.982,4.982c0,0 0,-0.464 -0,-0.464l-4.518,-4.518l4.518,-4.518l-0,-0.464l-4.982,4.982Z"/><path d="M31,32l8,-8l0,4l-4,4l4,4l0,4l-8,-8Z"/><path d="M31,32l8,-8l0,4l-4,4l4,4l0,4l-8,-8Zm1.768,-0l4.982,4.982c0,0 0,-0.464 -0,-0.464l-4.518,-4.518l4.518,-4.518l-0,-0.464l-4.982,4.982Z"/></g></svg>');
}
.clipboard-icon {
	height: 48px;
	width:  48px;
	mask-repeat: no-repeat;
	mask-size: 100%;
	background: black;
	mask-image: url('data:image/svg+xml;utf8, <svg width="100%" height="100%" viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="Clipboard"><path d="M32,16c8.831,0 16,7.169 16,16c0,8.831 -7.169,16 -16,16c-8.831,0 -16,-7.169 -16,-16c0,-8.831 7.169,-16 16,-16Zm0,2.083c-7.681,0 -13.917,6.236 -13.917,13.917c0,7.681 6.236,13.917 13.917,13.917c7.681,-0 13.917,-6.236 13.917,-13.917c-0,-7.681 -6.236,-13.917 -13.917,-13.917Z"/><path d="M35,23l4.007,0l0.993,1l0,17l-1,1l-14,0l-1,-1l0,-17l1.014,-1l3.986,0c0,-1.656 1.344,-3 3,-3c1.656,0 3,1.344 3,3Zm-9,5l0,2l12,0l0,-2l-12,0Zm6,-7c-1.104,0 -2,0.896 -2,2c-0,1.104 0.896,2 2,2c1.104,0 2,-0.896 2,-2c0,-1.104 -0.896,-2 -2,-2Z"/><path d="M35,23l4.007,0l0.993,1l0,17l-1,1l-14,0l-1,-1l0,-17l1.014,-1l3.986,0c0,-1.656 1.344,-3 3,-3c1.656,0 3,1.344 3,3Zm-9,5l0,2l12,0l0,-2l-12,0Zm6,-7c-1.104,0 -2,0.896 -2,2c-0,1.104 0.896,2 2,2c1.104,0 2,-0.896 2,-2c0,-1.104 -0.896,-2 -2,-2Zm3,3.25c-0.49,1.174 -1.649,2 -3,2c-1.351,0 -2.51,-0.826 -3.001,-2l-3.472,-0l-0.277,0.273l-0,2.227l13.5,0l-0,-2.235l-0.263,-0.265l-3.487,0Zm3.75,7l-13.5,0l-0,9.232l0.268,0.268l12.964,0l0.268,-0.268l-0,-9.232Z"/></g></svg>');
}
.close-icon {
	height: 48px;
	width:  48px;
	mask-repeat: no-repeat;
	mask-size: 100%;
	background: black;
	mask-image: url('data:image/svg+xml;utf8, <svg width="100%" height="100%" viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="Close"><path d="M32,16c8.831,0 16,7.169 16,16c0,8.831 -7.169,16 -16,16c-8.831,0 -16,-7.169 -16,-16c0,-8.831 7.169,-16 16,-16Zm0,2.083c-7.681,0 -13.917,6.236 -13.917,13.917c0,7.681 6.236,13.917 13.917,13.917c7.681,-0 13.917,-6.236 13.917,-13.917c-0,-7.681 -6.236,-13.917 -13.917,-13.917Z"/><path d="M36.243,24.929l-4.243,4.243l-4.243,-4.243l-2.828,2.828l4.243,4.243l-4.243,4.243l2.828,2.828l4.243,-4.243l4.243,4.243l2.828,-2.828l-4.243,-4.243l4.243,-4.243l-2.828,-2.828Z"/><path d="M35.877,25.295l0.366,0.884l0.366,-0.884l2.462,2.462l-4.243,4.243l4.243,4.243l-2.828,2.828l-4.243,-4.243l-4.243,4.243l-2.828,-2.828l4.243,-4.243l-4.243,-4.243l2.828,-2.828l4.243,4.243l3.877,-3.877Zm0.366,1.402l-4.243,4.242l-4.243,-4.242c0,-0 -1.06,1.06 -1.06,1.06l4.242,4.243l-4.242,4.243c-0,-0 1.06,1.06 1.06,1.06l4.243,-4.242l4.243,4.242c-0,0 1.06,-1.06 1.06,-1.06l-4.242,-4.243c-0,0 4.242,-4.243 4.242,-4.243l-1.06,-1.06Z"/></g></svg>');
}
.download-icon {
	height: 48px;
	width:  48px;
	mask-repeat: no-repeat;
	mask-size: 100%;
	background: black;
	mask-image: url('data:image/svg+xml;utf8, <svg width="100%" height="100%" viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="Download"><path d="M32,16c8.831,0 16,7.169 16,16c0,8.831 -7.169,16 -16,16c-8.831,0 -16,-7.169 -16,-16c0,-8.831 7.169,-16 16,-16Zm0,2.083c-7.681,0 -13.917,6.236 -13.917,13.917c0,7.681 6.236,13.917 13.917,13.917c7.681,-0 13.917,-6.236 13.917,-13.917c-0,-7.681 -6.236,-13.917 -13.917,-13.917Z"/><path d="M23,32l5,0l4,5l4,-5l5,0l2,2l0,4l-2,2l-18,0l-2,-2l0,-4l2,-2Zm16,2c-1.104,0 -2,0.896 -2,2c0,1.104 0.896,2 2,2c1.104,0 2,-0.896 2,-2c0,-1.104 -0.896,-2 -2,-2Z"/><path d="M23,32l5,0l4,5l4,-5l5,0l2,2l0,4l-2,2l-18,0l-2,-2l0,-4l2,-2Zm14.268,6.75c-0.912,-0.576 -1.518,-1.593 -1.518,-2.75c0,-1.157 0.606,-2.174 1.518,-2.75l-0.667,0l-3.625,4.531l-1.952,-0c-0,-0 -3.625,-4.531 -3.625,-4.531l-3.881,-0c-0,-0 -1.268,1.268 -1.268,1.268c0,-0 0,2.964 0,2.964l1.268,1.268l13.75,-0Zm1.732,-4.75c-1.104,0 -2,0.896 -2,2c0,1.104 0.896,2 2,2c1.104,0 2,-0.896 2,-2c0,-1.104 -0.896,-2 -2,-2Z"/><path d="M32,34l-4,-5l2,-0l0,-8l4,0l0,8l2,0l-4,5Z"/><path d="M32,34l-4,-5l2,-0l0,-8l4,0l0,8l2,0l-4,5Zm-1.399,-3.75l1.399,1.749l1.399,-1.749l-0.649,0l0,-8l-1.5,0l-0,8l-0.649,0Z"/></g></svg>');
}
.edit-icon {
	height: 48px;
	width:  48px;
	mask-repeat: no-repeat;
	mask-size: 100%;
	background: black;
	mask-image: url('data:image/svg+xml;utf8, <svg width="100%" height="100%" viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="Edit"><path d="M32,16c8.831,0 16,7.169 16,16c0,8.831 -7.169,16 -16,16c-8.831,0 -16,-7.169 -16,-16c0,-8.831 7.169,-16 16,-16Zm0,2.083c-7.681,0 -13.917,6.236 -13.917,13.917c0,7.681 6.236,13.917 13.917,13.917c7.681,-0 13.917,-6.236 13.917,-13.917c-0,-7.681 -6.236,-13.917 -13.917,-13.917Z"/><path d="M37.5,26.5c1,1 1,3 1,3l-9.5,10l-5,1.5l-0.5,-0.5l1.5,-5l9.5,-10c0,-0 2,-0 3,1Zm-2,-2l2,-2l2,-0l2,2l0,2l-2,2c0,-0 0,-2 -1,-3c-1,-1 -3,-1 -3,-1Z"/><path d="M37.5,26.5c1,1 1,3 1,3l-9.5,10l-5,1.5l-0.5,-0.5l1.5,-5l9.5,-10c0,-0 2,-0 3,1Zm-12.35,12.85l3.173,-0.952c-0,0 8.893,-9.361 8.893,-9.362c-0.024,-0.204 -0.066,-0.456 -0.138,-0.719c-0.089,-0.327 -0.214,-0.686 -0.462,-0.933c-0.247,-0.248 -0.606,-0.373 -0.933,-0.462c-0.247,-0.067 -0.486,-0.108 -0.683,-0.133l-8.888,9.356l-0.962,3.205Zm10.35,-14.85l2,-2l2,-0l2,2l0,2l-2,2c0,-0 0,-2 -1,-3c-1,-1 -3,-1 -3,-1Zm3.884,0.116c0.381,0.382 0.657,0.873 0.855,1.377l0.011,-0.011c0,0 0,-0.964 -0,-0.964l-1.268,-1.268l-0.964,-0l-0.011,0.011c0.504,0.198 0.995,0.474 1.377,0.855Z"/></g></svg>');
}
.full-screen-icon {
	height: 48px;
	width:  48px;
	mask-repeat: no-repeat;
	mask-size: 100%;
	background: black;
	mask-image: url('data:image/svg+xml;utf8, <svg width="100%" height="100%" viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="Full_Screen"><path d="M32,16c8.831,0 16,7.169 16,16c0,8.831 -7.169,16 -16,16c-8.831,0 -16,-7.169 -16,-16c0,-8.831 7.169,-16 16,-16Zm0,2.083c-7.681,0 -13.917,6.236 -13.917,13.917c0,7.681 6.236,13.917 13.917,13.917c7.681,-0 13.917,-6.236 13.917,-13.917c-0,-7.681 -6.236,-13.917 -13.917,-13.917Z"/><path d="M34,40l0,-2l4,0l0,-4l2,0l0,6l-6,0Z"/><path d="M24,30l0,-6l6,0l0,2l-4,0l0,4l-2,0Z"/><path d="M34,24l6,0l0,6l-2,0l0,-4l-4,0l0,-2Z"/><path d="M24,34l2,0l0,4l4,0l0,2l-6,0l0,-6Z"/></g></svg>');
}
.home-icon {
	height: 48px;
	width:  48px;
	mask-repeat: no-repeat;
	mask-size: 100%;
	background: black;
	mask-image: url('data:image/svg+xml;utf8, <svg width="100%" height="100%" viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="Home"><path d="M32,16c8.831,0 16,7.169 16,16c0,8.831 -7.169,16 -16,16c-8.831,0 -16,-7.169 -16,-16c0,-8.831 7.169,-16 16,-16Zm0,2.083c-7.681,0 -13.917,6.236 -13.917,13.917c0,7.681 6.236,13.917 13.917,13.917c7.681,-0 13.917,-6.236 13.917,-13.917c-0,-7.681 -6.236,-13.917 -13.917,-13.917Z"/><path d="M32,21l-10,8l0,1l20,0l0,-1l-10,-8Z"/><path d="M32,21l10,8l0,1l-20,0l0,-1l10,-8Zm-7.687,7.75l15.374,0l-7.687,-6.149l-7.687,6.149Z"/><path d="M24,40l6.07,-0l-0.07,-6l4,0l-0.017,6l6.017,0l0,-11l-16,0l0,11Z"/><path d="M24,40l0,-11l16,0l0,11l-6.017,-0l0.017,-6l-4,0l0.07,6l-6.07,0Zm1.25,-1.25l3.555,0l-0.055,-4.735c-0.004,-0.334 0.126,-0.656 0.361,-0.894c0.235,-0.237 0.555,-0.371 0.889,-0.371l4,0c0.332,-0 0.651,0.132 0.885,0.367c0.235,0.236 0.366,0.554 0.365,0.887c-0,-0 -0.014,4.746 -0.014,4.746l3.514,0l-0,-8.5l-13.5,-0l0,8.5Z"/></g></svg>');
}
.info-icon {
	height: 48px;
	width:  48px;
	mask-repeat: no-repeat;
	mask-size: 100%;
	background: black;
	mask-image: url('data:image/svg+xml;utf8, <svg width="100%" height="100%" viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="Information"><path d="M32,16c8.831,0 16,7.169 16,16c0,8.831 -7.169,16 -16,16c-8.831,0 -16,-7.169 -16,-16c0,-8.831 7.169,-16 16,-16Zm0,2.083c-7.681,0 -13.917,6.236 -13.917,13.917c0,7.681 6.236,13.917 13.917,13.917c7.681,-0 13.917,-6.236 13.917,-13.917c-0,-7.681 -6.236,-13.917 -13.917,-13.917Z"/><rect x="30" y="30" width="4" height="12"/><path d="M30,42l0,-12l4,0l0,12l-4,0Zm1.25,-1.25c0,-0 1.5,-0 1.5,0l0,-9.5c0,-0 -1.5,-0 -1.5,-0l0,9.5Z"/><circle cx="32" cy="24.5" r="2.5"/><path d="M32,22c1.38,0 2.5,1.12 2.5,2.5c-0,1.38 -1.12,2.5 -2.5,2.5c-1.38,0 -2.5,-1.12 -2.5,-2.5c0,-1.38 1.12,-2.5 2.5,-2.5Zm-0,1.25c-0.69,0 -1.25,0.56 -1.25,1.25c0,0.69 0.56,1.25 1.25,1.25c0.69,0 1.25,-0.56 1.25,-1.25c-0,-0.69 -0.56,-1.25 -1.25,-1.25Z"/></g></svg>');
}
.next-icon {
	height: 48px;
	width:  48px;
	mask-repeat: no-repeat;
	mask-size: 100%;
	background: black;
	mask-image: url('data:image/svg+xml;utf8, <svg width="100%" height="100%" viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="Next"><path d="M32,16c8.831,0 16,7.169 16,16c0,8.831 -7.169,16 -16,16c-8.831,0 -16,-7.169 -16,-16c0,-8.831 7.169,-16 16,-16Zm0,2.083c-7.681,0 -13.917,6.236 -13.917,13.917c0,7.681 6.236,13.917 13.917,13.917c7.681,-0 13.917,-6.236 13.917,-13.917c-0,-7.681 -6.236,-13.917 -13.917,-13.917Z"/><path d="M41,32l-8,-8l0,4l4,4l-4,4l0,4l8,-8Z"/><path d="M41,32l-8,8l0,-4l4,-4l-4,-4l0,-4l8,8Zm-1.768,0l-4.982,-4.982c0,-0 0,0.464 0,0.464l4.518,4.518l-4.518,4.518l0,0.464l4.982,-4.982Z"/><path d="M33,32l-8,-8l0,4l4,4l-4,4l0,4l8,-8Z"/><path d="M33,32l-8,8l0,-4l4,-4l-4,-4l0,-4l8,8Zm-1.768,0l-4.982,-4.982c0,-0 0,0.464 0,0.464l4.518,4.518l-4.518,4.518l0,0.464l4.982,-4.982Z"/></g></svg>');
}
.plus-icon {
	height: 48px;
	width:  48px;
	mask-repeat: no-repeat;
	mask-size: 100%;
	background: black;
	mask-image: url('data:image/svg+xml;utf8, <svg width="100%" height="100%" viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="Plus"><path d="M32,16c8.831,0 16,7.169 16,16c0,8.831 -7.169,16 -16,16c-8.831,0 -16,-7.169 -16,-16c0,-8.831 7.169,-16 16,-16Zm0,2.083c-7.681,0 -13.917,6.236 -13.917,13.917c0,7.681 6.236,13.917 13.917,13.917c7.681,-0 13.917,-6.236 13.917,-13.917c-0,-7.681 -6.236,-13.917 -13.917,-13.917Z"/><path d="M30,24l0,6l-6,0l0,4l6,0l0,6l4,0l0,-6l6,0l0,-4l-6,0l0,-6l-4,0Z"/><path d="M30,30l0,-6l4,0l0,6l6,0l0,4l-6,0l0,6l-4,0l0,-6l-6,0l0,-4l6,0Zm1.25,-4.75l0,6l-6,-0c-0,-0 0,1.5 -0,1.5l6,0l-0,6c-0,0 1.5,0 1.5,0l0,-6l6,0c0,0 0,-1.5 0,-1.5l-6,0c0,0 0,-6 -0,-6l-1.5,0Z"/></g></svg>');
}
.save-icon {
	height: 48px;
	width:  48px;
	mask-repeat: no-repeat;
	mask-size: 100%;
	background: black;
	mask-image: url('data:image/svg+xml;utf8, <svg width="100%" height="100%" viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="Save"><path d="M32,16c8.831,0 16,7.169 16,16c0,8.831 -7.169,16 -16,16c-8.831,0 -16,-7.169 -16,-16c0,-8.831 7.169,-16 16,-16Zm0,2.083c-7.681,0 -13.917,6.236 -13.917,13.917c0,7.681 6.236,13.917 13.917,13.917c7.681,-0 13.917,-6.236 13.917,-13.917c-0,-7.681 -6.236,-13.917 -13.917,-13.917Z"/><path d="M24,40l0,-16l12,0l4,4l0,12l-16,0Zm3,-13l-0,3l7,0l-0,-3l-7,0Zm5,5c-1.38,0 -2.5,1.12 -2.5,2.5c0,1.38 1.12,2.5 2.5,2.5c1.38,0 2.5,-1.12 2.5,-2.5c0,-1.38 -1.12,-2.5 -2.5,-2.5Z"/><path d="M24,40l0,-16l12,0l4,4l0,12l-16,0Zm1.25,-1.25l13.5,0l-0,-10.232l-3.268,-3.268l-10.232,0l-0,13.5Zm8.621,-7.5c1.123,0.648 1.879,1.861 1.879,3.25c0,2.07 -1.68,3.75 -3.75,3.75c-2.07,0 -3.75,-1.68 -3.75,-3.75c0,-1.389 0.756,-2.602 1.879,-3.25l-3.129,0c-0.69,-0 -1.25,-0.56 -1.25,-1.25l-0,-3c0,-0.69 0.56,-1.25 1.25,-1.25l7,0c0.69,0 1.25,0.56 1.25,1.25l-0,3c-0,0.69 -0.56,1.25 -1.25,1.25l-0.129,0Zm-6.871,-4.25l-0,3l7,0l-0,-3l-7,0Zm5,5c-1.38,0 -2.5,1.12 -2.5,2.5c0,1.38 1.12,2.5 2.5,2.5c1.38,0 2.5,-1.12 2.5,-2.5c0,-1.38 -1.12,-2.5 -2.5,-2.5Z"/></g></svg>');
}

</style>

<style>
.spacer-icon {
	height: 24px;
	width:  24px;
	background: transparent;
}

.no-icon {
	height: 24px;
	width:  24px;
}

.rot-0 {
	transform: rotate(0deg);
}

.rot-90 {
	transform: rotate(90deg);
}

.rot-180 {
	transform: rotate(180deg);
}

.rot-270 {
	transform: rotate(270deg);
}

.break {
  flex-basis: 100%;
  height: 0;
}

.center {
	margin: auto;
	text-align: center;
}

.center-h {
	margin-left: auto;
	margin-right: auto;
	text-align: center;
}

.center-v {
	margin-top: auto;
	margin-bottom: auto;
	text-align: center;
}

.right-justify {
	margin-left: auto;
	text-align: right;
}

.left-justify {
	margin-right: auto;
	text-align: left;
}

.capitalize {
	text-transform: capitalize;
}

.undiscovered {
	background-color: white;
}
.discovered {
	background-color: black;
}
.current {
	background-color: purple;
}

.container-button-1 {
	display: grid;
	grid-template-areas:
		"btn-1" "btn-1" "btn-1";
}

.container-button-2 {
	display: grid;
	grid-template-areas:
		"btn-1"
		"btn-2";
}

.container-button-3 {
	display: grid;
	grid-template-areas:
		"btn-1 btn-1"
		"btn-2 btn-3";
}

.container-button-4 {
	display: grid;
	grid-template-areas:
		"btn-f1 btn-2 btn-f2"
		"btn-1 btn-f3 btn-3"
		"btn-f4 btn-4 btn-f5";
}

.container-button-9 {
	display: grid;
	grid-template-areas:
		"btn-l btn-1 btn-2 btn-3 btn-r"
		"btn-l btn-4 btn-5 btn-6 btn-r"
		"btn-l btn-7 btn-8 btn-9 btn-r";
}

.btn-f { grid-area: btn-f; }

.btn-1 { grid-area: btn-1; }
.btn-2 { grid-area: btn-2; }
.btn-3 { grid-area: btn-3; }
.btn-4 { grid-area: btn-4; }
.btn-5 { grid-area: btn-5; }
.btn-6 { grid-area: btn-6; }
.btn-7 { grid-area: btn-7; }
.btn-8 { grid-area: btn-8; }
.btn-9 { grid-area: btn-9; }

.btn-l { grid-area: btn-l; }
.btn-r { grid-area: btn-r; }


.session-key:nth-of-type(odd) {
  background: lightgray;
}

.session-key:nth-of-type(even) {
  background: darkgray;
}

.black-text {
	color: black;
}

.inverted {
	filter: invert(1);
}
</style>

<title>Table Top Tapper</title>
</head>

<body class="body">

	<div class="canvas">

		<div class="container">

			<!-- Map -->
			<div id="map_group" class="container-map center-h">
				<div class="option-column-buttons">
					<div class="row-1 sidebar-open-button home-icon" onclick="open_sidebar('sidebar_load')"></div>
					<div class="row-2 sidebar-open-button full-screen-icon" onclick="toggleFullScreen()"></div>
				</div>
				<div id="map" class="map center-h">
					<div id="areas" class="areas overlay center-h">
						<div class="row-1 cell "></div>
						<div class="row-1 cell "></div>
						<div class="row-1 cell "></div>
						<div class="row-1 cell "></div>
						<div class="row-1 cell "></div>
						<div class="row-2 cell "></div>
						<div class="row-2 cell "></div>
						<div class="row-2 cell "></div>
						<div class="row-2 cell "></div>
						<div class="row-2 cell "></div>
						<div class="row-3 cell "></div>
						<div class="row-3 cell "></div>
						<div class="row-3 cell "></div>
						<div class="row-3 cell "></div>
						<div class="row-3 cell "></div>
						<div class="row-4 cell "></div>
						<div class="row-4 cell "></div>
						<div class="row-4 cell "></div>
						<div class="row-4 cell "></div>
						<div class="row-4 cell "></div>
						<div class="row-5 cell "></div>
						<div class="row-5 cell "></div>
						<div class="row-5 cell "></div>
						<div class="row-5 cell "></div>
						<div class="row-5 cell "></div>
					</div>
					<div id="doors" class="doors center-h overlay">
						<div class="row-1 cell-mini spacer-icon"></div>
						<div class="row-1 cell-mini no-icon"></div>
						<div class="row-1 cell-mini spacer-icon"></div>
						<div class="row-1 cell-mini no-icon"></div>
						<div class="row-1 cell-mini spacer-icon"></div>
						<div class="row-1 cell-mini no-icon"></div>
						<div class="row-1 cell-mini spacer-icon"></div>
						<div class="row-1 cell-mini no-icon"></div>
						<div class="row-1 cell-mini spacer-icon"></div>
						
						<div class="row-2 cell-mini no-icon"></div>
						<div class="row-2 cell-mini spacer-icon"></div>
						<div class="row-2 cell-mini no-icon"></div>
						<div class="row-2 cell-mini spacer-icon"></div>
						<div class="row-2 cell-mini no-icon"></div>
						<div class="row-2 cell-mini spacer-icon"></div>
						<div class="row-2 cell-mini no-icon"></div>
						<div class="row-2 cell-mini spacer-icon"></div>
						<div class="row-2 cell-mini no-icon"></div>
						
						<div class="row-3 cell-mini spacer-icon"></div>
						<div class="row-3 cell-mini no-icon"></div>
						<div class="row-3 cell-mini spacer-icon"></div>
						<div class="row-3 cell-mini no-icon"></div>
						<div class="row-3 cell-mini spacer-icon"></div>
						<div class="row-3 cell-mini no-icon"></div>
						<div class="row-3 cell-mini spacer-icon"></div>
						<div class="row-3 cell-mini no-icon"></div>
						<div class="row-3 cell-mini spacer-icon"></div>
						
						<div class="row-4 cell-mini no-icon"></div>
						<div class="row-4 cell-mini spacer-icon"></div>
						<div class="row-4 cell-mini no-icon"></div>
						<div class="row-4 cell-mini spacer-icon"></div>
						<div class="row-4 cell-mini no-icon"></div>
						<div class="row-4 cell-mini spacer-icon"></div>
						<div class="row-4 cell-mini no-icon"></div>
						<div class="row-4 cell-mini spacer-icon"></div>
						<div class="row-4 cell-mini no-icon"></div>
						
						<div class="row-5 cell-mini spacer-icon"></div>
						<div class="row-5 cell-mini no-icon"></div>
						<div class="row-5 cell-mini spacer-icon"></div>
						<div class="row-5 cell-mini no-icon"></div>
						<div class="row-5 cell-mini spacer-icon"></div>
						<div class="row-5 cell-mini no-icon"></div>
						<div class="row-5 cell-mini spacer-icon"></div>
						<div class="row-5 cell-mini no-icon"></div>
						<div class="row-5 cell-mini spacer-icon"></div>
						
						<div class="row-6 cell-mini no-icon"></div>
						<div class="row-6 cell-mini spacer-icon"></div>
						<div class="row-6 cell-mini no-icon"></div>
						<div class="row-6 cell-mini spacer-icon"></div>
						<div class="row-6 cell-mini no-icon"></div>
						<div class="row-6 cell-mini spacer-icon"></div>
						<div class="row-6 cell-mini no-icon"></div>
						<div class="row-6 cell-mini spacer-icon"></div>
						<div class="row-6 cell-mini no-icon"></div>
						
						<div class="row-7 cell-mini spacer-icon"></div>
						<div class="row-7 cell-mini no-icon"></div>
						<div class="row-7 cell-mini spacer-icon"></div>
						<div class="row-7 cell-mini no-icon"></div>
						<div class="row-7 cell-mini spacer-icon"></div>
						<div class="row-7 cell-mini no-icon"></div>
						<div class="row-7 cell-mini spacer-icon"></div>
						<div class="row-7 cell-mini no-icon"></div>
						<div class="row-7 cell-mini spacer-icon"></div>
						
						<div class="row-8 cell-mini no-icon"></div>
						<div class="row-8 cell-mini spacer-icon"></div>
						<div class="row-8 cell-mini no-icon"></div>
						<div class="row-8 cell-mini spacer-icon"></div>
						<div class="row-8 cell-mini no-icon"></div>
						<div class="row-8 cell-mini spacer-icon"></div>
						<div class="row-8 cell-mini no-icon"></div>
						<div class="row-8 cell-mini spacer-icon"></div>
						<div class="row-8 cell-mini no-icon"></div>
						
						<div class="row-9 cell-mini spacer-icon"></div>
						<div class="row-9 cell-mini no-icon"></div>
						<div class="row-9 cell-mini spacer-icon"></div>
						<div class="row-9 cell-mini no-icon"></div>
						<div class="row-9 cell-mini spacer-icon"></div>
						<div class="row-9 cell-mini no-icon"></div>
						<div class="row-9 cell-mini spacer-icon"></div>
						<div class="row-9 cell-mini no-icon"></div>
						<div class="row-9 cell-mini spacer-icon"></div>
					</div>
				</div>
				<div class="option-column-buttons">
					<div class="row-1 sidebar-open-button info-icon" onclick="open_sidebar('sidebar_data')"></div>
				</div>
			</div>

			<!-- Log -->
			<div id="log_group" class="container-log center-h">
				<div id="log", class="log center-h"></div>
			</div>

			<!-- Buttons -->
			<div id="button_group", class="container-button-1">
				<button id="start" type="button" class="button btn-1"><p class="center capitalize">Start</p></button>
			</div>

		</div>

		<!-- Modal -->
		<div id="modal" class="modal-container">
			<div id="modal_template_id" style="display: none;"></div>
			<div id="modal_content" class="modal-content">
			</div>
		</div>

		<!-- Sidebar -->
		<div id="sidebar" class="sidebar-container">
			<div id="sidebar_template_id" style="display: none;"></div>
			<div id="sidebar_content" class="sidebar-content">
			</div>
		</div>

	</div>
</body>

<script>
touch_drag = function(_element) {
	const STATES = { "Idle": 0, "Drag": 1 };
	let scope = {
		"state": STATES.Idle,
		"element": _element,
		"target": null,
		"data": null,
	};

	let dispatch = function(_target, _event, _payload=null) {
		if(_target != null) {
			_target.dispatchEvent(
				new CustomEvent(_event, { bubbles: true, detail: _payload }));
		};
	};

	let drop = function(_event) {
		if (this.state != STATES.Drag) { return };
		this.state = STATES.Idle;

		dispatch(this.target, "drop", this);
		this.element.style.position = "";
		this.element.style.left = "";
		this.element.style.top = "";

	}.bind(scope);
		
	let drag = function(_event) {
		if (this.state != STATES.Drag) { return };
		let coordinates = null;

		if (_event instanceof TouchEvent) {
    	coordinates = _event.touches[0];
		} else if  (_event instanceof MouseEvent) {
			coordinates = { "clientX": _event.clientX, "clientY": _event.clientY };
		} else {
			return
		}

    this.element.style.position = "absolute";
    this.element.style.left = `${coordinates.clientX}px`;
    this.element.style.top = `${coordinates.clientY}px`;

    this.target = document.elementFromPoint(coordinates.clientX, coordinates.clientY);
	}.bind(scope);

	let start = function(_event) {
		if (this.state != STATES.Idle) { return };

		this.state = STATES.Drag;
		this.target = null;

		dispatch(this.element, "dragstart", this);
	}.bind(scope);

	_element.addEventListener("touchstart", start);
	_element.addEventListener("touchmove", drag);
	_element.addEventListener("touchend", drop);
};
</script>

<script type="text/html" id="modal_roll_template">
	<div class="modal-header tabs">
		<p class="center-v left-justify">Set Roll:</p>
		<span class="right-justify" onclick="close_modal()"><div class="close-icon"></div></span>
	</div>
	<div class="modal-body">
		<div class="center">
			<label for="input_0" class="left-justify">Set to:</label><br>
			<input type="text" id="modal_input_0" name="input_0" class="right-justify" value=1><br>
			<label for="input_1" class="left-justify">Out of:</label><br>
			<input type="text" id="modal_input_1" name="input_1" class="right-justify" value="##0##"><br>
		</div>
	</div>
	<div class="modal-footer tabs">
		<button id="submit_modal" class="button center-h"><p class="center">Submit</p></button>
	</div>
</script>
<script>
	function get_modal_roll_ref() {
		return modal_roll;
	};

	const modal_roll = Object({
		initialize: function(_resolve, _reject, _args) {
			let max_r		= _args[3];
			html_factory.build("modal_roll_template", "modal_content", [max_r]);

			let submit = document.getElementById("submit_modal");
			submit.addEventListener("click", function() {
				let input = document.getElementById("modal_input_0").value;
				let max = parseInt((typeof max_r == "number") ? max_r : document.getElementById("modal_input_1").value);

				_reject([_args[1], [_args[2], input - 1, max - 1]]);
				close_modal();
			});
		},
	});
</script>



<script type="text/html" id="modal_edit_input_template">
	<div class="modal-header tabs">
		<p class="center-v left-justify">Edit the Value:</p>
		<span class="right-justify" onclick="close_modal()"><div class="close-icon"></div></span>
	</div>
	<div class="modal-body">
		<div class="center">
			<label for="input_0">Path:</label><br>
			<input type="text" id="modal_input_0" name="input_0" class="right-justify" value=##0##><br>
			<label for="input_1">Value:</label><br>
			<input type="text" id="modal_input_1" name="input_1" class="right-justify" value="##1##"><br>
		</div>
	</div>
	<div class="modal-footer tabs">
		<button id="submit_modal" class="button center-h"><p class="center">Submit</p></button>
	</div>
</script>

<script>
	function get_modal_edit_input_ref() {
		return modal_edit_input;
	};

	const modal_edit_input = Object({
		initialize: function(_resolve, _reject, _path, _data) {
			html_factory.build("modal_edit_input_template", "modal_content", [_path, _data]);

			let submit = document.getElementById("submit_modal");
			submit.addEventListener("click", function() {
				let path = document.getElementById("modal_input_0").value;
				let value = document.getElementById("modal_input_1").value;

				io.event_handler("write", [sidebar_data.context, path, value]);
				close_modal();
				close_sidebar();
			});
		},
	});
</script>



<script type="text/html" id="modal_edit_text_area_template">
	<div class="modal-header tabs">
		<p class="center-v left-justify">Edit the Value:</p>
		<span class="right-justify" onclick="close_modal()"><div class="close-icon"></div></span>
	</div>
	<div class="modal-body">
		<div class="center">
			<label for="input_0">Path:<a id="refresh_input" href="#" class="plus-icon right-justify">xx</a></label><br>
			<input type="text" id="modal_input_0" name="input_0" class="left-justify" value=##0##><br>
			<label for="input_1">Value:</label><br>
			<textarea id="modal_input_1" name="input_1" rows="8" class="left-justify">##1##</textarea> <br>
		</div>
	</div>
	<div class="modal-footer tabs">
		<button id="submit_modal" class="button center-h"><p class="center">Submit</p></button>
	</div>
</script>
<script>
	function get_modal_edit_text_area_ref() {
		return modal_edit_text_area;
	};

	const modal_edit_text_area = Object({
		initialize: function(_resolve, _reject, _path, _data) {
			html_factory.build("modal_edit_text_area_template", "modal_content", [_path, _data]);

			let submit = document.getElementById("submit_modal");
			submit.addEventListener("click", function() {
				let path = document.getElementById("modal_input_0").value;
				let value = document.getElementById("modal_input_1").value;

				io.write(sidebar_data.context, path, JSON.parse(value));
				close_modal();
				close_sidebar();
			});

			let refresh = document.getElementById("refresh_input");
			refresh.addEventListener("click", function() {
				let path = document.getElementById("modal_input_0").value;
				let data = io.read(sidebar_data.context, path);
				document.getElementById("modal_input_1").value = JSON.stringify(data, null, 1);
			});
		},
	});
</script>



<script type="text/html" id="modal_select_multi_template">
	<div class="modal-header tabs">
		<p class="center-v left-justify">##0##</p>
		<span class="right-justify" onclick="close_modal()"><div class="close-icon"></div></span>
	</div>
	<div class="modal-body">
		<div class="center">
			<select name="select_multi" id="select_multi" multiple size=##2##>
				##1##
			</select>
		</div>
	</div>
	<div class="modal-footer tabs">
		<button id="submit_modal" class="button center-h"><p class="center">Submit</p></button>
	</div>
</script>
<script>
	function get_modal_select_multi_ref() {
		return modal_select_multi;
	};

	const modal_select_multi = Object({
		initialize: function(_resolve, _reject, _args) {
			let title 	= _args[0];
			let selects = _args[1];
			let context = _args[2];
			let path 		= _args[3];

			let options = (context) ? io.read(context, path) : path;
			html_factory.build("modal_select_multi_template", "modal_content", [title, this.get_options(options), Math.min(options.length, 15)]);

			let select_multi = document.getElementById("select_multi");
			let submit = document.getElementById("submit_modal");
			submit.addEventListener("click", function() {
				let selected = select_multi.selectedOptions

				let results = [];
				for(let entry of selected) {
					results.push(entry.value.split(":")[1])
				}

				if (selects[0] <= results.length && results.length <= selects[1]) {
					_resolve(results);
				} else {
					input.event_handler("log", [`You must select between ${selects[0]}-${selects[1]} options you selected ${results.length}.`]);
				}

				close_modal();
			});
		},

		get_options: function(_options) {
			_options = (Array.isArray(_options) == false && typeof _options == "object") ? Object.entries(_options) : _options;
			let html = "";
			for (let idx in _options) {
				let option = (Array.isArray(_options[idx])) ? _options[idx][0]: _options[idx];
				html += `<option value="${idx}:${option}">${option}</option>\n`
			}
			return html
		},
	});
</script>



<script type="text/html" id="modal_text_input_template">
	<div class="modal-header tabs">
		<p class="center-v left-justify">##0##:</p>
		<span class="right-justify" onclick="close_modal()"><div class="close-icon"></div></span>
	</div>
	<div class="modal-body">
		<div class="center">
			<input type="text" id="modal_input_0" name="input_0" class="left-justify"><br>
		</div>
	</div>
	<div class="modal-footer tabs">
		<button id="submit_modal" class="button center-h"><p class="center">Submit</p></button>
	</div>
</script>

<script>
	function get_modal_text_input_ref() {
		return modal_text_input;
	};

	const modal_text_input = Object({
		initialize: function(_resolve, _reject, _args) {
			let title 	= _args[0];
			let context = _args[1];
			let path 		= _args[2];

			html_factory.build("modal_text_input_template", "modal_content", [title]);

			let submit = document.getElementById("submit_modal");
			submit.addEventListener("click", function() {
				_resolve(document.getElementById("modal_input_0").value);
				close_modal();
			});
		},
	});
</script>



<script type="text/html" id="sidebar_data_template">
	<div id="sidebar_head" class="tabs">
		<button class="button" onclick="close_sidebar()"><div class="close-icon center-h"></div></button>
		<button id="save_button" class="button"><p class="center-h capitalize">save</p></button>
		<button id="game_button" class="button"><p class="center-h capitalize">game</p></button>
		<button id="rule_button" class="button"><p class="center-h capitalize">rule</p></button>
	</div>

	<div id="sidebar_bread_crumbs" class="sidebar-bread-crumbs">
	</div>

	<div id="sidebar_body" class="sidebar-body">
	</div>

	<div id="sidebar_footer" class="tabs">
		<button id="edit_data_sidebar"   class="button" draggable="true"><div class="edit-icon center-h"></div></button>
		<button id="copy_data_sidebar"   class="button" draggable="true"><div class="clipboard-icon center-h"></div></button>
		<button id="delete_data_sidebar" class="button" draggable="true"><div class="close-icon center-h"></div></button>
	</div>
</script>

<script>
	function get_sidebar_data_ref() {
		return sidebar_data;
	};

	const sidebar_data = Object({
		context: undefined,

		initialize: function() {
			Array.from(document.getElementById("sidebar_head").children).slice(1)
				.forEach(_element => this.tab_buttons(_element));

			Array.from(document.getElementById("sidebar_footer").children)
				.forEach((child) => { 
					child.addEventListener("dragstart", this.on_drag_start);
					touch_drag(child);
				});

			this.wire_observer();
		},

		wire_observer: function(_observer=null) {
			const target_node = document.getElementById("sidebar_body");
			const config = { childList: true, subtree: true };
			
			if (_observer) {
				_observer.observe(target_node, config);
			} else {
				const observer = new MutationObserver(this.on_dom_mutation.bind(this));
				observer.observe(target_node, config);
			}
		},

		on_dom_mutation: function(_records, _observer) {
			for(let record of _records) {
				if (record.addedNodes.length > 0) {
					this.add_drop_handlers(record.addedNodes[0]);
				}
			}

			_observer.takeRecords();
			this.wire_observer(_observer);
		},
		
		add_drop_handlers: function(_root_element) {
			let keys = Array.from(_root_element.getElementsByClassName("key"));
			let keywords = Array.from(_root_element.getElementsByClassName("keyword"));
			let numbers = Array.from(_root_element.getElementsByClassName("number"));
			let strings = Array.from(_root_element.getElementsByClassName("string"));
			let arrays = Array.from(_root_element.querySelectorAll(".classname:is(.array):not(.syntax)"));
			let objects = Array.from(_root_element.querySelectorAll(".classname:is(.object):not(.syntax)"));

			//https://stackoverflow.com/questions/1517924/javascript-mapping-touch-events-to-mouse-events
			[].concat(keys, keywords, numbers, strings, arrays, objects)
				.forEach((_ele) => {
					_ele.addEventListener("dragover", 	this.on_drag_over); 
					_ele.addEventListener("drop", 			this.on_drop.bind(this));
				}
			)
		},

		tab_buttons: function(_button) {
			_button.addEventListener("click",	function(_event) {
				let new_id = _event.currentTarget.id.split("_")[0];
				let new_content = document.getElementById("sidebar_body");
				while(new_content.firstChild) { new_content.removeChild(new_content.firstChild); };

				this.context = `${new_id}_d`;
				new_content.appendChild(
					renderjson.set_icons('+', '-')
										.set_show_to_level((`${new_id}_d` != "rule_d") ? 2 : 1)
										.set_collapse_msg(function(len) { return len })
										(io.data_sets[`${new_id}_d`]));
			}.bind(this));
		},

		on_drag_start: function(_event) {
			let target_action = _event.target.id.split("_")[0];

			if (_event instanceof DragEvent) {
				_event.dataTransfer.clearData();
				_event.dataTransfer.setData("text", target_action);
			} else if (_event instanceof CustomEvent) {
				_event.detail.data = target_action;
			}
		},

		on_drag_over: function(_event) {
			_event.preventDefault();
			_event.dataTransfer.dropEffect = "link";
		},
		
		on_drop: function(_event) {
			_event.preventDefault();
			let action = (_event instanceof DragEvent) ? _event.dataTransfer.getData("text") : _event.detail.data;

			let path = json_data_utils.get_path_from_tree(_event.target);
			let value = io.read(this.context, path);
			let is_value_object = (typeof value == "object");

			let modal_id = `modal_${action}_${(is_value_object) ? "text_area" : "input"}`
			open_modal(modal_id, null, null, path, (is_value_object) ? JSON.stringify(value, null, 1) : value);
		},
	})

	const json_data_utils = Object({
		get_path_from_tree: function(_target) {
			let class_filter_primitive = ["string", "number"];
			let class_filter_special = ["array", "object", "keyword"];
			let target = _target;
			let path = []
			
			while(target != null && !target.className.includes("renderjson")) {
				if (target.className == "key") {
					path.unshift(target.innerHTML);
					
				} else if (class_filter_primitive.includes(target.className)) {
					if (target.parentNode.className == "object") {
						let element = this.walk_siblings_for_element(target, "previousSibling", "className", "key");
						path.unshift(element.innerHTML);

					} else {
						let idx = this.walk_siblings_for_idx(target, "previousSibling", "+", "innerHTML", ",");
						path.unshift(idx);
					}

				} else if (class_filter_special.includes(target.className)) {
					if (target.className != "keyword") {
						target = target.parentNode;
					}

					if (target.parentNode.className == "object") {
						target = target.previousSibling.previousSibling;
						path.unshift(target.innerHTML);

					} else if  (target.parentNode.className == "array") {
						let idx = this.walk_siblings_for_idx(target, "previousSibling", "+", "innerHTML", ",");
						path.unshift(idx);
					}
				}

				target = target.parentNode;
			}

			path.shift()
			return path.join(".").replaceAll("\"", "");
		},

		walk_siblings_for_element: function(_element, _sibling_itter, _attribute, _value) {
			let idx = 0;
			let sibling = _element[_sibling_itter];

			while(sibling) {
				if (sibling[_attribute] == _value) {
					return sibling;
				}

				sibling = sibling[_sibling_itter];
			}
		},

		walk_siblings_for_idx: function(_element, _sibling_itter, _operation, _attribute, _value) {
			let idx = 0;
			let sibling = _element[_sibling_itter];

			while(sibling) {
				if (sibling[_attribute] == _value) {
					idx = (_operation == "+") ? idx + 1 : idx - i;
				}

				sibling = sibling[_sibling_itter];
			}

			return idx;
		}
	});
</script>

<script type="text/html" id="sidebar_load_template">
	<div id="sidebar_head" class="modal-header tabs">
		<p id="sidebar_title" class="center-v left-justify">Null</p>
		<button id="profile_button" class="button"><p class="center-h capitalize">profiles</p></button>
		<button id="save_button" class="button" disabled><p class="center-h capitalize">saves</p></button>
		<span class="right-justify" onclick="close_sidebar()"><div class="close-icon"></div></span>
	</div>

	<div id="sidebar_body" class="sidebar-body">
	</div>

	<div id="sidebar_footer" class="tabs">
		<button id="new_data" class="button"><p class="center-h capitalize">New</p></button>
		<button id="load_data" class="button"><p class="center-h capitalize">Load</p></button>
		<button id="delete_data" class="button"><p class="center-h capitalize">Delete</p></button>
	</div>
</script>

<script>
	function get_sidebar_load_ref() {
		return sidebar_load;
	};

	const sidebar_load = Object({
		selected_data: "",

		initialize: async function() {
			let tab_buttons = Array.from(document.getElementById("sidebar_head").children).slice(1);
			tab_buttons[0].addEventListener("click", 	this.on_profile_data.bind(sidebar_load)); 
			tab_buttons[1].addEventListener("click", 	this.on_save_data.bind(sidebar_load)); 

			let action_buttons = Array.from(document.getElementById("sidebar_footer").children).slice();
			action_buttons[0].addEventListener("click", 	this.on_action.bind(sidebar_load, "new")); 
			action_buttons[1].addEventListener("click", 	this.on_action.bind(sidebar_load, "load")); 
			action_buttons[2].addEventListener("click", 	this.on_action.bind(sidebar_load, "delete")); 

			if(save_data.name) {
				this.on_save_data();
			} else {
				this.on_profile_data();
			}
		},

		create_entry: function(_entry) {
			let div = document.createElement("div");
			div.id = _entry;
			div.className = "session-key";

			let p = document.createElement("p");
			p.className = "black-text"
			p.innerHTML = _entry;
			div.appendChild(p);

			div.addEventListener("click", sidebar_load.on_select.bind(this, div, _entry));
			return div;
		},

		on_profile_data: async function() {
			document.getElementById("sidebar_title").innerText = "Profiles:";

			sidebar_load.selected_data = "";
			let db_entries = await profile.get_profiles();

			let root = html_factory.get_and_clear_element("sidebar_body");
			for(let idx in db_entries) {
				let profile_entry = this.create_entry(db_entries[idx])
				root.appendChild(profile_entry);

				if (db_entries[idx][0] == save_data.name) {
					this.on_select(profile_entry, db_entries[idx], null);
					document.getElementById("save_button").disabled = false;
					this.on_save_data.bind(this);
				}
			}
		},

		on_save_data: async function() {
			document.getElementById("save_button").disabled = false;
			document.getElementById("sidebar_title").innerText = "Save Data:";

			sidebar_load.selected_data = "";
			let save_entries = await profile.get_saves();
			save_entries.sort((_a, _b) => { return (parseInt(_a.split("-").at(-1)) < parseInt(_b.split("-").at(-1)) ? -1 : 1) });

			let root = html_factory.get_and_clear_element("sidebar_body");
			for(let idx in save_entries) {
				root.appendChild(this.create_entry(save_entries[idx]));
			}
		},

		on_select: function(_div, _entry, _event) {
			sidebar_load.selected_data = _entry;
			Array.from(document.getElementsByClassName("inverted")).forEach(ele => ele.className = ele.className.replace("inverted", ""));
			_div.className += " inverted" 
		},

		on_action: async function(_action) {
			let title = document.getElementById("sidebar_title");
			let context = (title.innerText == "Profiles:") ? "profile" : "save";

			if (_action == "load") {
				if (context == "profile") {
					await this.on_profile_load();
				} else if (context == "save") {
					await this.on_save_load();
				}
			} else if (_action == "delete") {
				if (context == "profile") {
					await this.on_profile_delete();
				} else if (context == "save") {
					await this.on_save_delete();
				}
			} else if (_action == "new") {
				if (context == "profile") {
					let new_profile = async function(_profile_name) {
						profile.set_profile(_profile_name);
						profile.set_save(0);
						await profile.save_data().then(() => { sidebar_load.on_profile_data(); });
						close_sidebar();
					};

					open_modal("modal_text_input", new_profile, null, ["Profile Name"])
				}
			}
		},

		on_profile_load: function() {
			if (sidebar_load.selected_data == "") { return };
			profile.set_profile(sidebar_load.selected_data[0]);
			document.getElementById("save_button").disabled = false;
			
			sidebar_load.on_save_data.bind(sidebar_load)();
		},

		on_profile_delete: async function() {
			if (sidebar_load.selected_data == "") { return };
			await profile.delete_profile(sidebar_load.selected_data[0]);

			let entry = document.getElementById(sidebar_load.selected_data);
			entry.parentElement.removeChild(entry);

			let profile_id = `${sidebar_load.selected_data[0]}-${sidebar_load.selected_data[1]}`
			if (profile_id == save_data.id) {
				document.getElementById("save_button").disabled = true;
			}
		},

		on_save_load: async function() {
			if (sidebar_load.selected_data == "") { return };

			profile.set_save(sidebar_load.selected_data.split("-")[1]);
			await profile.load_data()
			.then(function(_data) {
				close_sidebar();
			});
		},

		on_save_delete: async function() {
			if (sidebar_load.selected_data == "") { return };

			await profile.delete_data(sidebar_load.selected_data);
			let entry = document.getElementById(sidebar_load.selected_data);
			entry.parentElement.removeChild(entry);
		}
	});
</script>

<script>
const game_data = Object({
	data: {
		"enums": {
			"die": { "d100": 7, "d20": 6, "d12": 5, "d10": 4, "d8": 3, "d6": 2, "d4": 1, "d2": 0 },
		},
		"tables": {
			"criticals": [100, 11, 22, 33, 44, 55, 66, 77, 88, 99],
			"difficulty": [30, 20, 10, 0, -10, -20, -30],
			"damage_modifier": [0, 0.5, 1.0, 2.0, -1.0],
			"damage_dealt": [0, 1, 1, 1, 2, 2, 2, 3, 3, 4],
			"area_type": ["corridor", "room", "room", "room"],
			"doors": [[1,0,0,0],[1,1,0,0],[1,0,1,0],[1,0,0,1],[1,1,1,0],[1,0,1,1],[1,1,1,1],[1,1,1,1]],
			"locked": [[0,0,0,0],[0,0,0,0],[0,2,0,0],[0,0,2,0],[0,0,0,2],[0,2,2,0],[0,2,0,2],[0,2,2,2]],
			"trapped": [[0,0,0,0],[0,0,0,0],[0,4,0,0],[0,0,4,0],[0,0,0,4],[0,4,4,0],[0,4,0,4],[0,4,4,4]],
			"damage_types": ["acid", "air", "arcane", "bludgeon", "charm", "cold", "disease", "earth", "fire", "holy", "infernal", "necrotic", "pierce", "poison", "psychic", "slash", "water", "all"],
			"conditions": ["bleed", "blind", "burn", "charm", "conceal", "cursed", "daze", "disease", "entangle", "ethereal", "fear", "paralyze", "poison", "prone", "sleep", "stun", "belt_damage"],
			"madness": [],
			"perks": [],
			"stats": ["health", "toughness", "aether", "sanity", "magic_resist"],
			"skills": {
				"weapon":		["blade", "bludgeon",	"pole", "fist"],
				"ability":		["acrobatics", "athletics", "dodge", "endurance", "medicine", "perception", "resolve", "reason", "scavenge", "stealth", "thievery"],
				"all":			["acrobatics", "athletics", "blade", "bludgeon","dodge", "endurance", "fist", "medicine", "perception", "pole", "resolve", "reason", "scavenge", "stealth", "thievery"]
			},
			"darkness": [
				"hell_bats"
			],
			"bodies": {
				"distribution": {
					"arachnid":			["right_rear_leg","right_rear_leg","left_rear_leg","left_rear_leg","mid_right_leg","mid_right_leg","mid_left_leg","mid_left_leg","fore_right_leg","fore_right_leg","fore_left_leg","fore_left_leg","abdomen","abdomen","front_right_leg","front_right_leg","front_left_leg","front_left_leg","cephalothorax","cephalothorax"],
					"insectoid":		["right_rear_leg","left_rear_leg","right_middle_leg","left_middle_leg","abdomen","abdomen","abdomen","abdomen","abdomen","thorax","thorax","thorax","thorax","thorax","right_front_leg","left_front_leg","head","head","head","head"],
					"quadruped":		["right_hind_leg","right_hind_leg","right_hind_leg","left_hind_leg","left_hind_leg","left_hind_leg","hindquarters","hindquarters","hindquarters","forequarters","forequarters","forequarters","right_front_leg","right_front_leg","right_front_leg","left_front_leg","left_front_leg","left_front_leg","head","head"],
					"humanoid":			["right_leg","right_leg","right_leg","left_leg","left_leg","left_leg","abdomen","abdomen","abdomen","chest","chest","chest","left_arm","left_arm","left_arm","right_arm","right_arm","right_arm","head","head"],
					"serpentoid":		["body","body","body","body","body","body","body","body","body","body","body","body","body","body","body","body","body","body","head","head"],
					"winged_biped":		["right_leg","left_leg","chest","chest","chest","right_wing","right_wing","right_wing","right_wing","left_wing","left_wing","left_wing","left_wing","right_arm","left_arm","head","head","head","head","head"],
				},
				"unique": {
					"arachnid":			["right_rear_leg","left_rear_leg","mid_right_leg","mid_left_leg","fore_right_leg","fore_left_leg","abdomen","front_right_leg","front_left_leg","cephalothorax"],
					"insectoid":		["right_rear_leg","left_middle_leg","abdomen","thorax","right_front_leg","left_front_leg","head"],
					"quadruped":		["right_hind_leg","left_hind_leg","hindquarters","forequarters","right_front_leg","left_front_leg","head"],
					"humanoid":			["right_leg","left_leg","abdomen","chest","left_arm","right_arm","head"],
					"serpentoid":		["body","head"],
					"winged_biped":		["right_leg","left_leg","chest","right_wing","left_wing","right_arm","left_arm","head"],					
				},
			},
			"enemies": [
				"blightfang_rats", 
				"amalgam", 
				"corpse_ant", 
				"skeletal_horror"],
			"overseers": [
				"infernal_tormentor"
			],
			"events": [
				"trader", 
				"magical_item"],
			"scavenge": [
				"You uncover some grisly remains. Make a successful Resolve check or lose 1 Sanity", 
				"You find nothing of interest", 
				"You discover D20", 
				"You find D4 Crafting Supplies", 
				"You discover 2D20", 
				"You find D4 Cooking Supplies", 
				"You discover D100", 
				"Roll on the Spoils table"],
			"masteries":[
				"abyssal_reaver",
				"arcanist",
				"brawler",
				"bulwark",
				"duskblade",
				"emissary",
				"flamecaster",
				"frostcaster",
				"gravecaller",
				"hexmancer",
				"icon_caller",
				"mindbinder",
				"ritualist",
				"stormbrand",
				"tracker",
				"umber_phantom",
				"weapon_master",
				"wraith",
				"wraith_spawn",
				"zealot"
			],
			"actions": {
				"combat":{
					"standard": {
						// ----------------------------------------------------------------------------------------------------- Weapons
						"slash.blade": 				{"name": "slash.blade",						"type": "standard",		"check": {"type": "oppose",	"skills": ["weapon.blade", "combat.attack", "combat.initiative"],			"vantage": "+combat+attack"				},	"target": {"party": 1, "count": 1},		"rule": ["actions.basic.attack_roll",	["<roll_results>", "<body_part>", [{"type":"slashing", 		"roll": 6, "modifier": 0}]]]},
						"slash.fist": 				{"name": "slash.fist",						"type": "standard",		"check": {"type": "oppose",	"skills": ["weapon.fist", "combat.attack", "combat.initiative"],			"vantage": "+combat+attack"				},	"target": {"party": 1, "count": 1},		"rule": ["actions.basic.attack_roll",	["<roll_results>", "<body_part>", [{"type":"slashing", 		"roll": 6, "modifier": 0}]]]},
						"slash.pole": 				{"name": "slash.pole",						"type": "standard",		"check": {"type": "oppose",	"skills": ["weapon.pole", "combat.attack", "combat.initiative"],			"vantage": "+combat+attack"				},	"target": {"party": 1, "count": 1},		"rule": ["actions.basic.attack_roll",	["<roll_results>", "<body_part>", [{"type":"slashing", 		"roll": 6, "modifier": 0}]]]},
						"stab.blade": 				{"name": "stab.blade",						"type": "standard",		"check": {"type": "oppose",	"skills": ["weapon.blade", "combat.attack", "combat.initiative"],			"vantage": "+combat+attack"				},	"target": {"party": 1, "count": 1},		"rule": ["actions.basic.attack_roll",	["<roll_results>", "<body_part>", [{"type":"piercing", 		"roll": 6, "modifier": 0}]]]},
						"stab.bludgeon":			{"name": "stab.bludgeon",					"type": "standard",		"check": {"type": "oppose",	"skills": ["weapon.bludgeon", "combat.attack", "combat.initiative"],	"vantage": "+combat+attack"				},	"target": {"party": 1, "count": 1},		"rule": ["actions.basic.attack_roll",	["<roll_results>", "<body_part>", [{"type":"piercing", 		"roll": 6, "modifier": 0}]]]},
						"stab.fist":					{"name": "stab.fist",							"type": "standard",		"check": {"type": "oppose",	"skills": ["weapon.fist", "combat.attack", "combat.initiative"],			"vantage": "+combat+attack"				},	"target": {"party": 1, "count": 1},		"rule": ["actions.basic.attack_roll",	["<roll_results>", "<body_part>", [{"type":"piercing", 		"roll": 6, "modifier": 0}]]]},
						"stab.pole":					{"name": "stab.pole",							"type": "standard",		"check": {"type": "oppose",	"skills": ["weapon.pole", "combat.attack", "combat.initiative"],			"vantage": "+combat+attack"				},	"target": {"party": 1, "count": 1},		"rule": ["actions.basic.attack_roll",	["<roll_results>", "<body_part>", [{"type":"piercing", 		"roll": 6, "modifier": 0}]]]},
						"smash.bludgeon":			{"name": "smash.bludgeon",				"type": "standard",		"check": {"type": "oppose",	"skills": ["weapon.bludgeon", "combat.attack", "combat.initiative"],	"vantage": "+combat+attack"				},	"target": {"party": 1, "count": 1},		"rule": ["actions.basic.attack_roll",	["<roll_results>", "<body_part>", [{"type":"bludgeoning", "roll": 6, "modifier": 0}]]]},
						"smash.fist":					{"name": "smash.fist",						"type": "standard",		"check": {"type": "oppose",	"skills": ["weapon.fist", "combat.attack", "combat.initiative"],			"vantage": "+combat+attack"				},	"target": {"party": 1, "count": 1},		"rule": ["actions.basic.attack_roll",	["<roll_results>", "<body_part>", [{"type":"bludgeoning", "roll": 6, "modifier": 0}]]]},
						"smash.pole":					{"name": "smash.pole",						"type": "standard",		"check": {"type": "oppose",	"skills": ["weapon.pole", "combat.attack", "combat.initiative"],			"vantage": "+combat+attack"				},	"target": {"party": 1, "count": 1},		"rule": ["actions.basic.attack_roll",	["<roll_results>", "<body_part>", [{"type":"bludgeoning", "roll": 6, "modifier": 0}]]]},
						// ----------------------------------------------------------------------------------------------------- Skeletal_Horror
						"cursed_slash":				{"name": "cursed_slash",					"type": "standard",		"check": {"type": "oppose",	"skills": ["weapon.blade", "combat.attack", "combat.initiative"],			"vantage": "+combat+attack"				},	"target": {"party": 1, "count": 1 },	"rule": ["actions.basic.attack_roll",									["<roll_results>", "<body_part>", [{"type": "slashing",	"roll": 8, "modifier": 0}]]]},
						"ethereal_grasp":			{"name": "ethereal_grasp",				"type": "standard",		"check": {"type": "skill",	"skills": ["skill.magic_resist"],																			"vantage": "+skill+magic_resist"	},	"target": {"party": 1, "count": 1 },	"rule": ["actions.skeletal_horror.ethereal_grasp",		["<roll_results>", "<body_part>", [{"type": "necrotic",	"roll": 6, "modifier": 0}]]]},
						"haunting_wail":			{"name": "haunting_wail",					"type": "standard",		"check": {"type": "skill",	"skills": ["skill.magic_resist"],																			"vantage": "+skill+magic_resist"	},	"target": {"party": 1, "count": -1},	"rule": ["actions.skeletal_horror.haunting_wail",			["<roll_results>", "<body_part>",	[{"type": "skill", "sub_type": "resolve", "effects": ["conditions.stunned"]}]]]},
						"vengeful_onslaught":	{"name": "vengeful_onslaught",		"type": "standard",		"check": {"type": "oppose",	"skills": ["weapon.blade", "combat.attack", "combat.initiative"],			"vantage": "+combat+attack"				},	"target": {"party": 1, "count": 1 },	"rule": ["actions.skeletal_horror.vengeful_onslaught",["<roll_results>", "<body_part>", [{"type": "piercing",	"roll": 10, "modifier": 0}]]]},
					}
				},
				"monsters": {
					"skeletal_horrors": {

							"cursed_slash": { "name": "cursed_slash",
								"rule": "physical_attack_roll",
								"die": [[8, ["Slash"], 0]],
								"check": { "attack": "combat", "defend": null },
								"desc": "swings its weapon with an eerie precision, dealing D8 Slashing damage." },
							"ethereal_grasp": { "name": "ethereal_grasp",
								"rule": "ethereal_grasp",
								"die": [[6, ["Necrotic"], 0]],
								"check": { "attack": "combat", "defend": "endurance" },
								"desc": "reaches out with its hand, attempting to touch the essence of a target's life force. The target must make an Endurance check. On a failed check, they take D6 Necrotic damage, and the Skeletal Horror regains Health equal to half the damage dealt (rounding up). On a successful roll, the target takes half damage (rounding up), and the Skeletal Horror doesn't regain Health." },		
							"haunting_wail": { "name": "haunting_wail",
								"rule": "haunting_wail",
								"die": null,
								"check": { "attack": "combat", "defend": "resolve" },
								"desc": "lets out a haunting wail that reverberates through the air. All creatures must make a successful Resolve check to avoid becoming Stunned for 1 round." },
							"vengeful_onslaught": { "name": "vengeful_onslaught",
								"rule": "vengeful_onslaught",
								"die": [[10, ["Pierce"], 0]],
								"check": { "attack": "combat", "defend": null},
								"desc": "charges forward with relentless determination, targeting one creature. It makes a melee attack against the target, dealing D10 Piercing damage on a hit. If the attack hits, the Skeletal Horror immediately uses its Ethereal Grasp ability as a Free Action." },
					}
				},
			},
			"effects": {
				"aged": {
					"poisoned": {},
					"explosive": {},
					"impotent": {},
					"normal": {},
					"refined": {},
					"enhanced": {}
				},
				"counter": {
					"use": {
						"1":			{	"desc": "The item has 1 uses.",								"rule": ["effects.counters", "add"],		"args": ["<party>", "<char_idx>", "<source_ref>", "use", {"at": 1,		"by": 1}]},
						"6":			{	"desc": "The item has 6 uses.",								"rule": ["effects.counters", "add"],		"args": ["<party>", "<char_idx>", "<source_ref>", "use", {"at": 6,		"by": 1}]},
						"8":			{	"desc": "The item has 8 uses.",								"rule": ["effects.counters", "add"],		"args": ["<party>", "<char_idx>", "<source_ref>", "use", {"at": 8,		"by": 1}]},
						"10":			{	"desc": "The item has 10 uses.",							"rule": ["effects.counters", "add"],		"args": ["<party>", "<char_idx>", "<source_ref>", "use", {"at": 10,		"by": 1}]},
						"12":			{	"desc": "The item has 12 uses.",							"rule": ["effects.counters", "add"],		"args": ["<party>", "<char_idx>", "<source_ref>", "use", {"at": 12,		"by": 1}]},
						"20":			{	"desc": "The item has 20 uses.",							"rule": ["effects.counters", "add"],		"args": ["<party>", "<char_idx>", "<source_ref>", "use", {"at": 20,		"by": 1}]},
					},
					"integrity": {
						"1":			{	"desc": "The item has 1 integrity.",						"rule": ["effects.counters", "add"], 		"args": ["<party>", "<char_idx>", "<source_ref>", "integrity", {"at": 1,		"by": 1}]},
						"6":			{	"desc": "The item has 6 integrity.",						"rule": ["effects.counters", "add"], 		"args": ["<party>", "<char_idx>", "<source_ref>", "integrity", {"at": 6,		"by": 2}]},
						"8":			{	"desc": "The item has 8 integrity.",						"rule": ["effects.counters", "add"], 		"args": ["<party>", "<char_idx>", "<source_ref>", "integrity", {"at": 8,		"by": 2}]},
						"10":			{	"desc": "The item has 10 integrity.",						"rule": ["effects.counters", "add"], 		"args": ["<party>", "<char_idx>", "<source_ref>", "integrity", {"at": 10,		"by": 2}]},
						"12":			{	"desc": "The item has 12 integrity.",						"rule": ["effects.counters", "add"], 		"args": ["<party>", "<char_idx>", "<source_ref>", "integrity", {"at": 12,		"by": 2}]},
					},
				},
				"light_source": {	"desc": "Set character's light source.",				"rule": ["character.light_sources", "add", "delete"], 	"args": ["<party>", "<char_idx>", "<source_ref>", "<effect_id>"]},
				"equip_to": {
					"amulet":			{	"desc": "Equipped to amulet.",					"rule": ["character.inventory.equipment", "equip", "unequip"], 	"args": ["<party>", "<char_idx>", "<source_ref>", "equipped.amulet"]},
					"hand":				{	"desc": "Equipped to either hand.",				"rule": ["character.inventory.equipment", "equip", "unequip"], 	"args": ["<party>", "<char_idx>", "<source_ref>", "equipped.hand"]},
					"main_hand":		{	"desc": "Equipped to main_hand.",				"rule": ["character.inventory.equipment", "equip", "unequip"], 	"args": ["<party>", "<char_idx>", "<source_ref>", "equipped.main_hand"]},
					"off_hand":			{	"desc": "Equipped to off_hand.",				"rule": ["character.inventory.equipment", "equip", "unequip"], 	"args": ["<party>", "<char_idx>", "<source_ref>", "equipped.off_hand"]},
					"helmet":			{	"desc": "Equipped to helmet.",					"rule": ["character.inventory.equipment", "equip", "unequip"], 	"args": ["<party>", "<char_idx>", "<source_ref>", "equipped.helmet"]},
					"torso":			{	"desc": "Equipped to torso.",					"rule": ["character.inventory.equipment", "equip", "unequip"], 	"args": ["<party>", "<char_idx>", "<source_ref>", "equipped.torso"]},
					"vambrace":			{	"desc": "Equipped to vambrace.",				"rule": ["character.inventory.equipment", "equip", "unequip"], 	"args": ["<party>", "<char_idx>", "<source_ref>", "equipped.vambrace"]},
					"greave":			{	"desc": "Equipped to greave.",					"rule": ["character.inventory.equipment", "equip", "unequip"], 	"args": ["<party>", "<char_idx>", "<source_ref>", "equipped.greave"]},
					"gloves":			{	"desc": "Equipped to gloves.",					"rule": ["character.inventory.equipment", "equip", "unequip"], 	"args": ["<party>", "<char_idx>", "<source_ref>", "equipped.gloves"]},
					"boots":			{	"desc": "Equipped to boots.",					"rule": ["character.inventory.equipment", "equip", "unequip"], 	"args": ["<party>", "<char_idx>", "<source_ref>", "equipped.boots"]},
					"ring":				{	"desc": "Equipped to ring.",					"rule": ["character.inventory.equipment", "equip", "unequip"], 	"args": ["<party>", "<char_idx>", "<source_ref>", "equipped.ring"]},
					"belt":				{	"desc": "Equipped to belt.",					"rule": ["character.inventory.equipment", "equip", "unequip"], 	"args": ["<party>", "<char_idx>", "<source_ref>", "equipped.belt"]},
					"pouch":			{	"desc": "Equipped to pouch.",					"rule": ["character.inventory.equipment", "equip", "unequip"], 	"args": ["<party>", "<char_idx>", "<source_ref>", "equipped.pouch"]},
					"belt_lamp":		{	"desc": "Equipped to belt_lamp.",				"rule": ["character.inventory.equipment", "equip", "unequip"], 	"args": ["<party>", "<char_idx>", "<source_ref>", "equipped.belt_lamp"]},
				},
				"actions": {
					"disarm":			{	"desc": "Disarm trap action.",					"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "actions", "traversal", "standard", "<source_ref>", "<effect_id>",  ["disarm", ["door.actions", "container.actions"]]]},
					"slash": {
						"blade":		{	"desc": "A slashing blade attack.",				"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "actions", "combat", "standard", "<source_ref>", "<effect_id>", "slash.blade"]},
						"fist":			{	"desc": "A slashing fist attack.",				"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "actions", "combat", "standard", "<source_ref>", "<effect_id>", "slash.fist"]},
						"pole":			{	"desc": "A slashing pole attack.",				"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "actions", "combat", "standard", "<source_ref>", "<effect_id>", "slash.pole"]},
					},
					"stab": {
						"blade":		{	"desc": "A stabbing blade attack.",				"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "actions", "combat", "standard", "<source_ref>", "<effect_id>", "stab.blade"]},
						"bludgeon":		{	"desc": "A stabbing bludgeon attack.",			"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "actions", "combat", "standard", "<source_ref>", "<effect_id>", "stab.bludgeon"]},
						"fist":			{	"desc": "A stabbing fist attack.",				"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "actions", "combat", "standard", "<source_ref>", "<effect_id>", "stab.fist"]},
						"pole":			{	"desc": "A stabbing pole attack.",				"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "actions", "combat", "standard", "<source_ref>", "<effect_id>", "stab.pole"]},
					},
					"smash": {
						"bludgeon":		{	"desc": "A smashing bludgeon attack.",			"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "actions", "combat", "standard", "<source_ref>", "<effect_id>", "smash.bludgeon"]},
						"fist":			{	"desc": "A smashing fist attack.",				"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "actions", "combat", "standard", "<source_ref>", "<effect_id>", "smash.fist"]},
						"pole":			{	"desc": "A smashing pole attack.",				"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "actions", "combat", "standard", "<source_ref>", "<effect_id>", "smash.pole"]},
					},
				},
				"passives": {

				},
				"conditions": {
					"stunned": {
						"desc": "The character loses their next turn.", 												
						"rule": ["character.listener", "add"], 
						"args": ["<party>", "<char_idx>", "default", "condition.stunned", 1, {
							"trigger":	["<party>.<char_idx>.combat.turn", "character.conditions.stunned",	["<party>", "<char_idx>"]],
							"delete":		["$limit$"]}],
					},
				},
				"armor": {
					"helmet": {
						"1":				{ "desc": "+1 armor to the head.",								"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "enums", "defense", "armor", "<source_ref>", "<effect_id>", [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1]]},
						"2":				{ "desc": "+2 armor to the head.",								"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "enums", "defense", "armor", "<source_ref>", "<effect_id>", [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2]]},
						"3":				{ "desc": "+3 armor to the head.",								"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "enums", "defense", "armor", "<source_ref>", "<effect_id>", [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3]]},
					},
					"vambrace": {
						"1":				{ "desc": "+1 armor to the arms.",								"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "enums", "defense", "armor", "<source_ref>", "<effect_id>", [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0]]},
						"2":				{ "desc": "+2 armor to the arms.",								"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "enums", "defense", "armor", "<source_ref>", "<effect_id>", [0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,0,0]]},
						"3":				{ "desc": "+3 armor to the arms.",								"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "enums", "defense", "armor", "<source_ref>", "<effect_id>", [0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,0,0]]},
					},
					"torso": {
						"1":				{ "desc": "+1 armor to the chest.",								"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "enums", "defense", "armor", "<source_ref>", "<effect_id>", [0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0]]},
						"2":				{ "desc": "+2 armor to the chest.",								"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "enums", "defense", "armor", "<source_ref>", "<effect_id>", [0,0,0,0,0,0,2,2,2,2,2,2,0,0,0,0,0,0,0,0]]},
						"3":				{ "desc": "+3 armor to the chest.",								"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "enums", "defense", "armor", "<source_ref>", "<effect_id>", [0,0,0,0,0,0,3,3,3,3,3,3,0,0,0,0,0,0,0,0]]},
					},
					"greave": {
						"1":				{ "desc": "+1 armor to the legs.",								"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "enums", "defense", "armor", "<source_ref>", "<effect_id>", [1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]},
						"2":				{ "desc": "+2 armor to the legs.",								"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "enums", "defense", "armor", "<source_ref>", "<effect_id>", [2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]},
						"3":				{ "desc": "+3 armor to the legs.",								"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "enums", "defense", "armor", "<source_ref>", "<effect_id>", [3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]},
					}
				},
				"reduction": {
					"acid": 			{ "desc": "Reduce damage of type acid",						"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "enums", "defense", "reduction", "<source_ref>", "<effect_id>", [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]},
					"air":				{ "desc": "Reduce damage of type air",						"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "enums", "defense", "reduction", "<source_ref>", "<effect_id>", [0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]}, 
					"arcane":			{ "desc": "Reduce damage of type arcane",					"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "enums", "defense", "reduction", "<source_ref>", "<effect_id>", [0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]}, 
					"bludgeon":			{ "desc": "Reduce damage of type bludgeon",					"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "enums", "defense", "reduction", "<source_ref>", "<effect_id>", [0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]}, 
					"charm":			{ "desc": "Reduce damage of type charm",					"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "enums", "defense", "reduction", "<source_ref>", "<effect_id>", [0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0]]}, 
					"cold":				{ "desc": "Reduce damage of type cold",						"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "enums", "defense", "reduction", "<source_ref>", "<effect_id>", [0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0]]},
					"disease":			{ "desc": "Reduce damage of type earth",					"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "enums", "defense", "reduction", "<source_ref>", "<effect_id>", [0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0]]},
					"earth":			{ "desc": "Reduce damage of type earth",					"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "enums", "defense", "reduction", "<source_ref>", "<effect_id>", [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0]]}, 
					"fire":				{ "desc": "Reduce damage of type fire",						"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "enums", "defense", "reduction", "<source_ref>", "<effect_id>", [0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0]]}, 
					"holy":				{ "desc": "Reduce damage of type holy",						"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "enums", "defense", "reduction", "<source_ref>", "<effect_id>", [0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0]]}, 
					"infernal":			{ "desc": "Reduce damage of type infernal",					"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "enums", "defense", "reduction", "<source_ref>", "<effect_id>", [0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]]}, 
					"necrotic":			{ "desc": "Reduce damage of type necrotic",					"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "enums", "defense", "reduction", "<source_ref>", "<effect_id>", [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0]]}, 
					"pierce":			{ "desc": "Reduce damage of type pierce",					"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "enums", "defense", "reduction", "<source_ref>", "<effect_id>", [0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0]]}, 
					"poison":			{ "desc": "Reduce damage of type poison",					"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "enums", "defense", "reduction", "<source_ref>", "<effect_id>", [0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0]]}, 
					"psychic":			{ "desc": "Reduce damage of type psychic",					"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "enums", "defense", "reduction", "<source_ref>", "<effect_id>", [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0]]}, 
					"slash":			{ "desc": "Reduce damage of type slash",					"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "enums", "defense", "reduction", "<source_ref>", "<effect_id>", [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0]]}, 
					"water":			{ "desc": "Reduce damage of type water",					"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "enums", "defense", "reduction", "<source_ref>", "<effect_id>", [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0]]}, 
					"all":				{ "desc": "Reduce damage of type all",						"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "enums", "defense", "reduction", "<source_ref>", "<effect_id>", [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]]},
				},
				"stats": {
					"action": {
						"free": {
							"1":	{ "desc": "1 to free actions.", 								"rule": ["character.attributes.modifiers", "add", "delete"],		"args": ["<party>", "<char_idx>", "stats", "action", "free", "<source_ref>", "<effect_id>", {"total": 1}]},
							"-1": 	{ "desc": "-1 to free actions.", 								"rule": ["character.attributes.modifiers", "add", "delete"],		"args": ["<party>", "<char_idx>", "stats", "action", "free", "<source_ref>", "<effect_id>", {"total": -1}]},
						},
						"standard": {
							"1":	{ "desc": "1 to standard actions.", 							"rule": ["character.attributes.modifiers", "add", "delete"],		"args": ["<party>", "<char_idx>", "stats", "action", "standard", "<source_ref>", "<effect_id>", {"total": 1}]},
							"-1": 	{ "desc": "-1 to standard actions.", 							"rule": ["character.attributes.modifiers", "add", "delete"],		"args": ["<party>", "<char_idx>", "stats", "action", "standard", "<source_ref>", "<effect_id>", {"total": -1}]},
						},
						"reaction": {
							"1":	{ "desc": "1 to reaction actions.", 							"rule": ["character.attributes.modifiers", "add", "delete"],		"args": ["<party>", "<char_idx>", "stats", "action", "reaction", "<source_ref>", "<effect_id>", {"total": 1}]},
							"-1": 	{ "desc": "-1 to reaction actions.", 							"rule": ["character.attributes.modifiers", "add", "delete"],		"args": ["<party>", "<char_idx>", "stats", "action", "reaction", "<source_ref>", "<effect_id>", {"total": -1}]},
						}
					},
					"combat": {
						"attack": {
							"10":			{ "desc": "+10 to attack.",								"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "combat", "attack", "<source_ref>", "<effect_id>", {"total": 10}]},
							"-10":			{ "desc": "-10 to attack.",								"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "combat", "attack", "<source_ref>", "<effect_id>", {"total": -10}]},
							"-20":			{ "desc": "-20 to attack.",								"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "combat", "attack", "<source_ref>", "<effect_id>", {"total": -20}]},
							"-30":			{ "desc": "-30 to attack.",								"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "combat", "attack", "<source_ref>", "<effect_id>", {"total": -30}]},
						},
					},
				},
				"skill": {
					"acrobatics": {
						"-2":				{ "desc": "-2 to acrobatics.", 							"rule": ["character.attributes.modifiers", "add", "delete"],		"args": ["<party>", "<char_idx>", "stats", "skill", "acrobatics", "<source_ref>", "<effect_id>", {"total": -2}]},
						"-3":				{ "desc": "-3 to acrobatics.", 							"rule": ["character.attributes.modifiers", "add", "delete"],		"args": ["<party>", "<char_idx>", "stats", "skill", "acrobatics", "<source_ref>", "<effect_id>", {"total": -3}]},
						"-4":				{ "desc": "-4 to acrobatics.", 							"rule": ["character.attributes.modifiers", "add", "delete"],		"args": ["<party>", "<char_idx>", "stats", "skill", "acrobatics", "<source_ref>", "<effect_id>", {"total": -4}]},
						"-5":				{ "desc": "-5 to acrobatics.", 							"rule": ["character.attributes.modifiers", "add", "delete"],		"args": ["<party>", "<char_idx>", "stats", "skill", "acrobatics", "<source_ref>", "<effect_id>", {"total": -5}]},
						"-6":				{ "desc": "-6 to acrobatics.", 							"rule": ["character.attributes.modifiers", "add", "delete"],		"args": ["<party>", "<char_idx>", "stats", "skill", "acrobatics", "<source_ref>", "<effect_id>", {"total": -6}]},
						"-7":				{ "desc": "-7 to acrobatics.", 							"rule": ["character.attributes.modifiers", "add", "delete"],		"args": ["<party>", "<char_idx>", "stats", "skill", "acrobatics", "<source_ref>", "<effect_id>", {"total": -7}]},
						"-8":				{ "desc": "-8 to acrobatics.", 							"rule": ["character.attributes.modifiers", "add", "delete"],		"args": ["<party>", "<char_idx>", "stats", "skill", "acrobatics", "<source_ref>", "<effect_id>", {"total": -8}]},
						"-9":				{ "desc": "-9 to acrobatics.", 							"rule": ["character.attributes.modifiers", "add", "delete"],		"args": ["<party>", "<char_idx>", "stats", "skill", "acrobatics", "<source_ref>", "<effect_id>", {"total": -9}]},
						"-10":				{ "desc": "-10 to acrobatics.", 						"rule": ["character.attributes.modifiers", "add", "delete"],		"args": ["<party>", "<char_idx>", "stats", "skill", "acrobatics", "<source_ref>", "<effect_id>", {"total": -10}]},
					},
					"athletics": {
						"10":				{ "desc": "+10 to skill athletics.",					"rule": ["character.attributes.modifiers", "add", "delete"],		"args": ["<party>", "<char_idx>", "stats", "combat", "parry", "<source_ref>", "<effect_id>", {"total": 10} ]},
					},
					"dodge": {
						"-2":				{ "desc": "-2 to dodge.", 								"rule": ["character.attributes.modifiers", "add", "delete"],		"args": ["<party>", "<char_idx>", "stats", "skill", "dodge", "<source_ref>", "<effect_id>", {"total": -2}]},
						"-3":				{ "desc": "-3 to dodge.", 								"rule": ["character.attributes.modifiers", "add", "delete"],		"args": ["<party>", "<char_idx>", "stats", "skill", "dodge", "<source_ref>", "<effect_id>", {"total": -3}]},
						"-4":				{ "desc": "-4 to dodge.", 								"rule": ["character.attributes.modifiers", "add", "delete"],		"args": ["<party>", "<char_idx>", "stats", "skill", "dodge", "<source_ref>", "<effect_id>", {"total": -4}]},
						"-5":				{ "desc": "-5 to dodge.", 								"rule": ["character.attributes.modifiers", "add", "delete"],		"args": ["<party>", "<char_idx>", "stats", "skill", "dodge", "<source_ref>", "<effect_id>", {"total": -5}]},
						"-6":				{ "desc": "-6 to dodge.", 								"rule": ["character.attributes.modifiers", "add", "delete"],		"args": ["<party>", "<char_idx>", "stats", "skill", "dodge", "<source_ref>", "<effect_id>", {"total": -6}]},
						"-7":				{ "desc": "-7 to dodge.", 								"rule": ["character.attributes.modifiers", "add", "delete"],		"args": ["<party>", "<char_idx>", "stats", "skill", "dodge", "<source_ref>", "<effect_id>", {"total": -7}]},
						"-8":				{ "desc": "-8 to dodge.", 								"rule": ["character.attributes.modifiers", "add", "delete"],		"args": ["<party>", "<char_idx>", "stats", "skill", "dodge", "<source_ref>", "<effect_id>", {"total": -8}]},
						"-9":				{ "desc": "-9 to dodge.", 								"rule": ["character.attributes.modifiers", "add", "delete"],		"args": ["<party>", "<char_idx>", "stats", "skill", "dodge", "<source_ref>", "<effect_id>", {"total": -9}]},
						"-10":				{ "desc": "-10 to dodge.", 								"rule": ["character.attributes.modifiers", "add", "delete"],		"args": ["<party>", "<char_idx>", "stats", "skill", "dodge", "<source_ref>", "<effect_id>", {"total": -10}]},
					},
					"endurance": {
						"disease": {
							"+":			{ "desc": "Advantage on disease",						"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "checks", "vantage", "+skill+endurance+disease", "<source_ref>", "<effect_id>", 1]},
							"-":			{ "desc": "Disadvantage on disease",					"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "checks", "vantage", "+skill+endurance+disease", "<source_ref>", "<effect_id>", -1]},
						},
						"poison": {
							"+":			{ "desc": "Advantage on poison",						"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "checks", "vantage", "+skill+endurance+poison", "<source_ref>", "<effect_id>", 1]},
							"-":			{ "desc": "Disadvantage on poison",						"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "checks", "vantage", "+skill+endurance+poison", "<source_ref>", "<effect_id>", -1]},
						},
					},
					"perception": {
						"10":				{ "desc": "-10 perception.",							"rule": ["character.attributes.modifiers", "add", "delete"],		"args": ["<party>", "<char_idx>", "stats", "skill", "perception", "<source_ref>", "<effect_id>", {"total": 10}]},
						"-5":				{ "desc": "-5 perception.",								"rule": ["character.attributes.modifiers", "add", "delete"],		"args": ["<party>", "<char_idx>", "stats", "skill", "perception", "<source_ref>", "<effect_id>", {"total": -5} ]},
						"-10":				{ "desc": "-10 perception.",							"rule": ["character.attributes.modifiers", "add", "delete"],		"args": ["<party>", "<char_idx>", "stats", "skill", "perception", "<source_ref>", "<effect_id>", {"total": -10}]},
						"-15":				{ "desc": "-15 perception.",							"rule": ["character.attributes.modifiers", "add", "delete"],		"args": ["<party>", "<char_idx>", "stats", "skill", "perception", "<source_ref>", "<effect_id>", {"total": -15}]},
					},
					"magic_resist": {
						"+":				{ "desc": "Advantage on magic resist",					"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "checks", "vantage", "+skill+magic_resist", "<source_ref>", "<effect_id>", 1]},
						"-":				{ "desc": "Disadvantage on magic resist",				"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "checks", "vantage", "+skill+magic_resist", "<source_ref>", "<effect_id>", -1]},
						"-10":				{ "desc": "-10 to magic resist.",						"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "skill", "magic_resist", "<source_ref>", "<effect_id>", {"total": -10}]},
						"10":				{ "desc": "+10 to magic resist.",						"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "skill", "magic_resist", "<source_ref>", "<effect_id>", {"total": 10}]},
					},
					"medicine": {
						"-10":				{ "desc": "-10 to medicine.",							"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "skill", "medicine", "<source_ref>", "<effect_id>", {"total": -10}]},
						"10":				{ "desc": "+10 to medicine.",							"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "skill", "medicine", "<source_ref>", "<effect_id>", {"total": 10}]},
					},
					"resolve": {
						"fear": {
							"+":			{ "desc": "Advantage on magic resist",					"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "checks", "vantage", "+skill+resolve+fear", "<source_ref>", "<effect_id>", 1]},
							"-":			{ "desc": "Disadvantage on magic resist",				"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "checks", "vantage", "+skill+resolve+fear", "<source_ref>", "<effect_id>", -1]},
						}
					},
					"scavenge": {
						"10": 				{ "desc": "+10 to scavenge.",							"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "skill", "scavenge", "<source_ref>", "<effect_id>", {"total": 10}]},
					},
					"stealth": {
						"10":				{ "desc": "+10 to stealth.",							"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "skill", "stealth", "<source_ref>", "<effect_id>", {"total": 10}]},
						"-2":				{ "desc": "-2 to stealth.", 							"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "skill", "stealth", "<source_ref>", "<effect_id>", {"total": -2}]},
						"-3":				{ "desc": "-3 to stealth.", 							"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "skill", "stealth", "<source_ref>", "<effect_id>", {"total": -3}]},
						"-4":				{ "desc": "-4 to stealth.", 							"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "skill", "stealth", "<source_ref>", "<effect_id>", {"total": -4}]},
						"-5":				{ "desc": "-5 to stealth.", 							"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "skill", "stealth", "<source_ref>", "<effect_id>", {"total": -5}]},
						"-6":				{ "desc": "-6 to stealth.", 							"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "skill", "stealth", "<source_ref>", "<effect_id>", {"total": -6}]},
						"-7":				{ "desc": "-7 to stealth.", 							"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "skill", "stealth", "<source_ref>", "<effect_id>", {"total": -7}]},
						"-8":				{ "desc": "-8 to stealth.", 							"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "skill", "stealth", "<source_ref>", "<effect_id>", {"total": -8}]},
						"-9":				{ "desc": "-9 to stealth.",								"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "skill", "stealth", "<source_ref>", "<effect_id>", {"total": -9}]},
						"-10":				{ "desc": "-10 to stealth.",							"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "skill", "stealth", "<source_ref>", "<effect_id>", {"total": -10}]},
						"-20":				{ "desc": "-20 to stealth.",							"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "skill", "stealth", "<source_ref>", "<effect_id>", {"total": -20}]},
						"-30":				{ "desc": "-30 to stealth.",							"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "skill", "stealth", "<source_ref>", "<effect_id>", {"total": -30}]},
						"-40":				{ "desc": "-40 to stealth.",							"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "skill", "stealth", "<source_ref>", "<effect_id>", {"total": -40}]},
						"-50":				{ "desc": "-50 to stealth.",							"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "skill", "stealth", "<source_ref>", "<effect_id>", {"total": -50}]},
						"-60":				{ "desc": "-60 to stealth.",							"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "skill", "stealth", "<source_ref>", "<effect_id>", {"total": -60}]},
					},
				},
				"combat": {
					"attack": {
						"-10":			{ "desc": "-10 to combat attack.",								"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "combat", "attack", "<source_ref>", "<effect_id>", {"total": -10}]},
						"-5":				{ "desc": "-5 to combat attack.",									"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "combat", "attack", "<source_ref>", "<effect_id>", {"total": -5}]},
						"5":				{ "desc": "+5 to combat attack.",									"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "combat", "attack", "<source_ref>", "<effect_id>", {"total": 5}]},
						"10":				{ "desc": "+10 to combat attack.",								"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "combat", "attack", "<source_ref>", "<effect_id>", {"total": 10}]},
					},
					"parry": {
						"+":				{ "desc": "Advantage on parry",										"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "checks", "vantage", "+combat+defend+parry", "<source_ref>", "<effect_id>", 1]},
						"-":				{ "desc": "Disadvantage on parry",								"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "checks", "vantage", "+combat+defend+parry", "<source_ref>", "<effect_id>", -1]},
						"-10":			{ "desc": "-10 to combat parry.",									"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "combat", "parry", "<source_ref>", "<effect_id>", {"total": -10}]},
						"-5":				{ "desc": "-5 to combat parry.",									"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "combat", "parry", "<source_ref>", "<effect_id>", {"total": -5}]},
						"5":				{ "desc": "+5 to combat parry.",									"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "combat", "parry", "<source_ref>", "<effect_id>", {"total": 5}]},
						"10":				{ "desc": "+10 to combat parry.",									"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "combat", "parry", "<source_ref>", "<effect_id>", {"total": 10}]},
						"15":				{ "desc": "+15 to combat parry.",									"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "combat", "parry", "<source_ref>", "<effect_id>", {"total": 5}]},
						"20":				{ "desc": "+20 to combat parry.",									"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "combat", "parry", "<source_ref>", "<effect_id>", {"total": 10}]},
					},
					"initiative": {
						"10":				{ "desc": "+10 to combat initiative.",						"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "combat", "initiative", "<source_ref>", "<effect_id>", {"total": 10}]},
					},
					"damage": {
						"1":				{ "desc": "+1 to combat damage.",									"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "combat", "damage", "<source_ref>", "<effect_id>", {"total": 1}]},
					},
					"dealt": {
						"1":				{ "desc": "+1 to combat dealt.",									"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "combat", "dealt", "<source_ref>", "<effect_id>", {"total": 1}]},
					},
				},
				"traverse": {
					"break": {
						"10": 			{ "desc": "+10 to traverse break.",								"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "traverse", "break", "<source_ref>", "<effect_id>", {"total": 10}]},
					},
					"disarm": {
						"10":				{ "desc": "+10 to traverse disarm.",							"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "traverse", "disarm", "<source_ref>", "<effect_id>", {"total": 10}]},
					},
					"inventory": {
						"5":				{ "desc": "+5 inventory size.",										"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "traversal", "inventory", "<source_ref>", "<effect_id>", {"total": 0}]},
						"10":				{ "desc": "+10 inventory size.",									"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "traversal", "inventory", "<source_ref>", "<effect_id>", {"total": 0}]},
						"20":				{ "desc": "+20 inventory size.",									"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "traversal", "inventory", "<source_ref>", "<effect_id>", {"total": 0}]},
					},
				},
				"camp": {
					"check": {
						"1": 				{ "desc": "+1 to camp check.",										"rule": ["character.attributes.modifiers", "add", "delete"], 	"args": ["<party>", "<char_idx>", "stats", "camp", "check", "<source_ref>", "<effect_id>", {"total": 1}]},
					}
				},
				"listener": {
					"cracked_soul": {
						"desc": "Reduce aether roll die: D6 -> D4",
						"rule": ["character.listener", "add"], 
						"args": ["<party>", "<char_idx>", "default", "<source_ref>", 1, {
							"trigger": 	["<party>.<char_idx>.stats.aether.roll", 									"character.biography.flaws.cracked_soul_proc",["$event_idx$", 4]], 
							"delete": 	["$limit$"]}]	
					},
					"defensive": 		{ 
						"desc": "If shield, +10 combat parry.",
						"rule": ["character.listener", "add"], 
						"args": ["<party>", "<char_idx>", "default", "equipped.main_hand.defensive", 1, {
							"trigger": 	["<party>.<char_idx>.equipped.off_hand.shield", 					"character.attributes.modifiers.add", 						["<party>", "<char_idx>", "stats", "combat", "parry", "<source_ref>.defensive", "<effect_id>", {"max": 0, "total": 10}]], 
							"delete": 	["<party>.<char_idx>.equipped.main_hand.", 								"character.attributes.modifiers.delete",					["<party>", "<char_idx>", "stats", "combat", "parry", "<source_ref>.defensive", "<effect_id>"]],
							"reset":		["<party>.<char_idx>.equipped.off_hand.((?!shield)\\w+)",	"character.attributes.modifiers.delete",					["<party>", "<char_idx>", "stats", "combat", "parry", "<source_ref>.defensive", "<effect_id>"]]}]
					},
					"death_check": 		{ 
						"desc": "If health reaches 0.",
						"rule": ["character.listener", "add"], 
						"args": ["<party>", "<char_idx>", "default", "on_death", 1, {
							"trigger": 	["<party>.<char_idx>.stats.base.health.0", 					"character.death", 						["<party>", "<char_idx>"]], 
							"delete": 	["$limit$"]}]
					},
					"fragile_mind": {
						"desc": "Reduce sanity roll die: D6 -> D4",
						"rule": ["character.listener", "add"], 
						"args": ["<party>", "<char_idx>", "default", "<source_ref>", 1, {
							"trigger": 	["<party>.<char_idx>.stats.sanity.roll", 									"character.biography.flaws.fragile_mind_proc",		["$event_idx$", 4]], 
							"delete": 	["$limit$"]}]	
					},
					"surprise_bonus": {
						"desc": "+20 to first combat roll",
						"rule": ["character.listener", "add"], 
						"args": ["<party>", "<char_idx>", "default", "<source_ref>", 1, {
							"trigger": 	["<party>.<char_idx>.combat.roll", 												"character.attributes.modifiers.add", 						["<party>", "<char_idx>", "stats", "combat", "attack", "<source_ref>", "<effect_id>", {"max": 0, "total": 20}]], 
							"delete": 	["$limit$", 																							"character.attributes.modifiers.delete",					["<party>", "<char_idx>", "stats", "combat", "attack", "<source_ref>", "<effect_id>"]],
						}]
					},
					"surprise_companion_penalty": {
						"desc": "-10 per entity in the party past 1.",
						"rule": ["character.listener", "add"], 
						"args": ["<party>", "<char_idx>", "default", "<source_ref>", 1, {
							"trigger": 	["<party>.<char_idx>.surprise.roll", 											"effects.surprise_companion_penalty.add",					["<party>", "<char_idx>"]],
							"delete": 	["$limit$", 																							"effects.surprise_companion_penalty.delete",			["<party>", "<char_idx>"]],
						}]
					},
					"surprise_fail_penalty": {
						"desc": "-10 on initiative.",
						"rule": ["character.listener", "add"], 
						"args": ["<party>", "<char_idx>", "default", "<source_ref>", 1, {
							"trigger": 	["<party>.<char_idx>.initiative.roll", 										"effects.surprise_fail_penalty.add",							["<party>", "<char_idx>"]],
							"delete": 	["$limit$", 																							"effects.surprise_fail_penalty.delete",						["<party>", "<char_idx>"]],
						}]
					},
					"target_attack_penalty": {
						"desc": "-30 for using a targeted attack.",
						"rule": ["character.listener", "add"], 
						"args": ["<party>", "<char_idx>", "default", "<source_ref>", 1, {
							"trigger": 	["<party>.<char_idx>.combat.roll.attack.check", 					"character.attributes.modifiers.add",						["<party>", "<char_idx>", "<source_ref>", "stats.combat.attack.-30"]],
							"delete": 	["$limit$", 														"character.attributes.modifiers.delete",					["<party>", "<char_idx>", "<source_ref>"]],
						}]
					},
					"two_handed": 	{ 
						"desc": "Unequip if equip to off_hand.", 												
						"rule": ["character.listener", "add"], 
						"args": ["<party>", "<char_idx>", "default", "equipped.main_hand.two_handed", 1, {
							"trigger":	["<party>.<char_idx>.equipped.off_hand.((?!null|undefined)\\w+)", "character.inventory.equipment.unequip",	["<party>", "<char_idx>", "<source_ref>", "equipped.main_hand"]],
							"delete":		["<party>.<char_idx>.equipped.main_hand"]}],
					},
					"standard_action": {
						"desc": "-1 to standard actions.",
						"rule": ["character.listener", "add"], 
						"args": ["<party>", "<char_idx>", "default", "<source_ref>", "*", {
							"trigger": 	["<party>.<char_idx>.combat.turn.standard", 							"character.attributes.modifiers.add",						["<party>", "<char_idx>", "<source_ref>.standard", "stats.actions.standard.-1"]],
							"delete": 	["combat.round.end",													"character.attributes.modifiers.delete",					["<party>", "<char_idx>", "<source_ref>.standard"]],
						}]
					},
					"free_action": {
						"desc": "-1 to free actions.",
						"rule": ["character.listener", "add"], 
						"args": ["<party>", "<char_idx>", "default", "<source_ref>", "*", {
							"trigger": 	["<party>.<char_idx>.combat.turn.free", 									"character.attributes.modifiers.add",						["<party>", "<char_idx>", "<source_ref>.free", "stats.actions.free.-1"]],
							"delete": 	["combat.round.end",														"character.attributes.modifiers.delete",					["<party>", "<char_idx>", "<source_ref>.free"]],
						}]
					},
					"re_action": {
						"desc": "-1 to re-actions.",
						"rule": ["character.listener", "add"], 
						"args": ["<party>", "<char_idx>", "default", "<source_ref>", "*", {
							"trigger": 	["<party>.<char_idx>.combat.turn.reaction", 							"character.attributes.modifiers.add",						["<party>", "<char_idx>", "<source_ref>.reaction", "stats.actions.reaction.-1"]],
							"delete": 	["<party>.<char_idx>.combat.turn.start",								"character.attributes.modifiers.delete",					["<party>", "<char_idx>", "<source_ref>.reaction"]],
						}]
					},
					"versatile": 		{
						"desc": "If two handed, +1 damage.",
						"rule": ["character.attributes.modifiers", "add", "delete"], 
						"args": ["<party>", "<char_idx>", "default", "equipped.main_hand.versatile", 1, {
							"trigger":	["equipped.off_hand.((?!null|undefined)\\w+)",						"character.attributes.modifiers.add", 						["<party>", "<char_idx>", "<to_item>.versatile", "combat.damage.1"]],
							"delete":		["<party>.<char_idx>.equipped.main_hand",						"character.attributes.modifiers.delete",					["<party>", "<char_idx>", "<to_item>.versatile"]],
							"reset":		["<party>.<char_idx>.equipped.off_hand.(null|undefined)", 		"character.attributes.modifiers.delete",					["<party>", "<char_idx>", "<to_item>.versatile"]]}],
					},
					// ---------------------------
					"on_death": 		{
						"desc": "If character has died for encounters.",
						"rule": ["character.attributes.listeners", "add", "delete"], 
						"args": ["<party>", "<char_idx>", "default", "is_dead", 1, {
							"trigger": 	["<party>.<char_idx>.died", 															"character.death",		[]], 
							"delete": 	["$limit$"]}],
					},
				},

				"todo": {
					"damage_reduction":			{"rule": ["roll_damage_type_reduction_by_rarity", [1,2,3]]},
					"magic_resist":				{"rule": ["roll_magic_resist_by_rarity", [10,20,30]]},
					"aether_for_toughness":		{"rule": ["add_modifiers", [{"stats.aether":{"max":-5}}, {"stats.toughness":{"max":10}}]]},
					"toughness_for_aether":		{"rule": ["add_modifiers", [{"stats.toughness":{"max":-5}}, {"stats.aether":{"max":10}}]]},
					"damage_resistance":		{"rule": ["damage_type_resistance"]},
					"intimidate":				{"rule": ["add_modifiers", [{"traits.intimidation":{"base":10}}]]},
					"light_source":				{"rule": ["add_light_source"]},
					"carry_capacity":			{"rule": ["add_modifiers", [{"inventory.size":{"max":10}}]]},
					"daily_reroll":				{"rule": ["reroll_once_per_camp"]},
					"heal_wounds":				{"rule": ["add_heal_wounds_action_by_rarity", [[10,2], [10,3], [10,4]]]},
					"heal_wounds":				{"rule": ["add_heal_wounds_action", [[10,0]]]},
					"recover_toughness":		{"rule": ["enchanted_toughness_recovery"]},
					"stun_immunity":			{"rule": ["add_modifiers", [{"defense.effects":{"stun":0}}]]},
					"fear_immunity":			{"rule": ["add_modifiers", [{"defense.effects":{"fear":0}}]]},
					"belt_check_immunity":		{"rule": []},
					"entangle_immunity":		{"rule": ["add_modifiers", [{"defense.effects":{"entangle":0}}]]},
					"paralysis_immunity":		{"rule": ["add_modifiers", [{"defense.effects":{"paralyze":0}}]]},
					"entangle":					{"rule": ["add_entangle_action"]},
					"shadow_phase":				{"rule": ["add_shadow_phase_action"]},
					"ignore_madness":			{"rule": []},
					"skill_increase":			{"rule": ["choose_skill_to_boost", [20]]},
					"master_lockpick":			{"rule": ["add_lockpick_reroll_on_fail"]},
					"master_trapper":			{"rule": ["add_disarm_reroll_on_fail"]},
					"improved_camp_health":		{"rule": ["camp_healing_roll", [4]]},
					"improved_camp_sanity":		{"rule": ["camp_sanity_roll", [4]]},
					"improved_fist":			{"rule": ["add_modifiers", [{"skills.fist":{"base":30}}]]},
					"improved_stamina":			{"rule": ["add_exhaustion_resist_by_rarity", [1,2,3]]},
					"improved_acrobatics":		{"rule": ["add_modifiers", [{"skills.acrobatics":{"roll":1}}]]},
					"improved_athletics":		{"rule": ["add_modifiers", [{"skills.athletics":{"roll":1}}]]},
					"improved_scavenge":		{"rule": ["add_modifiers", [{"skills.scavenge":{"roll":1}}]]},
					"improved_stealth":			{"rule": ["add_modifiers", [{"skills.stealth":{"roll":1}}]]},
					"roll_with_it":				{"rule": ["ignore_fumble_daily"]},
					"crafty":					{"rule": ["double_found_crafting_supplies"]},
					"collector":				{"rule": ["augment_scavenge_roll", [4]]},
					"sturdy_boots":				{"rule": ["add_modifiers", [{"defense.armor":{"legs":1}}]]},
					"sturdy_gloves":			{"rule": ["add_modifiers", [{"defense.armor":{"arms":1}}]]},
					"just_do_it":				{"rule": ["reroll_failed_dodge_per_room"]},
					"spartan_kick":				{"rule": ["add_spartan_kick_action"]},
					"light_on_your_feet":		{"rule": []},
					"one_punch":				{"rule": ["add_one_punch_action"]},
					"deflection":				{"rule": ["add_modifiers", [{"traits.parry":{"base":10}}]]},
					"aether_well":				{"rule": ["roll_for_modifier", ["stats.aether", "max", 10]]},
					"free_cast":				{"rule": ["cast_spell_for_free"]},
					"imbue_damage":				{"rule": ["roll_for_optional_attack_damage_type"]},
					"extra_damage":				{"rule": ["add_modifiers", [{"traits.damage":{"base":10}}]]},
					"vampiric":					{"rule": ["heal_on_kill", [1]]},
					"reinforced":				{"rule": ["roll_for_modifier", ["stats.toughness", "max", 10]]},
					//Fragments
					"ritual_dagger":			{"rule": ["summon_skeleton"]},
					"tattered_cloak": 			{"rule": ["invisibility_for_x_rooms", [5]]},
					"refracting_mirror": 		{"rule": ["add_modifiers", [{"defensive.checks":{"base":30}}]]},
					"grounding_chain": 			{"rule": ["add_temporary_modifiers", [{"traits.sanity":{"base":10}}]]},
					/*"black_heart_babble":		{"rule": ["rule_id"]},
					"cracked_monocle": 			{"rule": ["rule_id"]},
					"green_vial":				{"rule": ["rule_id"]},
					"enchanted_skull":			{"rule": ["rule_id"]},
					"cursed_bandages":			{"rule": ["rule_id"]}, //removing negative effect for equipped for too long.
					"blood_potion":				{"rule": ["rule_id"]},
					"ravens_trinket":			{"rule": ["rule_id"]},
					"spiked_gauntlets":			{"rule": ["rule_id"]},
					"black_vial":				{"rule": ["rule_id"]},
					"spider_locket":			{"rule": ["rule_id"]},
					"obsidian_whistle":			{"rule": ["rule_id"]},
					"miasma_flask":				{"rule": ["rule_id"]},
					"broken_harp":				{"rule": ["rule_id"]},
					"ancient_grimoire":			{"rule": ["rule_id"]},
					"amethyst_ring":			{"rule": ["rule_id"]},
					"frozen_hourglass":			{"rule": ["rule_id"]},*/
					// Usables
					"use_bandage":					["dice.roll_clamp_and_add_to",	[4, "stats.toughness.max", "stats.toughness.base"]],
					"refill_lamp":					["static.clamp_and_add_to", 	[1, "light_source.max", "light_source.base"]],
				},
			},
			"enums": {
				"legend": {"vulnerable": 1, "resist": 0.5, "immune": 0, "healed": -1},
				"armor":	{
					"helmet": 	[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
					"vambrace": [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0],
					"torso": 	[0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
					"greave": 	[1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
				},
				"conditions":	[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
				"affinity":		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
				"reduction":	[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
				"imbued":		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
			},
			"items": {
				"prices": {
					"rarity":	{"uncommon": 200, "rare": 400, "epic": 600},
					"gems": 	{"ornamental": [1,100], "semi_precious": [2,100], "precious": [3,100], "lavish": [4,100],	"sumptuous": [5,100],	"extravagant": [6,100]},
				},
				"distribution": {
					"random": {
						"armor": 		["tables.suit","tables.suit","torso","torso","torso","torso","torso","vambrace","vambrace","vambrace","vambrace","vambrace","greave","greave","greave","greave","greave","helmet","shield","shield",],
						"material":		["cloth","rawhide","studded","laminar","leather","mail","scale","brigandine","plate",],
						"shield": 		["target", "normal", "full", "wall"],
						"weapon": 		["bardiche","bastard_sword","billhook","claw","club","dagger","flail","glaive","great_axe","great_club","great_sword","halberd","hatchet","harpoon","improvised","knuckles","light_hammer","long_sword","maul","mace","morningstar","pike","pilum","quarterstaff","rapier","saber","scimitar","shiv","short_sword","spear","warhammer","war_pick"],
						"item":			["random.weapon", "random.armor", "gear.belt", "gear.boots", "gear.amulet", "gear.ring", "gear.ring"],
						"potion":		["aether", "antidote", "coagulant", "courage", "flaming", "frenzy", "health", "health", "regeneration", "poison", "cleanse", "vigor", "vigor", "satiation", "calmness", "haste", "haste", "stoneskin", "strength", "vitality"],
						"spoils":		["tables.random.mundane","tables.random.mundane","tables.random.mundane","tables.random.valuable","tables.random.valuable","tables.random.precious"],
						"mundane":		["tables.supplies.crafting_s","tables.supplies.crafting_s","tables.supplies.crafting_s","tables.supplies.crafting_s","tables.supplies.crafting_s","tables.supplies.cooking_s","tables.supplies.cooking_s","tables.supplies.cooking_s","tables.supplies.cooking_s","tables.supplies.cooking_s","gear.backpack"],
						"valuable":		["tables.random.potion","tables.random.potion","tables.random.potion","tables.random.potion","tables.random.potion","crystal","crystal","crystal","crystal","crystal","crystal","crystal","tables.random.fragment","tables.random.fragment","tables.random.fragment","tables.random.fragment","tables.random.item","tables.random.item","tables.random.item","tables.random.item"],
						"precious":		["tables.random.item","tables.random.item","tables.random.item","tables.random.relic"],
						"gems": 		["ornamental","ornamental","semi_precious","semi_precious","semi_precious","precious","precious","precious","precious","precious","lavish","lavish","lavish","lavish","sumptuous","sumptuous","sumptuous","extravagant","extravagant"],
						"fragment":		["ritual_dagger","tattered_cloak","refracting_mirror","grounding_chain","black_heart_babble","cracked_monocle","green_vial","enchanted_skull","cursed_bandages","blood_potion","ravens_trinket","spiked_gauntlets","black_vial","spider_locket","obsidian_whistle","miasma_flask","broken_harp","ancient_grimoire","amethyst_ring","frozen_hourglass",],
						"relic":		[],
						"rarity":		["uncommon", "uncommon", "uncommon", "uncommon", "uncommon", "rare", "rare", "rare", "epic", "epic"],
						"resource":		["nothing", "nothing", "cooking_s", "cooking_s", "cooking_s", "cooking_s", "crafting_s", "crafting_s", "crafting_s", "crafting_s"],
						"book":			["shadows_of_devotion", "aetheric_tailoring", "mysteries_of_death", "contemplations_on_the_tapestry_of_realms", "the_battle_of_curum", "the_midnight_throne", "a_thousand_years_of_glory", "rising_shadows", "the_third_path", "the_ganeus_rebellion"]
					},
					"effects": {
						"armor": 		["damage_reduction","damage_reduction","damage_reduction","damage_reduction","magic_resist","aether_for_toughness","toughness_for_aether","damage_resistance","intimidate","light_source","carry_capacity","daily_reroll","heal_wounds","recover_toughness","stun_immunity","fear_immunity","entangle","shadow_phase",],
						"belt": 		["damage_reduction","magic_resist","damage_resistance","carry_capacity","daily_reroll","belt_check_immunity","recover_toughness","stun_immunity","fear_immunity","skill_increase","improved_camp_health","improved_camp_sanity","ignore_madness","improved_stamina","master_lockpick","master_trapper","light_source","heal_wounds",],
						"boots": 		["damage_reduction","magic_resist","daily_reroll","stun_immunity","entangle_immunity","skill_increase","improved_stamina","master_lockpick","master_trapper","improved_acrobatics","improved_stealth","roll_with_it","crafty","improved_scavenge","collector","sturdy_boots","just_do_it","spartan_kick","light_on_your_feet","paralysis_immunity",],
						"gloves": 		["damage_reduction","magic_resist","daily_reroll","skill_increase","improved_stamina","improved_athletics","improved_fist","master_lockpick","master_trapper","one_punch","improved_scavenge","collector","sturdy_gloves","deflection","aether_well","free_cast","imbue_damage","extra_damage","vampiric","reinforced"],
						"ring": 		[],
						"weapon": 		[],
					},
					"enchanted": {
						"armor": 		[true,false,false,false,false,false,false,false,false,false],
						"weapon": 		[true,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false],
						"valuable": 	[false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,true,true,true,true],
						"precious": 	[true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,false,false,false,false,false],
					},
					"traits": {
						"potion":  		["poisoned", "poisoned", "explosive", "explosive", "impotent", "impotent", "normal", "normal", "normal", "refined", "refined", "enhanced"],
					},
					"supplies": {
						"crafting_s": 	[1,2,3,4],
						"cooking_s": 	[1,2,3,4],
						"ritual_s": 	[1,2,3,4],
					},
					"suit": 			["torso", "vambrace", "greave"],
				},
				"weapon": {
					"bardiche": 		{"name": "bardiche", 					"type": "weapon", 	"cost": [8,15], 	"size": 2,			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["listener.two_handed",	"combat.dealt.1",					"actions.slash.pole",	"actions.stab.pole"]},
					"bastard_sword":	{"name": "bastard_sword", 				"type": "weapon", 	"cost": [15,30],	"size": 1, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["listener.versatile",		"combat.parry.10",				"combat.attack.5",		"actions.slash.blade", "actions.stab.blade"]},	
					"billhook": 		{"name": "billhook", 					"type": "weapon", 	"cost": [5,10], 	"size": 1, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["listener.two_handed",	"combat.dealt.1",					"actions.slash.pole"]},
					"claw": 			{"name": "claw", 						"type": "weapon", 	"cost": [10,20],	"size": 1, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["combat.initiative.10",	"combat.attack.10",				"combat.parry.20",		"actions.slash.fist"]},
					"club": 			{"name": "club", 						"type": "weapon", 	"cost": [3,5],		"size": 1, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["combat.attack.15",			"combat.parry.15",				"smash.bludgeon"]},
					"dagger":			{"name": "dagger", 						"type": "weapon", 	"cost": [3,5],		"size": 1, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["combat.initiative.10",	"combat.attack.10", 			"combat.parry.20",		"actions.slash.blade", "actions.stab.blade"]},
					"flail": 			{"name": "flail", 						"type": "weapon", 	"cost": [15,30],	"size": 1, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["combat.attack.5", 			"combat.parry.5", 				"actions.smash.bludgeon"]},
					"glaive": 			{"name": "glaive", 						"type": "weapon", 	"cost": [8,15],		"size": 2, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["listener.two_handed", 	"combat.dealt.1", 				"actions.slash.pole"]},
					"great_axe": 		{"name": "great_axe", 					"type": "weapon", 	"cost": [25,50],	"size": 2, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["listener.two_handed", 	"combat.dealt.1", 				"combat.damage.1",		"combat.attack.-10",	"combat.parry.-10", "actions.slash.blade"]},
					"great_club": 		{"name": "great_club", 					"type": "weapon", 	"cost": [10,20],	"size": 2, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["listener.two_handed", 	"combat.dealt.1", 				"combat.damage.1",		"combat.attack.-10",	"combat.parry.-10", "actions.smash.bludgeon"]},
					"great_sword": 		{"name": "great_sword", 				"type": "weapon", 	"cost": [40,80],	"size": 2, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["listener.two_handed", 	"combat.dealt.1", 				"combat.damage.1",		"combat.attack.-5",		"combat.parry.-5",	"actions.slash.blade"]},
					"halberd": 			{"name": "halberd", 					"type": "weapon", 	"cost": [8,15], 	"size": 2, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["listener.two_handed", 	"combat.dealt.1",					"actions.slash.pole",	"actions.stab.pole"]},
					"hatchet":			{"name": "hatchet", 					"type": "weapon", 	"cost": [3,5],		"size": 1, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["combat.attack.15",			"combat.parry.15",				"actions.slash.blade"]},
					"harpoon": 			{"name": "harpoon", 					"type": "weapon", 	"cost": [5,10], 	"size": 1, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["combat.attack.5", 			"combat.parry.5", 				"actions.stab.pole"]},
					"improvised": 		{"name": "improvised", 					"type": "weapon", 	"cost": [1,1],		"size": 1, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["listener.two_handed", 	"combat.dealt.1",					"combat.attack.-10",	"combat.parry.-10",		"actions.smash.bludgeon"]},
					"knuckles": 		{"name": "knuckles", 					"type": "weapon", 	"cost": [3,5],		"size": 1, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["combat.initiative.10",	"combat.attack.20",				"combat.parry.20",		"actions.smash.bludgeon"]},
					"light_hammer": 	{"name": "light_hammer", 				"type": "weapon", 	"cost": [3,5],		"size": 1, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["combat.initiative.10",	"combat.attack.5",				"combat.parry.5",			"actions.smash.bludgeon"]},
					"long_sword":		{"name": "long_sword", 					"type": "weapon", 	"cost": [10,20],	"size": 1, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["listener.versatile",		"combat.parry.10",				"actions.slash.blade",	"actions.stab.blade"]},
					"maul": 			{"name": "maul", 						"type": "weapon", 	"cost": [10,20],	"size": 1, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["actions.smash.bludgeon"]},
					"mace": 			{"name": "maul", 						"type": "weapon", 	"cost": [8,15],		"size": 1, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["actions.smash.bludgeon"]},
					"morningstar": 		{"name": "morningstar", 				"type": "weapon", 	"cost": [8,15],		"size": 1, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["combat.damage.1", 			"smash.bludgeon",					"actions.stab.bludgeon"]},
					"pike": 			{"name": "pike", 						"type": "weapon", 	"cost": [5,10], 	"size": 1, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["listener.two_handed", 	"combat.dealt.1",					"actions.stab.pole"]},
					"pilum": 			{"name": "pilum", 						"type": "weapon", 	"cost": [5,10], 	"size": 1, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["listener.defensive",		"actions.stab.pole"]},
					"quarterstaff": 	{"name": "quarterstaff", 				"type": "weapon", 	"cost": [3,5],		"size": 2, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["listener.two_handed",	"combat.dealt.1",					"combat.attack.5",	"combat.parry.5",				"actions.smash.pole"]},
					"rapier":			{"name": "rapier", 						"type": "weapon", 	"cost": [15,30],	"size": 1, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["combat.initiative.10",	"combat.attack.10",				"combat.parry.10",	"actions.stab.blade"]},
					"saber":			{"name": "saber", 						"type": "weapon", 	"cost": [10,20],	"size": 1, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["combat.parry.10",			"combat.attack.5",				"combat.parry.5",		"actions.slash.blade"]},
					"scimitar":			{"name": "scimitar", 					"type": "weapon", 	"cost": [8,15],		"size": 1, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["combat.parry.10",			"combat.attack.5",				"combat.parry.5",		"actions.slash.blade"]},
					"shiv":				{"name": "shiv", 						"type": "weapon", 	"cost": [3,5],		"size": 1, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["combat.initiative.10",	"combat.attack.20",				"combat.parry.20",	"actions.stab.blade"]},
					"short_sword":		{"name": "short_sword", 				"type": "weapon", 	"cost": [8,15],		"size": 1, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["listener.defensive",		"combat.attack.5",				"combat.parry.5",		"actions.slash.blade",	"actions.stab.blade"]},
					"spear": 			{"name": "spear", 						"type": "weapon", 	"cost": [5,10],		"size": 1, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["listener.defensive",		"listener.versatile",			"combat.attack.5",	"combat.parry.5",				"actions.stab.pole"]},
					"warhammer": 		{"name": "warhammer", 					"type": "weapon", 	"cost": [13,25],	"size": 2, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["listener.two_handed",	"combat.dealt.1", 				"combat.damage.1",	"combat.attack.-10",		"combat.parry.-10",	"actions.smash.bludgeon"]},
					"war_pick": 		{"name": "war_pick", 					"type": "weapon", 	"cost": [8,15],		"size": 1, 			"item": ["equip_to.main_hand", "counter.integrity.1"],		"effects": ["combat.damage.1",			"actions.smash.bludgeon",	"actions.stab.bludgeon"]},
				},
				"helmet": {
					"cloth": 			{"name":"cloth_helmet", 				"type": "helmet", 	"cost": [10,20], 	"size": 1,			"item": ["equip_to.helmet", "counter.integrity.6"	],			"effects": ["skill.perception.-1", "armor.helmet.1"]},
					"rawhide": 			{"name":"rawhide_helmet", 				"type": "helmet", 	"cost": [15,30], 	"size": 1,			"item": ["equip_to.helmet", "counter.integrity.8"	],			"effects": ["skill.perception.-1", "armor.helmet.1"]},
					"studded": 			{"name":"studded_helmet", 				"type": "helmet", 	"cost": [20,40], 	"size": 1,			"item": ["equip_to.helmet", "counter.integrity.10"],			"effects": ["skill.perception.-1", "armor.helmet.1"]},
					"laminar": 			{"name":"laminar_helmet", 				"type": "helmet", 	"cost": [25,50], 	"size": 1,			"item": ["equip_to.helmet", "counter.integrity.6"	],			"effects": ["skill.perception.-2", "armor.helmet.2"]},
					"leather": 			{"name":"leather_helmet", 				"type": "helmet", 	"cost": [30,60], 	"size": 1,			"item": ["equip_to.helmet", "counter.integrity.8"	],			"effects": ["skill.perception.-2", "armor.helmet.2"]},
					"mail": 			{"name":"mail_helmet", 					"type": "helmet", 	"cost": [35,70], 	"size": 1,			"item": ["equip_to.helmet", "counter.integrity.10"],			"effects": ["skill.perception.-2", "armor.helmet.2"]},
					"scale": 			{"name":"scale_helmet", 				"type": "helmet", 	"cost": [40,80], 	"size": 1,			"item": ["equip_to.helmet", "counter.integrity.8"	],			"effects": ["skill.perception.-3", "armor.helmet.3"]},
					"brigandine": 		{"name":"brigandine_helmet",			"type": "helmet", 	"cost": [45,90], 	"size": 1,			"item": ["equip_to.helmet", "counter.integrity.10"],			"effects": ["skill.perception.-3", "armor.helmet.3"]},
					"plate": 			{"name":"plate_helmet", 				"type": "helmet", 	"cost": [50,100],	"size": 1,			"item": ["equip_to.helmet", "counter.integrity.12"],			"effects": ["skill.perception.-3", "armor.helmet.3"]},
				},
				"torso": {
					"cloth": 			{"name":"cloth_armor", 					"type": "torso", 		"cost": [20,40],		"size": 1, 		"item": ["equip_to.torso", "counter.integrity.6"	],			"effects": ["skill.acrobatics.-4",	"skill.dodge.-4",		"skill.stealth.-4",		"armor.torso.1"]},
					"rawhide": 			{"name":"rawhide_armor", 				"type": "torso", 		"cost": [30,60],		"size": 1, 		"item": ["equip_to.torso", "counter.integrity.8"	],			"effects": ["skill.acrobatics.-4",	"skill.dodge.-4",		"skill.stealth.-4",		"armor.torso.1"]},
					"studded": 			{"name":"studded_armor", 				"type": "torso", 		"cost": [40,80],		"size": 1, 		"item": ["equip_to.torso", "counter.integrity.10"	],			"effects": ["skill.acrobatics.-5",	"skill.dodge.-5",		"skill.stealth.-5",		"armor.torso.1"]},
					"laminar": 			{"name":"laminar_armor", 				"type": "torso", 		"cost": [50,100],		"size": 1, 		"item": ["equip_to.torso", "counter.integrity.6"	],			"effects": ["skill.acrobatics.-6",	"skill.dodge.-6",		"skill.stealth.-6",		"armor.torso.2"]},
					"leather": 			{"name":"leather_armor", 				"type": "torso", 		"cost": [60,120],		"size": 1, 		"item": ["equip_to.torso", "counter.integrity.8"	],			"effects": ["skill.acrobatics.-6",	"skill.dodge.-6",		"skill.stealth.-6",		"armor.torso.2"]},
					"mail": 			{"name":"mail_armor", 					"type": "torso", 		"cost": [70,140],		"size": 1, 		"item": ["equip_to.torso", "counter.integrity.10"	],			"effects": ["skill.acrobatics.-7",	"skill.dodge.-7",		"skill.stealth.-7",		"armor.torso.2"]},
					"scale": 			{"name":"scale_armor", 					"type": "torso", 		"cost": [80,160],		"size": 1, 		"item": ["equip_to.torso", "counter.integrity.8"	],			"effects": ["skill.acrobatics.-8",	"skill.dodge.-8",		"skill.stealth.-8",		"armor.torso.3"]},
					"brigandine": 		{"name":"brigandine_armor", 			"type": "torso", 		"cost": [90,180],		"size": 1, 		"item": ["equip_to.torso", "counter.integrity.10"	],			"effects": ["skill.acrobatics.-9",	"skill.dodge.-9",		"skill.stealth.-9",		"armor.torso.3"]},
					"plate": 			{"name":"plate_armor", 					"type": "torso", 		"cost": [100,200],		"size": 1, 		"item": ["equip_to.torso", "counter.integrity.12"	],			"effects": ["skill.acrobatics.-10",	"skill.dodge.-10",	"skill.stealth.-10",	"armor.torso.3"]},
				},	
				"vambrace": {	
					"cloth": 			{"name":"cloth_vambraces",			"type": "vambrace", "cost": [10,20],		"size": 1, 		"item": ["equip_to.vambrace", "counter.integrity.6"	],		"effects": ["skill.acrobatics.-2",	"skill.dodge.-2",		"skill.stealth.-2",		"armor.vambrace.1"]}, 
					"rawhide": 			{"name":"rawhide_vambraces", 		"type": "vambrace", "cost": [15,30],		"size": 1, 		"item": ["equip_to.vambrace", "counter.integrity.8"	],		"effects": ["skill.acrobatics.-3",	"skill.dodge.-3",		"skill.stealth.-3",		"armor.vambrace.1"]}, 
					"studded": 			{"name":"studded_vambraces", 		"type": "vambrace", "cost": [20,40],		"size": 1, 		"item": ["equip_to.vambrace", "counter.integrity.10"],		"effects": ["skill.acrobatics.-3",	"skill.dodge.-3",		"skill.stealth.-3",		"armor.vambrace.1"]}, 
					"laminar": 			{"name":"laminar_vambraces", 		"type": "vambrace", "cost": [25,50],		"size": 1, 		"item": ["equip_to.vambrace", "counter.integrity.6"	],		"effects": ["skill.acrobatics.-4",	"skill.dodge.-4",		"skill.stealth.-4",		"armor.vambrace.2"]}, 
					"leather": 			{"name":"leather_vambraces", 		"type": "vambrace", "cost": [30,60],		"size": 1, 		"item": ["equip_to.vambrace", "counter.integrity.8"	],		"effects": ["skill.acrobatics.-5",	"skill.dodge.-5",		"skill.stealth.-5",		"armor.vambrace.2"]}, 
					"mail": 			{"name":"mail_vambraces", 			"type": "vambrace", "cost": [35,70],		"size": 1, 		"item": ["equip_to.vambrace", "counter.integrity.10"],		"effects": ["skill.acrobatics.-5",	"skill.dodge.-5",		"skill.stealth.-5",		"armor.vambrace.2"]}, 
					"scale": 			{"name":"scale_vambraces", 			"type": "vambrace", "cost": [40,80],		"size": 1, 		"item": ["equip_to.vambrace", "counter.integrity.8"	],		"effects": ["skill.acrobatics.-8",	"skill.dodge.-8",		"skill.stealth.-8",		"armor.vambrace.3"]}, 
					"brigandine": 		{"name":"brigandine_vambraces",		"type": "vambrace", "cost": [45,90],		"size": 1, 		"item": ["equip_to.vambrace", "counter.integrity.10"],		"effects": ["skill.acrobatics.-9",	"skill.dodge.-9",		"skill.stealth.-9",		"armor.vambrace.3"]}, 
					"plate": 			{"name":"plate_vambraces", 			"type": "vambrace", "cost": [50,100],		"size": 1, 		"item": ["equip_to.vambrace", "counter.integrity.12"],		"effects": ["skill.acrobatics.-10", "skill.dodge.-10",	"skill.stealth.-10",	"armor.vambrace.3"]},
				},	
				"greave": {	
					"cloth": 			{"name":"cloth_greaves", 			"type": "greave", 	"cost": [10,20],		"size": 1, 		"item": ["equip_to.greave", "counter.integrity.6"	],			"effects": ["skill.acrobatics.-2",	"skill.dodge.-2",		"skill.stealth.-2",	 "armor.greave.1"]},
					"rawhide": 			{"name":"rawhide_greaves", 			"type": "greave", 	"cost": [15,30],		"size": 1, 		"item": ["equip_to.greave", "counter.integrity.8"	],			"effects": ["skill.acrobatics.-3",	"skill.dodge.-3",		"skill.stealth.-3",	 "armor.greave.1"]}, 
					"studded": 			{"name":"studded_greaves", 			"type": "greave", 	"cost": [20,40],		"size": 1, 		"item": ["equip_to.greave", "counter.integrity.10"],			"effects": ["skill.acrobatics.-4",	"skill.dodge.-4",		"skill.stealth.-4",	 "armor.greave.1"]}, 
					"laminar": 			{"name":"laminar_greaves", 			"type": "greave", 	"cost": [25,50],		"size": 1, 		"item": ["equip_to.greave", "counter.integrity.6"	],			"effects": ["skill.acrobatics.-4",	"skill.dodge.-4",		"skill.stealth.-4",	 "armor.greave.2"]}, 
					"leather": 			{"name":"leather_greaves", 			"type": "greave", 	"cost": [30,60],		"size": 1, 		"item": ["equip_to.greave", "counter.integrity.8"	],			"effects": ["skill.acrobatics.-5",	"skill.dodge.-5",		"skill.stealth.-5",	 "armor.greave.2"]}, 
					"mail": 			{"name":"mail_greaves", 			"type": "greave", 	"cost": [35,70],		"size": 1, 		"item": ["equip_to.greave", "counter.integrity.10"],			"effects": ["skill.acrobatics.-6",	"skill.dodge.-6",		"skill.stealth.-6",	 "armor.greave.2"]}, 
					"scale": 			{"name":"scale_greaves", 			"type": "greave", 	"cost": [40,80],		"size": 1, 		"item": ["equip_to.greave", "counter.integrity.8"	],			"effects": ["skill.acrobatics.-8",	"skill.dodge.-8",		"skill.stealth.-8",	 "armor.greave.3"]}, 
					"brigandine": 		{"name":"brigandine_greaves", 		"type": "greave", 	"cost": [45,90],		"size": 1, 		"item": ["equip_to.greave", "counter.integrity.10"],			"effects": ["skill.acrobatics.-9",	"skill.dodge.-9",		"skill.stealth.-9",	 "armor.greave.3"]}, 
					"plate": 			{"name":"plate_greaves", 			"type": "greave", 	"cost": [50,100],		"size": 1, 		"item": ["equip_to.greave", "counter.integrity.12"],			"effects": ["skill.acrobatics.-10", "skill.dodge.-10",	"skill.stealth.-10", "armor.greave.3"]},
				},
				"shield": {	
					"target": 			{"name":"target_shield", 			"type": "shield", 	"cost": [10,20],		"size": 1,		"item": ["equip_to.off_hand", "counter.integrity.8"],			"effects": ["combat.parry.+",	"combat.parry.5"]},
					"normal": 			{"name":"normal_shield",			"type": "shield", 	"cost": [20,40], 		"size": 1,		"item": ["equip_to.off_hand", "counter.integrity.8"],			"effects": ["combat.parry.+",	"combat.parry.10"]},
					"full": 			{"name":"full_shield", 	 			"type": "shield", 	"cost": [30,60], 		"size": 1,		"item": ["equip_to.off_hand", "counter.integrity.8"],			"effects": ["combat.parry.+",	"combat.parry.15"]},
					"wall": 			{"name":"wall_shield", 	 			"type": "shield", 	"cost": [50,100],		"size": 2,		"item": ["equip_to.off_hand", "counter.integrity.8"],			"effects": ["combat.parry.+",	"combat.parry.20"]},
				},
				"common": {	
					"backpack": 		{"name": "backpack",				"type": "backpack",		"cost": [250,500],		"size": 1,		"item": ["equip_to.backpack",	],									"effects": ["traverse.inventory.20"]},
					"belt": 			{"name": "belt", 					"type": "belt",			"cost": [500,1000],		"size": 1,		"item": ["equip_to.belt",		],									"effects": ["traverse.inventory.5"]},
					"boots": 			{"name": "boots", 					"type": "boots",		"cost": [25,50],		"size": 1,		"item": ["equip_to.boots",		],									"effects": []},
					"gloves":			{"name": "gloves", 					"type": "gloves",		"cost": [25,50],		"size": 1,		"item": ["equip_to.gloves",		],									"effects": []},
					"circlet":			{"name": "circlet",					"type": "helmet",		"cost": [100,200], 		"size": 1,		"item": ["equip_to.helmet",		],									"effects": []},
					"pouch":			{"name": "pouch", 					"type": "pouch",		"cost": [50,100],		"size": 1,		"item": ["equip_to.pouch",		],									"effects": ["traverse.inventory.5"]},
					"ring": 			{"name": "ring", 					"type": "ring",			"cost": [50,100],		"size": 0,		"item": ["equip_to.ring",			],								"effects": []},
					"bedroll": 			{"name": "backpack",				"type": "gear",			"cost": [100,200],		"size": 2,		"item": ["inventory.passive",	],									"effects": ["camp.check.1"]},
					"crow_bar":			{"name": "crow_bar", 				"type": "gear",			"cost": [25,50],		"size": 1,		"item": ["inventory.passive",	],									"effects": ["traverse.break.10"]},
					"toolkit":			{"name": "toolkit",					"type": "gear",			"cost": [5,10],			"size": 0,		"item": ["inventory.passive",	],									"effects": ["actions.disarm", "traverse.disarm.5"]},
					"belt_lamp":		{"name": "belt_lamp", 				"type": "light",		"cost": [750,1500],		"size": 1,		"item": ["equip_to.belt_slot","counter.use.20"],					"effects": ["light_source"]},
					"lamp": 			{"name": "lamp", 					"type": "light",		"cost": [100,200],		"size": 1,		"item": ["equip_to.off_hand",	"counter.use.20"],					"effects": ["light_source"]},			
					"torch": 			{"name": "torch", 					"type": "light_use",	"cost": [5,10],			"size": 1,		"item": ["equip_to.off_hand",	"counter.use.20"],					"effects": ["light_source"]},			
					"candle": 			{"name": "candle", 					"type": "light_use",	"cost": [5,10],			"size": 1,		"item": ["equip_to.off_hand",	"counter.use.10"],					"effects": ["light_source"]},
					"flare": 			{"name": "flare", 					"type": "light_use",	"cost": [10,20],		"size": 1,		"item": ["equip_to.off_hand",	"counter.use.1"],					"effects": ["light_source"]},		
				},
				"supplies": {
					"bandage": 			{"name": "bandage", 				"type": "supplies", 	"cost": [5,10], 		"size": 0},
					"cooking":			{"name": "cooking", 				"type": "supplies", 	"cost": [3,5], 			"size": 0},
					"crafting":			{"name": "crafting",				"type": "supplies", 	"cost": [3,5], 			"size": 0},
					"crystal":			{"name": "crystal", 				"type": "supplies", 	"cost": [25,50],		"size": 0},
					"lockpick":			{"name": "lockpick",				"type": "supplies", 	"cost": [3,5],			"size": 0},
					"oil":				{"name": "oil",						"type": "supplies", 	"cost": [3,5],			"size": 0},
					"ration":			{"name": "ration",					"type": "supplies", 	"cost": [3,5],			"size": 0},
					"ritual":			{"name": "ritual",					"type": "supplies", 	"cost": [5,10],			"size": 0},
				},
				"potion": {
					"aether": 			{"name": "aether",					"type":"potion", 		"cost": [25,50], 		"size": 0, 	"item": "consume.potion",	"effects": ["dice.roll_aging", "aether_potion", "counter.1"]},
					"antidote": 		{"name": "antidote",				"type":"potion", 		"cost": [25,50], 		"size": 0, 	"effects": ["dice.roll_aging", "antidote_potion", "counter.1"]},
					"coagulant": 		{"name": "coagulant",				"type":"potion", 		"cost": [25,50], 		"size": 0, 	"effects": ["dice.roll_aging", "coagulant_potion", "counter.1"]},
					"courage":			{"name": "courage",					"type":"potion", 		"cost": [25,50], 		"size": 0, 	"effects": ["dice.roll_aging", "courage_potion", "counter.1"]},
					"flaming":			{"name": "flaming",					"type":"potion", 		"cost": [25,50], 		"size": 0, 	"effects": ["dice.roll_aging", "flaming_potion", "counter.1"]},
					"frenzy":			{"name": "frenzy",					"type":"potion", 		"cost": [25,50], 		"size": 0, 	"effects": ["dice.roll_aging", "frenzy_potion", "counter.1"]},
					"health":			{"name": "health",					"type":"potion", 		"cost": [25,50], 		"size": 0, 	"effects": ["dice.roll_aging", "health_potion", "counter.1"]},
					"regeneration":		{"name": "regeneration",			"type":"potion", 		"cost": [25,50], 		"size": 0, 	"effects": ["dice.roll_aging", "regeneration_potion", "counter.1"]},
					"poison":			{"name": "poison",					"type":"potion", 		"cost": [25,50], 		"size": 0, 	"effects": ["dice.roll_aging", "poison_potion", "counter.1"]},
					"cleanse":			{"name": "cleanse",					"type":"potion", 		"cost": [25,50], 		"size": 0, 	"effects": ["dice.roll_aging", "cleanse_potion", "counter.1"]},
					"vigor":			{"name": "vigor",					"type":"potion", 		"cost": [25,50], 		"size": 0, 	"effects": ["dice.roll_aging", "vigor_potion", "counter.1"]},
					"satiation":		{"name": "satiation",				"type":"potion", 		"cost": [25,50], 		"size": 0, 	"effects": ["dice.roll_aging", "satiation_potion", "counter.1"]},
					"calmness":			{"name": "calmness",				"type":"potion", 		"cost": [25,50], 		"size": 0, 	"effects": ["dice.roll_aging", "calmness_potion", "counter.1"]},
					"haste":			{"name": "haste",					"type":"potion", 		"cost": [25,50], 		"size": 0, 	"effects": ["dice.roll_aging", "haste_potion", "counter.1"]},
					"stoneskin":		{"name": "stoneskin",				"type":"potion", 		"cost": [25,50], 		"size": 0, 	"effects": ["dice.roll_aging", "stoneskin_potion", "counter.1"]},
					"strength":			{"name": "strength",				"type":"potion", 		"cost": [25,50], 		"size": 0, 	"effects": ["dice.roll_aging", "strength_potion", "counter.1"]},
					"vitality":			{"name": "vitality",				"type":"potion", 		"cost": [25,50], 		"size": 0, 	"effects": ["dice.roll_aging", "vitality_potion", "counter.1"]},
				},
				"fragment": {
					"ritual_dagger": 							{"name":"ritual_dagger",						"type": "fragment",		"cost": [750,750],		"size": 0,	"effects": ["ritual_dagger.action", "counter.1"]},
					"tattered_cloak": 							{"name":"tattered_cloak",						"type": "fragment",		"cost": [750,750],		"size": 0,	"effects": ["tattered_cloak.action", "counter.1"]},
					"refracting_mirror": 						{"name":"refracting_mirror",					"type": "fragment",		"cost": [750,750],		"size": 0,	"effects": ["refracting_mirror.action", "counter.1"]},
					"grounding_chain": 							{"name":"grounding_chain",						"type": "fragment",		"cost": [750,750],		"size": 0,	"effects": ["grounding_chain.action", "counter.1"]},
					"black_heart_babble": 						{"name":"black_heart_babble",					"type": "fragment",		"cost": [750,750],		"size": 0,	"effects": ["black_heart_babble.action", "counter.1"]},
					"cracked_monocle": 							{"name":"cracked_monocle",						"type": "fragment",		"cost": [750,750],		"size": 0,	"effects": ["cracked_monocle.action", "counter.1"]},
					"green_vial":								{"name":"green_vial",							"type": "fragment",		"cost": [750,750],		"size": 0,	"effects": ["green_vial.action", "counter.1"]},
					"enchanted_skull":							{"name":"enchanted_skull",						"type": "fragment",		"cost": [750,750],		"size": 0,	"effects": ["enchanted_skull.action", "counter.1"]},
					"cursed_bandages":							{"name":"cursed_bandages",						"type": "fragment",		"cost": [750,750],		"size": 0,	"effects": ["cursed_bandages.action", "counter.1"]},
					"blood_potion":								{"name":"blood_potion",							"type": "fragment",		"cost": [750,750],		"size": 0,	"effects": ["blood_potion.action", "counter.1"]},
					"ravens_trinket":							{"name":"ravens_trinket",						"type": "fragment",		"cost": [750,750],		"size": 0,	"effects": ["ravens_trinket.action", "counter.1"]},
					"spiked_gauntlets":							{"name":"spiked_gauntlets",						"type": "fragment",		"cost": [750,750],		"size": 0,	"effects": ["spiked_gauntlets.action", "counter.1"]},
					"black_vial":								{"name":"black_vial",							"type": "fragment",		"cost": [750,750],		"size": 0,	"effects": ["black_vial.action", "counter.1"]},
					"spider_locket":							{"name":"spider_locket",						"type": "fragment",		"cost": [750,750],		"size": 0,	"effects": ["spider_locket.action", "counter.1"]},
					"obsidian_whistle":							{"name":"obsidian_whistle",						"type": "fragment",		"cost": [750,750],		"size": 0,	"effects": ["obsidian_whistle.action", "counter.1"]},
					"miasma_flask":								{"name":"miasma_flask",							"type": "fragment",		"cost": [750,750],		"size": 0,	"effects": ["miasma_flask.action", "counter.1"]},
					"broken_harp":								{"name":"broken_harp",							"type": "fragment",		"cost": [750,750],		"size": 0,	"effects": ["broken_harp.action", "counter.1"]},
					"ancient_grimoire":							{"name":"ancient_grimoire",						"type": "fragment",		"cost": [750,750],		"size": 0,	"effects": ["ancient_grimoire.action", "counter.1"]},
					"amethyst_ring":							{"name":"amethyst_ring",						"type": "fragment",		"cost": [750,750],		"size": 0,	"effects": ["amethyst_ring.action", "counter.1"]},
					"frozen_hourglass":							{"name":"frozen_hourglass",						"type": "fragment",		"cost": [750,750],		"size": 0,	"effects": ["frozen_hourglass.action", "counter.1"]},
				},
				"relic": {
					"eternal_sentinel_aegis": 					{"name":"eternal_sentinel_aegis", 	 			"type": "armor", 			"cost": [1000,1000],	"size": 2,	"effects":["combat.parry.20", "ignore_damage.action"]},
					"band_of_knowledge": 						{"name":"band_of_knowledge", 					"type": "ring", 			"cost": [1000,1000],	"size": 1,	"effects":["camp_boost_skill.action.50"]},
					"diadem_of_aetheric_power":					{"name":"diadem_of_aetheric_power",				"type": "helmet",			"cost": [1000,1000],	"size": 1,	"effects":["aether.max.10", "spells.extra_die.6"]},
					"draught_of_vitality":						{"name":"draught_of_vitality",					"type": "potion",			"cost": [1000,1000],	"size": 1,	"effects":["health.max.roll.4"]},
					"echo_of_resurgence":						{"name":"echo_of_resurgence",					"type": "trinket",			"cost": [1000,1000],	"size": 1,	"effects":["resurrect"]},
					"elixir_of_ascendence":						{"name":"elixir_of_ascendence",					"type": "potion",			"cost": [1000,1000],	"size": 1,	"effects":["aether.max.roll.4"]},
					"ethereal_requiem_blade":					{"name":"ethereal_requiem_blade",				"type": "weapon",			"cost": [1000,1000],	"size": 1,	"effects":[""]},
					"gloomheart_seed":							{"name":"gloomheart_seed",						"type": "usable",			"cost": [1000,1000],	"size": 1,	"effects":[""]},
					"blazing_phoenix_gloves":					{"name":"blazing_phoenix_gloves",				"type": "gloves",			"cost": [1000,1000],	"size": 1,	"effects":[""]},
					"inferno_plate":							{"name":"inferno_plate",						"type": "torso",			"cost": [1000,1000],	"size": 1,	"effects":[""]},
					"eclipse_mace":								{"name":"eclipse_mace",							"type": "weapon",			"cost": [1000,1000],	"size": 1,	"effects":[""]},
					"mindward_elixir":							{"name":"mindward_elixir",						"type": "potion",			"cost": [1000,1000],	"size": 1,	"effects":[""]},
					"rebirth_potion":							{"name":"rebirth_potion",						"type": "potion",			"cost": [1000,1000],	"size": 1,	"effects":[""]},
					"arcane_tempest_ring":						{"name":"arcane_tempest_ring",					"type": "ring",				"cost": [1000,1000],	"size": 1,	"effects":[""]},
					"ethereal_grasp_ring":						{"name":"ethereal_grasp_ring",					"type": "ring",				"cost": [1000,1000],	"size": 1,	"effects":[""]},
					"ring_of_servitude":						{"name":"ring_of_servitude",					"type": "ring",				"cost": [1000,1000],	"size": 1,	"effects":[""]},
					"third_eye_of_emaricus":					{"name":"third_eye_of_emaricus",				"type": "trinket",			"cost": [1000,1000],	"size": 1,	"effects":[""]},
					"vitalbane_cinch":							{"name":"vitalbane_cinch",						"type": "belt",				"cost": [1000,1000],	"size": 1,	"effects":[""]},
					"voidclasp_gauntlets":						{"name":"voidclasp_gauntlets",					"type": "gloves",			"cost": [1000,1000],	"size": 1,	"effects":[""]},
					"wyrmfang":									{"name":"wyrmfang",								"type": "weapon",			"cost": [1000,1000],	"size": 1,	"effects":[""]},
				},
			},
			"criticals": {
				"character_party": {
					"acrobatics": {
						"success": [{"name": "Daring Maneuver", "desc": "The character performs a daring acrobatic maneuver. They gain a +30 bonus to their next action due to the momentum and adrenaline rush from the successful maneuver. This bonus lasts for one round.", "rule": ["test", ["__0__"]]}],
						"failure": [{"name": "Catastrophic Tumble", "desc": "The character loses control during an acrobatic attempt and suffers a severe fall, taking D10+1 Bludgeoning damage from the fall. Additionally, they are considered Prone.", "rule": null}]
					},
					"athletics": {
						"success": [{"name": "Herculean Feat", "desc": "The character performs an incredible display of physical prowess, exceeding all expectations. Their next successful attack deals double damage, or the next door/container they encounter is smashed open automatically (whichever happens first).", "rule": null}],
						"failure": [{"name": "Overexertion", "desc": "The character pushes themselves too hard during an athletic endeavor, resulting in a mishap. They have Disadvantage in their next Athletics check due to fatigue.", "rule": null}]
					},
					"dodge": {
						"success": [{"name": "Elusive Maneuver", "desc": "The character displays exceptional agility and awareness, narrowly avoiding an attack. They gain a +20 bonus to their Dodge skill for the next round.", "rule": null}],
						"failure": [{"name": "Clumsy Misstep", "desc": "The character loses their footing or makes a critical error in judgment, making them an easier target. They receive double damage from the source they're trying to avoid.", "rule": null}]
					},
					"endurance": {
						"success": [{"name": "Unwavering Resilience", "desc": "The character demonstrates exceptional fortitude and resilience in the face of hardship. They recover 1 Health and are Resistant to Poison damage for the next 5 rooms.", "rule": null}],
						"failure": [{"name": "Overwhelmed by Strain", "desc": "The character succumbs to the physical stress of the situation, suffering a temporary setback. They have Disadvantage on the next Athletics and Acrobatics checks.", "rule": null}]
					},
					"initiative": {
						"success": [{"name": "Snap Reaction", "desc": "You act at lighting speed, allowing you to take advantage of your opponent. Perform your first attack with Advantage.", "rule": null}],
						"failure": [{"name": "Taken by Surprise", "desc": "You are unaware of your surroundings and lose your first turn as a result.", "rule": null}]
					},
					"magic_resist": {
						"success": [{"name": "Unbreakable Will", "desc": "The character demonstrates exceptional resistance to magical influence, defying the effects of the spell or magical attack. They become Resistant to the spell's damage for the next D4+1 rounds.", "rule": null}],
						"failure": [{"name": "Magical Vulnerability", "desc": "The character succumbs to the full force of the magical influence, experiencing the worst possible outcome of the spell or attack. They receive double damage from the spell, or its consequences last twice as long.", "rule": null}]
					},
					"medicine": {
						"success": [{"name": "Miraculous Recovery", "desc": "The character demonstrates exceptional medical skill and knowledge, achieving an improbable outcome. They recover D10 Toughness.", "rule": null}],
						"failure": [{"name": "Harmful Treatment", "desc": "The character makes a critical error in diagnosis or treatment, potentially worsening the patient's condition. They suffer 2D6 damage.", "rule": null}],
					},
					"perception": {
						"success": [{"name": "Heightened Awareness", "desc": "The character notices hidden details or gains exceptional situational awareness. They gain Advantage on their next Perception check.", "rule": null}],
						"failure": [{"name": "Blind Spot", "desc": "The character completely misses a crucial detail or misinterprets a situation. They have Disadvantage on their next Perception check.", "rule": null}]
					},
					"resolve": {
						"success": [{"name": "Unwavering Will", "desc": "The character displays exceptional mental fortitude and resilience, resisting the pressures of the situation. They recover D4+1 Sanity.", "rule": null}],
						"failure": [{"name": "Mental Lapse", "desc": "The character succumbs to the mental pressure of the situation, making them vulnerable to further influence or manipulation. They lose D4 Sanity.", "rule": null}]
					},
					"reason": {
						"success": [{"name": "Brilliant Deduction", "desc": "The character demonstrates exceptional logic and critical thinking, making a breakthrough in their understanding. They immediately identify a magic item in their possession, without spending an Attunement Crystal.", "rule": null}],
						"failure": [{"name": "Mental Block", "desc": "The character suffers a temporary lapse in logic or reasoning, hindering their ability to think clearly. They have Disadvantage on their next Reason check.", "rule": null}]
					},
					"stealth": {
						"success": [{"name": "Ghost in the Shadows", "desc": "The character moves with exceptional stealth, becoming nearly invisible to anyone in the vicinity. If they perform an attack in the next round, it strikes automatically.", "rule": null}],
						"failure": [{"name": "Flimsy Footing", "desc": "The character makes a critical error in their movement or actions, alerting their pursuers. They have Disadvantage on any action they perform in the next round, due to being surprised.", "rule": null}]
					},
					"thievery": {
						"success": [{"name": "Masterful Thief", "desc": "The character executes their thieving act with exceptional skill and precision, exceeding expectations. They receive Advantage on their next Thievery check.", "rule": null}],
						"failure": [{"name": "Bungled Attempt", "desc": "The character makes a critical error during their thieving attempt, leading to complications. They accidentally have triggered a trap they had somehow missed. Roll on the Traps table.", "rule": null}]
					},
					"combat": {
						"success": [],
						"failure": [
							{"name": "Drop Weapon", "desc": "You drop your weapon and must spend your next turn recovering it. If you are not wielding a weapon, your next attack suffers -20.", "rule": null},
							{"name": "Embedded Weapon", "desc": "You hurl your weapon with such strength that it gets stuck very deep in a wall or ground. As a Standard Action, you must perform a successful Athletics check to retrieve it. If you are not wielding a weapon, your next attack suffers -20.", "rule": null},
							{"name": "Shatter Weapon", "desc": "You hurl your weapon with such strength that it smashes against a stone, breaking in half. You must repair it before you can wield it again. If you are not wielding a weapon, your next attack suffers -20.", "rule": null},
							{"name": "Crush Belt", "desc": "A random item from your belt breaks: make a belt check. If you don't have a belt, you receive 1 direct damage.", "rule": null},
							{"name": "Aether Sickness", "desc": "You are suddenly feeling drained and lose D8 Aether. If you don't have any Aether, you receive 1 direct damage.", "rule": null},
							{"name": "Trip", "desc": "You trip and fall, wasting this action. You are Prone and must use a Standard Action to get back up next round.", "rule": null},
							{"name": "Miscalculated Attack", "desc": "In the process of executing your attack you trip and slam your head. You are Dazed for 2 rounds.", "rule": null},
							{"name": "Friendly Fire", "desc": "Your attack hits a random ally instead of the intended target. If there are no allies, you strike yourself.", "rule": null},
							{"name": "Stop Hitting Yourself", "desc": "You manage to strike yourself with a normal attack.", "rule": null},
							{"name": "Self Own", "desc": "You somehow manage to hurt yourself badly with your own weapon. You receive a critical hit.", "rule": null},
						]
					}
				},
				"enemy_party": {
					"combat": {
						"success": [],
						"failure": [
							{"name": "Weakened Front", "desc": "The creature's next attack suffers -20, If it's a magical action, the PC receives +20 to its Magic Resistance.", "rule": null},
							{"name": "Incompetent Swing", "desc": "The creature becomes confused by their own inability to strike the PC, becoming Stunned for the next round.", "rule": null},
							{"name": "Entangled", "desc": "The creature is Entangled for the next D4 rounds due to some vegetation or refuse in its vicinity.", "rule": null},
							{"name": "Fixed Pattern", "desc": "The creature exposes a weakness in its attack pattern, granting the PC Advantage on their defensive rolls for the next 2 rounds.", "rule": null},
							{"name": "Floor Sand", "desc": "The attack creates a huge cloud of lifted dust, causing the PC to be Concealed for D4 rounds.", "rule": null},
							{"name": "Help I've Fallen", "desc": "The creature trips and falls, wasting their action. It is Prone and must use its next turn to get back up.", "rule": null},
							{"name": "Discombobulated", "desc": "In the process of executing its attack, the creature trips and slams its head. It is Stunned for 2 rounds.", "rule": null},
							{"name": "Spooked", "desc": "The creature becomes Frightened for D4 rounds. They can attempt a Magic Resistance check at the start of each of its turn to remove the condition.", "rule": null},
							{"name": "Stop Hitting Yourself", "desc": "The creature manages to strike itself, receiving D8 Slashing damage.", "rule": null},
							{"name": "Trip", "desc": "The creature falls in an awkward position, becoming Prone and receiving 2D6 Bludgeoning damage. It must use its next turn to get back up.", "rule": null}
						]
					}
				}
			},
			"defensive_maneuvers": [
				{ "desc": "Their next attack receives an additional +10", "rule": null },
				{ "desc": "Reduce their opponent's Armor by 1 in one random location until the end of combat", "rule": null },
				{ "desc": "Their opponent receives the Bleeding (1) condition", "rule": null },
				{ "desc": "If they were Prone, Paralyzed, Stunned, or some other similar condition, they automatically recover. Otherwise, their next attack receives an additional +10", "rule": null },
				{ "desc": "Their opponent immediately suffers D4 damage that ignores armor", "rule": null },
				{ "desc": "Their next attack deals +D10 damage", "rule": null },
				{ "desc": "They gain Advantage on their next attack", "rule": null },
				{ "desc": "They press their advantage, reducing their opponent's next defensive roll by -20", "rule": null },
				{ "desc": "They get a moment of respite after fending off their opponent's attack. Recover 2 Toughness (2 Health in case of NPCs and opponents)", "rule": null },
				{ "desc": "Their next attack doesn't suffer the usual -30 modifier to their attack skill when targeting a specific body part.", "rule": null },
			],
			"masteries":{
				"abyssal_reaver":						{	"name": "abyssal_reaver",					"desc": null, 	"level": {"base": 0, "max": 5, "total": 0	},	"effects":["actions.abyssal_reaver.passive", "actions.abyssal_reaver.infernal_flame", "actions.abyssal_reaver.hellish_weapon", "actions.abyssal_reaver.demonic_pact", "actions.abyssal_reaver.demon_shroud", "actions.abyssal_reaver.soul_harvest"]},
				"arcanist":								{	"name": "arcanist",							"desc": null, 	"level": {"base": 0, "max": 5, "total": 0	},	"effects":["actions.arcanist.passive", "actions.arcanist.arcane_missiles", "actions.arcanist.arcane_shield", "actions.arcanist.create_light", "actions.arcanist.arcane_companion", "actions.arcanist.arcane_bolt"]},
				"brawler":								{	"name": "brawler",							"desc": null, 	"level": {"base": 0, "max": 5, "total": 0	},	"effects":["actions.brawler.passive", "actions.brawler.feint", "actions.brawler.uppercut", "actions.brawler.overwhelm", "actions.brawler.kidney_shot", "actions.brawler.perfect_blocking"]},
				"bulwark":								{	"name": "bulwark",							"desc": null, 	"level": {"base": 0, "max": 5, "total": 0	},	"effects":["actions.bulwark.passive", "actions.bulwark.brace", "actions.bulwark.shield_bash", "actions.bulwark.sword_&_board", "actions.bulwark.battle_form", "actions.bulwark.bastion"]},
				"duskblade":							{	"name": "duskblade",						"desc": null, 	"level": {"base": 0, "max": 5, "total": 0	},	"effects":["actions.duskblade.passive", "actions.duskblade.poisoned_blade", "actions.duskblade.weaken", "actions.duskblade.sap", "actions.duskblade.ruthless_strike", "actions.duskblade.invisibility"]},
				"emissary":								{	"name": "emissary",							"desc": null, 	"level": {"base": 0, "max": 5, "total": 0	},	"effects":["actions.emissary.passive", "actions.emissary.heal_wounds", "actions.emissary.unbreakable_faith", "actions.emissary.remove_condition", "actions.emissary.divine_justice", "actions.emissary.holy_flames"]},
				"flamecaster":							null,
				"frostcaster":							null,
				"gravecaller":							null,
				"hexmancer":							null,
				"icon_caller":							null,
				"mindbinder":							null,
				"ritualist":							null,
				"stormbrand":							null,
				"tracker":								null,
				"umber_phantom":						null,
				"weapon_master":						null,
				"wraith":								null,
				"wraith_spawn":							null,
				"zealot":								null,
			},
			"goals": {
				"acid_damage_expert":					{	"name": "acid_damage_expert",			"tally": { "event": "",	"at": 0, "goal": 200	},	"rule": "reduction.acid",						"goal":"Deal 200 Acid damage",																								"reward":"Gain 1 Acid damage reduction"}, 
				"air_damage_expert":					{	"name": "air_damage_expert",			"tally": { "event": "",	"at": 0, "goal": 200	},	"rule": "reduction.air",						"goal":"Deal 200 Air damage",																									"reward":"Gain 1 Air damage reduction"}, 
				"annihilator":							{	"name": "annihilator",					"tally": { "event": "",	"at": 0, "goal": 1000	},	"rule": null,												"goal":"Defeat 1,000 opponents",																							"reward":"+D4 Psychic damage to all attacks"}, 
				"arcane_damage_expert":					{	"name": "arcane_damage_expert",			"tally": { "event": "",	"at": 0, "goal": 200	},	"rule": "reduction.arcane",					"goal":"Deal 200 Arcane damage",																							"reward":"Gain 1 Arcane damage reduction"}, 
				"astral_bane":							{	"name": "astral_bane",					"tally": { "event": "",	"at": 0, "goal": 100	},	"rule": null,												"goal":"Defeat 100 Astral opponents",																					"reward":"Triple the damage dealt with a critical hit against Astral opponents"}, 
				"beast_hunter":							{	"name": "beast_hunter",					"tally": { "event": "",	"at": 0, "goal": 100	},	"rule": null,												"goal":"Defeat 100 Animal opponents",																					"reward":"Triple the damage dealt with a critical hit against Animal opponents"}, 
				"bladed_weapon_master":					{	"name": "bladed_weapon_master",			"tally": { "event": "",	"at": 0, "goal": 50		},	"rule": null,												"goal":"Defeat 50 opponents with the Bladed Weapons skill",										"reward":"+1 damage while wielding a bladed weapon"}, 
				"bludgeoning_damage_expert":			{	"name": "bludgeoning_damage_expert",	"tally": { "event": "",	"at": 0, "goal": 200	},	"rule": "reduction.bludgeoning",		"goal":"Deal 200 Bludgeoning damage",																					"reward":"Gain 1 Bludgeoning damage reduction"}, 
				"bludgeoning_weapon_master":			{	"name": "bludgeoning_weapon_master",	"tally": { "event": "",	"at": 0, "goal": 50		},	"rule": null,												"goal":"Defeat 50 opponents with the Bludgeoning Weapons skill",							"reward":"+1 damage while wielding a bludgeoning weapon"}, 
				"botanical_exterminator":				{	"name": "botanical_exterminator",		"tally": { "event": "",	"at": 0, "goal": 100	},	"rule": null,												"goal":"Defeat 100 Plant opponents",																					"reward":"Triple the damage dealt with a critical hit against Plant opponents"}, 
				"brawler":								{	"name": "brawler",						"tally": { "event": "",	"at": 0, "goal": 50		},	"rule": null,												"goal":"Defeat 50 opponents with the Unarmed Combat & Fist Weapons skill",		"reward":"+1 damage while wielding a fist weapon or completely unarmed"}, 
				"cold_damage_expert":					{	"name": "cold_damage_expert",			"tally": { "event": "",	"at": 0, "goal": 200	},	"rule": null,												"goal":"Deal 200 Cold damage",																								"reward":"Gain 1 Cold damage reduction"}, 
				"decapitate_the_leadership":			{	"name": "decapitate_the_leadership",	"tally": { "event": "",	"at": 0, "goal": 20		},	"rule": null,												"goal":"Defeat 20 Overseers",																									"reward":"When facing an Overseer, they are Stunned during the first combat round"}, 
				"demon_bane":							{	"name": "demon_bane",					"tally": { "event": "",	"at": 0, "goal": 100	},	"rule": null,												"goal":"Defeat 100 Demon opponents",																					"reward":"Triple the damage dealt with a critical hit against Demon opponents"}, 
				"earth_damage_expert":					{	"name": "earth_damage_expert",			"tally": { "event": "",	"at": 0, "goal": 200	},	"rule": null,												"goal":"Deal 200 Earth damage",																								"reward":"Gain 1 Earth damage reduction"}, 
				"elemental_vanquisher":					{	"name": "elemental_vanquisher",			"tally": { "event": "",	"at": 0, "goal": 100	},	"rule": null,												"goal":"Defeat 100 Elemental opponents",																			"reward":"Triple the damage dealt with a critical hit against Elemental opponents"}, 
				"fire_damage_expert":					{	"name": "fire_damage_expert",			"tally": { "event": "",	"at": 0, "goal": 200	},	"rule": null,												"goal":"Deal 200 Fire damage",																								"reward":"Gain 1 Fire damage reduction"}, 
				"hoarder":								{	"name": "hoarder",						"tally": { "event": "",	"at": 0, "goal": 10000	},	"rule": null,												"goal":"Obtain 10,000. (You do not need to hold this amount all at once)",		"reward":"Traders will buy up to 5 items from you at full price"}, 
				"holy_damage_expert":					{	"name": "holy_damage_expert",			"tally": { "event": "",	"at": 0, "goal": 200	},	"rule": null,												"goal":"Deal 200 Holy damage",																								"reward":"Gain 1 Holy damage reduction"}, 
				"infernal_damage_expert":				{	"name": "infernal_damage_expert",		"tally": { "event": "",	"at": 0, "goal": 200	},	"rule": null,												"goal":"Deal 200 Infernal damage",																						"reward":"Gain 1 Infernal damage reduction"}, 
				"living_shadow":						{	"name": "living_shadow",				"tally": { "event": "",	"at": 0, "goal": 50		},	"rule": null,												"goal":"Surprise 50 opponents",																								"reward":"You gain the Living Shadow Perk"}, 
				"marauder":								{	"name": "marauder",						"tally": { "event": "",	"at": 0, "goal": 100	},	"rule": null,												"goal":"Defeat 100 Humanoid opponents",																				"reward":"Triple the damage dealt with a critical hit against Humanoid opponents"}, 
				"master_thief":							{	"name": "master_thief",					"tally": { "event": "",	"at": 0, "goal": 100	},	"rule": null,												"goal":"Open 100 doors or containers with the help of your Thievery skill",		"reward":"You gain the Lucky Find Perk"}, 
				"necrotic_damage_expert":				{	"name": "necrotic_damage_expert",		"tally": { "event": "",	"at": 0, "goal": 200	},	"rule": null,												"goal":"Deal 200 Necrotic damage",																						"reward":"Gain 1 Necrotic damage reduction"}, 
				"overseer_overthrown":					{	"name": "overseer_overthrown",			"tally": { "event": "",	"at": 0, "goal": 1		},	"rule": null,												"goal":"Defeat an Overseer",																									"reward":"You obtain an Amulet"}, 
				"piercing_damage_expert":				{	"name": "piercing_damage_expert",		"tally": { "event": "",	"at": 0, "goal": 200	},	"rule": null,												"goal":"Deal 200 Piercing damage",																						"reward":"Gain 1 Piercing damage reduction"}, 
				"poison_damage_expert":					{	"name": "poison_damage_expert",			"tally": { "event": "",	"at": 0, "goal": 200	},	"rule": null,												"goal":"Deal 200 Poison damage",																							"reward":"Gain 1 Poison damage reduction"}, 
				"precision_striker":					{	"name": "precision_striker",			"tally": { "event": "",	"at": 0, "goal": 50		},	"rule": null,												"goal":"Deal 50 critical hits in combat",																			"reward":"You gain the Precision Striker Perk"}, 
				"psychic_damage_expert":				{	"name": "psychic_damage_expert",		"tally": { "event": "",	"at": 0, "goal": 200	},	"rule": null,												"goal":"Deal 200 Psychic damage",																							"reward":"Gain 1 Psychic damage reduction"}, 
				"relic_hunter":							{	"name": "relic_hunter",					"tally": { "event": "",	"at": 0, "goal": 1		},	"rule": null,												"goal":"Find a Relic",																												"reward":"100 XP"}, 
				"scavenger":							{	"name": "scavenger",					"tally": { "event": "",	"at": 0, "goal": 100	},	"rule": null,												"goal":"Successfully scavenge 100 rooms",																			"reward":"You gain the Scavenger Perk"}, 
				"scholar":								{	"name": "scholar",						"tally": { "event": "",	"at": 0, "goal": 100	},	"rule": null,												"goal":"Successfully use the Reason skill 100 times to solve Events",					"reward":"You gain the Scholar Perk"}, 
				"sentinel_smasher":						{	"name": "sentinel_smasher",				"tally": { "event": "",	"at": 0, "goal": 100	},	"rule": null,												"goal":"Defeat 100 Construct opponents",																			"reward":"Triple the damage dealt with a critical hit against Construct opponents"},
				"shafted_weapon_master":				{	"name": "shafted_weapon_master",		"tally": { "event": "",	"at": 0, "goal": 50		},	"rule": null,												"goal":"Defeat 50 opponents with the Shafted Weapons skill",									"reward":"+1 damage while wielding a shafted weapon"},
				"slashing_damage_expert":				{	"name": "slashing_damage_expert",		"tally": { "event": "",	"at": 0, "goal": 200	},	"rule": null,												"goal":"Deal 200 Slashing damage",																						"reward":"Gain 1 Slashing damage reduction"},
				"trap_buster":							{	"name": "trap_buster",					"tally": { "event": "",	"at": 0, "goal": 50		},	"rule": null,												"goal":"Successfully dismantle 50 traps",																			"reward":"You gain the Trap Buster Perk"},
				"thrill_seeker":						{	"name": "thrill_seeker",				"tally": { "event": "",	"at": 0, "goal": 20		},	"rule": null,												"goal":"Trigger 20 Growing Darkness events",																	"reward":"Each time you must roll on the Growing Darkness table, you can choose to roll a second time and choose the result you prefer"},
				"vaelorian_erudite":					{	"name": "vaelorian_erudite",			"tally": { "event": "",	"at": 0, "goal": 10		},	"rule": null,												"goal":"Loot 10 Lore Books",																									"reward":"Increase your goalimum Aether by D4"},
				"water_damage_expert":					{	"name": "water_damage_expert",			"tally": { "event": "",	"at": 0, "goal": 200	},	"rule": null,												"goal":"Deal 200 Water damage",																								"reward":"Gain 1 Water damage reduction"},
				"wraithstalker":						{	"name": "wraithstalker",				"tally": { "event": "",	"at": 0, "goal": 100	},	"rule": null,												"goal":"Defeat 100 Undead opponents",																					"reward":"Triple the damage dealt with a critical hit against Undead opponents"},
			},
			"influence": {
				"Tough": 		"Immune to critical hits", 
				"Vital": 		"+D4 Health/5L",
				"Frenzied": 	"+2 damage",
				"Skilled": 		"+10 Combat Skill",
				"Magebane": 	"+10 Magic Resistance",
				"Resistant": 	"Resistant to 1 random type of damage. Roll on the Damage Type table on page 206",
				"Corrupting":	"Each time the creature deals 3+ damage on a single attack, the target must make a Resolve check or lose 1 Sanity",
				"Unstable": 	"Deals D8 Arcane damage when killed",
				"Alert": 		"+20 Awareness",
				"Piercing": 	"Gains the Penetrating (1) Trait. This can stack with other instances of the same trait",
			},
			"crimes": {
				"Highway Robbery": 			"Armed individuals ambush travelers on highways, robbing them of their belongings and sometimes resorting to violence.",
				"Witchcraft": 				"Accusations of practicing witchcraft are common in Veldonia, and those accused often face trials and punishment, such as imprisonment or execution.",
				"Poaching": 				"People illegally hunt game on private land, often to supplement their diet or sell the animals for profit, disregarding the landowner's rights.",
				"Smuggling": 				"Illicit trade involving the import or export of goods without paying customs duties, usually through hidden routes to avoid detection.",
				"Piracy": 					"Seafaring individuals that attack ships, plundering their cargo and often resorting to violence against the crew. Pirates are a significant concern for Veldonia due to the importance of its maritime trade.",
				"Murder": 					"The intentional killing of another person, which could be motivated by various factors such as revenge, personal disputes, or criminal activities.",
				"Sedition": 				"Engaging in activities that undermine or seek to overthrow the established authority, such as inciting rebellion or spreading dissent.",
				"Treason": 					"Engaging in activities that betray or threaten the monarchy, such as plotting against the king.",
				"Counterfeiting": 			"Producing fake currency or counterfeit goods, which undermine the economy and defraud individuals.",
				"Housebreaking": 			"Breaking into homes to steal valuable items or money, often resulting in damage to property and sometimes violence against occupants.",
				"Vagrancy": 				"Being homeless and unemployed, wandering from place to place without a clear means of support.",
				"Dueling": 					"Engaging in private combat with deadly weapons to resolve personal disputes.",
				"Rioting": 					"Participating in violent public disturbances or protests, often with groups of people causing damage to property or attacking others.",
				"Blasphemy": 				"Uttering or promoting sacrilegious or disrespectful statements or actions against any of the sanctioned churches.",
				"Grave Robbery": 			"The profanation of sepulchers to rob the dead of their valuables is seen with utmost disgust by Veldonian society, especially by the followers of Sothos, God of Death.",
				"Fraud": 					"Pretending to be something you are not to gain sympathy, regard or money. This might include pretending to be a veteran of the Eskalian wars, selling phony cures or masquerading as a priest, noble, or similar person of station.",
				"Trespassing": 				"Entering or remaining on someone else's property without permission, often resulting in disputes or damage.",
				"Clandestine Marriage":		"Secretly marrying without the consent or approval of family members or authorities.",
				"Child Theft":				"Kidnapping or abducting children for various reasons, including ransom, forced labor, or adoption without consent.",
				"Sodomy": 					"Committing any unnatural sexual act, including those among members of the same sex, but not limited to it."
			},
			"merits": {
				"blessed": 							{ "name": "blessed",				"rule": "character.biography.merits.blessed",					"desc": "The day you were born, a god took pity on your human condition and blessed you. +10 Magic Resistance. This Merit cannot be taken in conjunction with the Cursed Flaw."}, 
				"eagle_eyed": 						{ "name": "eagle_eyed",				"rule": "character.biography.merits.eagle_eyed",				"desc": "You have improved chances of spotting hidden objects or enemies. +10 Perception."}, 
				"fearless": 						{ "name": "fearless",				"rule": "character.biography.merits.fearless",					"desc": "You have Advantage on all Resolve checks involving fear. This Merit cannot be taken if in possession of the Coward Flaw."}, 
				"haggler": 							{ "name": "haggler",				"rule": "character.biography.merits.haggler",					"desc": "When you find a trader, make a Reason check. If you pass it, you can sell all items in your possession for 100% of their price, instead of the usual 50%."}, 
				"lucky": 							{ "name": "lucky",					"rule": "character.biography.merits.lucky",						"desc": "Once per Domain, you can choose the most optimal result for you as a result of any roll, be it yours or an opponent's. This means that you don't need to make a roll: whichever the best option would be for that particular check, it happens. The only exception to this is rolls on the Precious Items table, which cannot be affected by Lucky."}, 
				"natural_healer": 					{ "name": "natural_healer",			"rule": "character.biography.merits.natural_healer",			"desc": "Your injuries seem to heal faster, recovering D6 Toughness after combat, instead of D4."},
				"hearty":							{ "name": "hearty",					"rule": "character.biography.merits.hearty",					"desc": "You have Advantage on all Endurance checks involving diseases and poisons. This Merit cannot be taken if in possession of the Sickly Flaw."},
				"scavenger": 						{ "name": "scavenger",				"rule": "character.biography.merits.scavenger",					"desc": "You have a good eye for finding things of value among heaps of trash. +10 Scavenging."},
				"tracker": 							{ "name": "tracker",				"rule": "character.biography.merits.tracker",					"desc": "Once per Domain, you can track down a trader. They will appear in a room you've just cleared. Unfortunately, they seem to be angry at you for following them, and all their prices are doubled."},
				"trained": 							{ "name": "trained",				"rule": "character.biography.merits.trained",					"desc": "You have obsessively trained with one particular weapon, granting you +10 to your weapon skill when wielding that type of weapon."}
			},
			"flaws": {
				"addict": 						{ "name": "addict", 			"rule": "character.biography.flaws.addict",				"desc": "You are addicted to the rush and carefree feeling that narcotics provide, more so since you were cast into the Underverse. Each time you ind Cooking Supplies, you spend some of them for recreational purposes, resulting in you finding 1 less."},
				"coward": 						{ "name": "coward", 			"rule": "character.biography.flaws.coward",				"desc": "You have Disadvantage on all Resolve checks involving fear. This Flaw cannot be taken if in possession of the Fearless Merit."},
				"cracked_soul": 				{ "name": "cracked_soul", 		"rule": "character.biography.flaws.cracked_soul",		"desc": "You start the game with D4+8 Aether, instead of D6+8."},
				"cursed": 						{ "name": "cursed", 			"rule": "character.biography.flaws.cursed",				"desc": "You offended a deity or some powerful sorcerer, who cursed you. -10 Magic Resistance. This Flaw cannot be taken in conjunction with the Blessed Merit."},
				"damaged_nerve": 				{ "name": "damaged_nerve",		"rule": "character.biography.flaws.damaged_nerve",		"desc": "One of your legs was injured a while back, and you never fully recovered. -10 Acrobatics."},
				"fragile_mind": 				{ "name": "fragile_mind", 		"rule": "character.biography.flaws.fragile_mind",		"desc": "You roll D4+8 for your starting Sanity, instead of D6+8."},
				"queasy": 						{ "name": "queasy", 			"rule": "character.biography.flaws.queasy",				"desc": "The sight of blood and poking at your own wounds makes you sick. -10 Medicine."},
				"short_sighted": 				{ "name": "short_sighted",		"rule": "character.biography.flaws.short_sighted",		"desc": "Your eyesight isn't your greatest asset. -10 Perception."},
				"sickly": 						{ "name": "sickly",				"rule": "character.biography.flaws.sickly",				"desc": "You have Disadvantage on all Endurance checks involving diseases and poisons. This Flaw cannot be taken if in possession of the Resilient Constitution Merit."},
				"armor_averse": 				{ "name": "armor_averse", 		"rule": "character.biography.flaws.armor_averse",		"desc": "Whenever you wear a piece of heavy armor (excluding helmets) your Dodge skill is reduced by 5. If you're wearing a full suit of heavy armor your Dodge skill is reduced by 20"},
			},
			"actions_old": {
				"combat": {
					"standard": {
						"get_up_from_prone":	{"rule": "get_up_from_prone", "args":[]},
						"flee":					{"rule": "flee", "args":[]},
						"targeted_attack":		{"rule": "targeted_attack", "args":[]},
						"slash_attack": 		{"rule": "slash_attack", "args":[]},
						"pierce_attack":		{"rule": "pierce_attack", "args":[]},
						"blunt_attack":			{"rule": "bludgeon_attack", "args":[]},
						"disabling_strike":		{"rule": "disabling_strike", "args":[]},
					},
					"free": {
						"drop_held": 			{"rule": "drop_held", "args":[]},
						"use_belt_item": 		{"rule": "use_belt_item", "args":[]},
						"stop_concentrating": 	{"rule": "stop_concentrating", "args":[]},
						"violent_swing":		{"rule": "violent_swing", "args":[]},
					},
					"reactions": {
						"combat_check":			{"rule": "combat_check", "args":[]},
						"dodge_check":			{"rule": "dodge_check", "args":[]},
						"blunt_crit":			{"rule": "blunt_crit", "args":[]},
					}
				},
				"traversal": {
					"move": 			{"rule": "move", "args":[]},
					"scavenge": 		{"rule": "scavenge", "args":[]},
					"take_breather":	{"rule": "take_breather", "args": []},
					"camp":				{"rule": "camp", "args": []},
					"inventory": 		{"rule": "inventory", "args": []},
					"pickup_item": 		{"rule": "pickup_item", "args": []},
				},
			"camp_actions": {
				"attune": 				{"rule": "camp_atune", "args":[]},
				"barricade": 			{"rule": "camp_barricade", "args":[]},
				"cook": 				{"rule": "camp_cook", "args":[]},
				"ritual_components":	{"rule": "camp_craft", "args":[["crafting_supplies", -5], ["ritual_components", 1], ["exhaustion", 1], ["camp_check", -2]]},
				"bandages": 			{"rule": "camp_craft", "args":[["crafting_supplies", -1], ["bandages", 1], ["exhaustion", 1], ["camp_check", -1]]},
				"lamp_oil": 			{"rule": "camp_craft", "args":[["crafting_supplies", -2], ["lamp_oil", 1], ["exhaustion", 1], ["camp_check", -2]]},
				"torches": 				{"rule": "camp_craft", "args":[["crafting_supplies", -1], ["torches", 1], ["exhaustion", 1], ["camp_check", -2]]},
				"heal_condition": 		{"rule": "camp_heal", "args":[]},
				"repair": 				{"rule": "camp_repair", "args":[]},
				"repair": 				{"rule": "camp_rest", "args":[]},
				"swap_amulet": 			{"rule": "camp_swap_amulet", "args":[]},
				}
			},
		},
		"enemies": {
			"skeletal_horror": {
				"id": "skeletal_horror",
				"type": "Undead", 
				"number": 2,
				"stats": {"health": [3, 3]},
				"skills": {"perception": 20,"endurance": 20,"athletics": 25,"combat": 30,"magic_resist": 20,},
				"body": {"type": "humanoid","armor": [0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0],"weak_spot": "head"},
				"loot": "tables.spoils",
				"modifiers": {
					"defense": {"Acid":1, "Air":1, "Arcane":1, "Bludgeon":1, "Charm": 0, "Cold":1, "Disease":0, "Earth":1, "Fire":1, "Holy":2, "Infernal":1, "Necrotic":-1, "Pierce":1, "Poison":0, "Psychic":1, "Slash":1, "Water":1},
					"reduction": {"Acid":0, "Air":0, "Arcane":0, "Bludgeon":0, "Charm": 0, "Cold":0, "Disease":0, "Earth":0, "Fire":0, "Holy":0, "Infernal":0, "Necrotic":0, "Pierce":0, "Poison":0, "Psychic":0, "Slash":0, "Water":0},
				},
				"traits": ["undead", "frightening"],
				"adaptions": [],
				"passives":[
					{ "name": "frightening",
						"rule": "apply_condition_roll",
						"args": ["frightened", "resolve"]},
				],
				"combat": {
					"standard": {
						"idx": [0,1],
						"distribution": ["cursed_slash", "cursed_slash", "ethereal_grasp", "ethereal_grasp", "haunting_wail", "vengeful_onslaught"],
						"actions": [
							{ "name": "cursed_slash",
								"rule": "physical_attack_roll",
								"die": [[8, ["Slash"], 0]],
								"check": { "attack": "combat", "defend": null },
								"desc": "swings its weapon with an eerie precision, dealing D8 Slashing damage." },
							{ "name": "ethereal_grasp",
								"rule": "ethereal_grasp",
								"die": [[6, ["Necrotic"], 0]],
								"check": { "attack": "combat", "defend": "endurance" },
								"desc": "reaches out with its hand, attempting to touch the essence of a target's life force. The target must make an Endurance check. On a failed check, they take D6 Necrotic damage, and the Skeletal Horror regains Health equal to half the damage dealt (rounding up). On a successful roll, the target takes half damage (rounding up), and the Skeletal Horror doesn't regain Health." },		
							{ "name": "haunting_wail",
								"rule": "haunting_wail",
								"die": null,
								"check": { "attack": "combat", "defend": "resolve" },
								"desc": "lets out a haunting wail that reverberates through the air. All creatures must make a successful Resolve check to avoid becoming Stunned for 1 round." },
							{ "name": "vengeful_onslaught",
								"rule": "vengeful_onslaught",
								"die": [[10, ["Pierce"], 0]],
								"check": { "attack": "combat", "defend": null},
								"desc": "charges forward with relentless determination, targeting one creature. It makes a melee attack against the target, dealing D10 Piercing damage on a hit. If the attack hits, the Skeletal Horror immediately uses its Ethereal Grasp ability as a Free Action." },
						]
					}
				}
			}
		},
		"overseers": {
			"infernal_tormentor": {
				"id": "infernal_tormentor",
				"type": "Demon", 
				"number": 1,
				"stats": {"health": [15, 15]},
				"skills": {"perception": 70,"endurance": 50,"athletics": 60,"combat": 60,"magic_resist": 50,},
				"body": {"type": "humanoid","armor": [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"weak_spot": "head"},
				"loot": ["tables.valuable", "table.precious"],
				"modifiers": {
					"defense": {"Acid":1, "Air":1, "Arcane":1, "Bludgeon":1, "Charm": 0, "Cold":1, "Disease":0, "Earth":1, "Fire":1, "Holy":2, "Infernal":1, "Necrotic":-1, "Pierce":1, "Poison":0, "Psychic":1, "Slash":1, "Water":1},
					"reduction": {"Acid":0, "Air":0, "Arcane":0, "Bludgeon":0, "Charm": 0, "Cold":0, "Disease":0, "Earth":0, "Fire":0, "Holy":0, "Infernal":0, "Necrotic":0, "Pierce":0, "Poison":0, "Psychic":0, "Slash":0, "Water":0},
				},
				"traits": [["penetrating", 2], ["frightening", 1], ["ruthlessness", 1], ["swift", 1]],
				"adaptions": {
					"5": [["extra_die", 6], ["armor", 1]],
					"10": [["extra_die", 6], ["combat", 10]],
				},
				"passives":[],
				"combat": {
					"standard": {
						"idx": [0,1],
						"distribution": [],
						"actions": [
						]
					}
				}
			}
		},
		"models": {
			"domain": {
				"overseer": null,
				"influence": null,
				"tension_die": [8, 8],
				"layer_die": [10, 10],
				"exit_die": [10, 10],
				"darkness": [],
				"enemy_pool": ["skeletal_horror"],
				"map": Array(11).fill(Array(11)),
				"party_coord": [5, 5],
			},
			"area_flags":{
				"is_event": 1, 
				"is_encounter": 2, 
				"is_exit_up": 4, 
				"is_exit_down": 8, 
				"is_layer": 16,
				"is_scavenge": 32,
				"is_trader": 64,
				"is_items": 128, 
			},
			"door_flags": {
				"door": 1,
				"locked": 2,
				"trapped": 4,
				"opened": 8
			},
			"area": {
				"floor_plan": {
					"type": null,
					"shift_by": 0,
					"doors": [0,0,0,0],
					"flags": 0,
					"data": {}
				},
				"contents": {
					"scavenge": 	{"tries": [0,1]},
					"encounter": {
						"id":		undefined,
						"order":	{"idx": 0, "parties": []},
						"enemies":	[],
						"reset":	false,
						"ambush":	false,
						"outcome":	null
					},
					"event": 		{"id": 0},
					"exit": 		{"direction": -1},
					"items": 		[],
					"trader": 		{"unique_items":[], "bargains":[0,0], "buy_sell": [.5, 1]},
				},
				"flags": {
					"door": {
						"door": 1,
						"locked": 2,
						"trapped": 4,
						"opened": 8
					},
					"contents": {
						"is_event": 1, 
						"is_encounter": 2, 
						"is_exit_up": 4, 
						"is_exit_down": 8, 
						"is_layer": 16,
						"is_scavenge": 32,
						"is_trader": 64,
						"is_items": 128, 
					}
				}
			},
			"directions": {
				"north": 0,
				"west": 1,
				"south": 2,
				"east": 3
			},
			"character": {
				"type": 				"player",
				"name": 				"Anonymous",
				"biography":		{
					"body": 			{ "type": "humanoid", "weak_spot": "head" },
					"levels":			{ "base": 0,	"max": 1000,"total": 0 },
					"masteries":	{},
					"merits":			{},
					"flaws":			{},
					"madness":		{},
					"goals":			{},
					"perks": 			{},
					"domain":			{},
				},
				"stats": {
					"base": {
						"health": 		{ "base": 0,	"max": 0,	"total": 0 },
						"toughness": 	{ "base": 0,	"max": 0,	"total": 0 },
						"aether": 		{ "base": 0,	"max": 0,	"total": 0 },
						"sanity": 		{ "base": 0,	"max": 0,	"total": 0 },
						"exhaustion": 	{ "base": 0,	"max": 20,	"total": 0 },
					},
					"weapon": {
						"blade":		{ "base": 0, 	"max": 80,	"total": 0 },
						"bludgeon":		{ "base": 0, 	"max": 80,	"total": 0 },
						"fist":			{ "base": 20,	"max": 80,	"total": 20},
						"pole":			{ "base": 0, 	"max": 80,	"total": 0 },
					},
					"skill": {
						"acrobatics":	{ "base": 10,	"max": 80,	"total": 10}, 
						"athletics":	{ "base": 10,	"max": 80,	"total": 10}, 
						"dodge":		{ "base": 10,	"max": 80,	"total": 10}, 
						"endurance":	{ "base": 0, 	"max": 80,	"total": 0 }, 
						"medicine":		{ "base": 0, 	"max": 80,	"total": 0 },
						"magic_resist": { "base": 0,	"max": 80,	"total": 0 },
						"perception":	{ "base": 20,	"max": 80,	"total": 20}, 
						"resolve":		{ "base": 10,	"max": 80,	"total": 10}, 
						"reason":		{ "base": 0, 	"max": 80,	"total": 0 }, 
						"scavenge":		{ "base": 0, 	"max": 80,	"total": 0 }, 
						"stealth":		{ "base": 0, 	"max": 80,	"total": 0 }, 
						"thievery":		{ "base": 0, 	"max": 80,	"total": 0 },
					},
					"action": {
						"free":			{ "base": 1,	"max": 1,	"total": 1 },
						"reaction":		{ "base": 1,	"max": 1,	"total": 1 },
						"standard":		{ "base": 1,	"max": 1,	"total": 1 },
					},
					"combat": {
						"attack": 		{ "base": 0, 	"max": 0,	"total": 0 },
						"parry":		{ "base": 0, 	"max": 0,	"total": 0 },
						"initiative":	{ "base": 0, 	"max": 0,	"total": 0 },
						"damage": 		{ "base": 0, 	"max": 0,	"total": 0 },
						"dealt": 		{ "base": 0, 	"max": 0,	"total": 0 },
					},
					"traversal": {
						"break":		{ "base": 0,	"max": 0,	"total": 0 },
						"disarm":		{ "base": 0,	"max": 0,	"total": 0 },
						"lockpick": 	{ "base": 0,	"max": 20,	"total": 0 },
						"inventory":	{ "base": 0,	"max": 20,	"total": 0 },
					},
					"camp": {
						"hidden": 		{ "base": 0, 	"max": 20,	"total": 0 },
					}
				},
				"modifiers": {
				},
				"enums": {
					"defense": {
						"armor":		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
						"affinity":		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
						"reduction":	[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
					},
					"offense": {
						"imbued":		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
					},
					"status": {
						"effects": 		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
					},
				},
				"+checks": {},
				"light_source": "equipped.off_hand",
				"equipped": { 
					"main_hand":	null,
					"off_hand":		null,
					"belt": 		null,
					"belt_lamp":	null,
					"helmet":		null,
					"torso":		null,
					"vambrace":		null,
					"greave":		null,
					"gloves":		null,
					"boots":		null,
					"amulet":		null,
					"ring_l":		null,
					"ring_r":		null,
					"backpack":		null,
					"pouch_1":		null,
					"pouch_2":		null,
					"pouch_3":		null,
				},
				"inventory": {
					"supplies": { "gold": 0, "jewelry": 0, "bandage": 0, "cooking": 0, "crafting": 0, "crystal": 0, "lockpick": 0, "oil": 0, "ration": 0, "ritual": 0, },
					"items": 		[],
				},
				"actions": {
					"combat": {
						"standard": 	{},
						"free": 			{},
						"reactions": 	{},
					},
					"traversal": {
						"standard": {}
					},
					"camp": {
						"standard": {}
					},
				},
			},

			"combat": {
				"enemy_idx": 0,
				"enemy_party": [],
				"party_order": ["character_party", "enemy_party"],
			},

			"session": 	{	},
		},
		"encounters": {
			"enemy": {
				"skeletal_horror": {
					"type": 			"enemy",
					"name": 			"skeletal_horror",
					"biography":		{
						"tribe":		"undead",
						"body": 		{ "type": "humanoid", "weak_spot": "head" },
						"levels":		{ "base": 1,	"max": 3,"total": 1 },
						"number": 		2,
						"adaptations":	{},
						"loot_table":	"tables.spoils",
						"distribution": ["cursed_slash", "cursed_slash", "ethereal_grasp", "ethereal_grasp", "haunting_wail", "vengeful_onslaught"],
					},
					"stats.base.health": 			{ "base": 3,	"max": 3,		"total": 3	},
					"stats.weapon.blade": 			{ "base": 30,	"max": 80,	"total": 30 },
					"stats.skill.magic_resist": 	{ "base": 20,	"max": 80,	"total": 20	},
					"stats.skill.perception":		{ "base": 20, "max": 80,	"total": 20	},
					"stats.skill.endurance":		{ "base": 20, "max": 80,	"total": 20 }, 
					"stats.skill.resolve":			{ "base": 20, "max": 80,	"total": 20 },
					"stats.skill.acrobatics":		{ "base": 25, "max": 80,	"total": 25 }, 
					"stats.skill.athletics":		{ "base": 25, "max": 80,	"total": 25 },
					"enums.defense.armor":			[0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
					"enums.defense.affinity":		[1,1,1,1,0,1,0,1,1,2,1,-1,1,0,1,1,1],
					"actions.combat.standard": 		["cursed_slash", "ethereal_grasp", "haunting_wail", "vengeful_onslaught"],
				},
			},
			"overseer": {

			},
		},
		"emersion_text": {
			"general": {
				"introduction": "When __0__ first awakens among rotting corpses, confused and in pain, they have nothing but some rags on, and the knowledge they accumulated all those years spent on the surface. Underverse is an unforgivable place, and they'll need to find their footing quickly if they want to survive."
			}
		},
	},
})



</script>

<script>
let save_data = Object({
	get: function() { return this.data; },
	set: function(_data) { this.data = _data; },

	data: {
		"context": "traverse.actions",

		"domain_idx": -1,
		"domains": [],

		"character_idx": 0,
		"character_party": [],
		"character_turns": null,

		"enemy_idx": 0,
		"enemy_party": [],
		"enemy_turns": null,

		"encounter": null,
	},
})
</script>

<script>
const rule_data = Object({
	get: function (_key) {
		let split = _key.split(".");
		let result = (split.length > 0) ? this : null;

		for (let key of split) {
			result = result[key];

			if (result == null || result == undefined) {
				throw new Error(`There is no rule that matches the key: ${_key}`);
			}
		}

		return result;
	},

	start: [
		{ "id": "char_idx", "action": "read", "args": ["save_d", "character_idx"] },
		{ "id": "is_character", "action": "null", "args": ["save_d", "character_party.<char_idx>"] },
		{ "id": "null", "action": "branch", "args": ["<is_character>", { "action": "inject", "args": ["campaign.new", ["<is_character>"]] }, null] },
		{ "id": "null", "action": "inject", "args": ["campaign.context.next"] },
	],

	campaign: {
		new: [
			["is_character"],
			// Set up character party coordinate watchers
			{ "id": "null", "action": "watch", "args": ["d_idx", "domain_idx", "domain_idx"] },
			{ "id": "null", "action": "watch", "args": ["x", "domains\\.\\d+\\.party_coord\\.0", "domains.<$d_idx>.party_coord.0"] },
			{ "id": "null", "action": "watch", "args": ["y", "domains\\.\\d+\\.party_coord\\.1", "domains.<$d_idx>.party_coord.1"] },
			// Setup Domain Context
			{ "id": "null", "action": "context", "args": ["domain", "+", ["domain\\."]] },
			// Setup Character
			{ "id": "branch", "action": "branch", "args": ["<is_character>", { "action": "inject", "args": ["character.creation.wizard", [0]] }, null] },
			// Setup Domain
			{ "id": "domain_idx", "action": "read", "args": ["save_d", "domain_idx"] },
			{ "id": "branch", "action": "branch", "args": [["<domain_idx>", "!=", -1], { "action": "return" }] },
			{ "id": "branch", "action": "inject", "args": ["traverse.domain.enter"] },
		],

		context: {
			next: [
				{ "id": "null", "action": "inject", "args": ["campaign.context.determine", []] },
				{ "id": "null", "action": "inject", "args": ["campaign.context.set", []] },
			],

			set: [
				{ "id": "context", "action": "read", "args": ["save_d", "context"] },
				{ "id": "null", "action": "action", "args": ["<context>"] },
			],

			determine: [
				{ "id": "area_f", "action": "read", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.flags"] },
				// Is there an encounter
				{ "id": "combat_f", "action": "read", "args": ["game_d", "models.area.flags.contents.is_encounter"] },
				{ "id": "null", "action": "branch", "args": [["<combat_f>", "&", "<area_f>"], null, { "action": "goto", "args": ["id.event_f.next"] }] },
				// Combat Turned off
				//{ "id": "null", "action": "write", "args": ["save_d", "context", "combat.actions"] }, 
				{ "id": "null", "action": "return", "args": [] },
				// Is there an event
				{ "id": "event_f", "action": "read", "args": ["game_d", "models.area.flags.contents.is_event"] },
				{ "id": "null", "action": "branch", "args": [["<event_f>", "&", "<area_f>"], null, { "action": "goto", "args": ["id.trader_f.next"] }] },
				//{"id": "null",			"action": "write", 		"args": ["save_d", "context", "event.actions"]},
				//{"id": "null",			"action": "return",		"args": []},
				// Is there a trader
				{ "id": "trader_f", "action": "read", "args": ["game_d", "models.area.flags.contents.is_event"] },
				{ "id": "null", "action": "branch", "args": [["<trader_f>", "&", "<area_f>"], null, { "action": "goto", "args": ["id.traverse.next"] }] },
				//{"id": "null",			"action": "write", 		"args": ["save_d", "context", "trader.actions"]},
				//{"id": "null",			"action": "return",		"args": []},
				// Else traverse
				{ "id": "traverse", "action": "write", "args": ["save_d", "context", "traverse.actions"] },
			],
		},

		preserve_lore: [],
		abandon: [],
	},

	// ------------------------------------------------------------------------------------------------------- Traverse
	traverse: {
		actions: [
			{ "id": "choice", "action": "choice", "args": ["What action will you take?", { "move": "traverse.move.choice", "camp": "rest.camp.flow", "breather": "rest.breather.flow", "scavenge": "traverse.area.check.scavenge.do" }, ["camp"]] },
			{ "id": "log", "action": "log", "args": ["You chose to <choice.data>."] },
			{ "id": "null", "action": "branch", "args": [["<choice.data>", "==", "camp"], { "action": "action", "args": ["rest.camp.actions"] }, { "action": "inject", "args": ["<choice.data>"] }] },
			{ "id": "null", "action": "inject", "args": ["campaign.context.next", []] },
		],

		move: {
			choice: [
				{ "id": "choice", "action": "choice", "args": ["What direction will you go?", ["west", "north", "east", "south"]] },
				{ "id": "notify", "action": "notify", "args": ["Party moves <choice.data>."] },
				{ "id": "direct", "action": "read", "args": ["game_d", "models.directions.<choice.data>"] },
				{ "id": "inject", "action": "inject", "args": ["traverse.move.direction", ["<direct>"]] },
			],

			direction: [
				["direct"],
				{ "id": "door", "action": "read", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.doors.<direct>"] },
				// Make sure there is a door in the direction they are moving
				{ "id": "no_door", "action": "math", "args": ["<door>", "==", 0] },
				{ "id": "branch", "action": "branch", "args": ["<no_door>", { "action": "notify", "args": ["There is only a wall here."] }, null] },
				{ "id": "return", "action": "branch", "args": ["<no_door>", { "action": "return" }, null] },
				// Determine if the door has been opened before or not and branch accordingly
				{ "id": "opened", "action": "math", "args": ["<door>", "&", 8] },
				{
					"id": "branch", "action": "branch", "args": ["<opened>",
						{ "action": "inject", "args": ["traverse.area.door.enter", ["<direct>"]] },
						{ "action": "inject", "args": ["traverse.area.door.open", ["<direct>"]] }]
				},
			],

			backtrack: [
				["area_type"],
				{ "id": "notify", "action": "notify", "args": ["----------- Backtracking <area_type> ------------ "] },
				{ "id": "tension", "action": "inject", "args": ["dice.usage.check", ["domains.<$d_idx>.tension_die", "Tension", "traverse.area.check.tension.flow", true]] },
				{ "id": "light_source", "action": "branch", "args": [["<area_type>", "==", "room"], { "action": "inject", "args": ["character.light_sources.use.party", ["character_party"]] }] },
			],
		},

		domain: {
			enter: [
				// Generate the domain from the model
				{ "id": "domain_idx", "action": "read", "args": ["save_d", "domain_idx"] },
				{ "id": "domain_idx", "action": "math", "args": ["<domain_idx>", "+", 1] },
				{ "id": "null", "action": "write", "args": ["save_d", "domain_idx", "<domain_idx>"] },
				{ "id": "copy", "action": "copy", "args": ["game_d", "models.domain"] },
				{ "id": "domain", "action": "write", "args": ["save_d", "domains.<domain_idx>", "<copy>"] },
				{ "id": "null", "action": "audience", "args": ["domain:<domain_idx>", "+", { "start": "domain\\.<domain_idx>.entered", "stop": "domain\\.<domain_idx>.exited" }] },
				{ "id": "null", "action": "event", "args": ["domain.<domain_idx>.entered", "<domain_idx>"] },
				// Start the Domain rolls
				{ "id": "notify", "action": "notify", "args": ["------------- Entered Domain ------------ "] },
				{ "id": "inject", "action": "inject", "args": ["dice.rolls.save_roll_against_table", ["tables.overseers", "domains.<domain_idx>.overseer"]] },
				{ "id": "inject", "action": "inject", "args": ["dice.rolls.save_roll_against_table", ["tables.influence", "domains.<domain_idx>.influence"]] },
				{ "id": "party_size", "action": "size", "args": ["save_d", "character_party"] },
				{ "id": "p_range", "action": "range", "args": ["<party_size>"] },
				// Add Experience to players for entering new domain
				{ "id": "loop", "action": "loop", "args": ["character.biography.levels.add_experience", "<p_range>", ["character_party", "$idx$", 50]] },
				// Generate the first room of the domain
				{ "id": "copy", "action": "copy", "args": ["game_d", "models.area.floor_plan"] },
				{ "id": "set", "action": "set", "args": ["<copy>", "type", "room"] },
				{ "id": "has_stair", "action": "math", "args": ["<domain_idx>", "!=", 0] },
				{ "id": "branch", "action": "branch", "args": ["<has_stair>", null, { "action": "goto", "args": ["id.map_d.next"] }] },
				{ "id": "set", "action": "set", "args": ["<copy>", "contains", "stairs_up"] },
				// Write the model to the domain map data
				{ "id": "map_d", "action": "write", "args": ["save_d", "domains.<domain_idx>.map.5.5", "<copy>"] },
				// Generate Doors
				{ "id": "doors", "action": "inject", "args": ["dice.rolls.lookup_against_table", ["tables.doors", 8]] },
				{ "id": "write", "action": "write", "args": ["save_d", "domains.<domain_idx>.map.<$y>.<$x>.doors", "<doors>"] },
				{ "id": "scavenge", "action": "inject", "args": ["traverse.area.check.scavenge.generate"] },
			],
		},

		area: {
			type: {
				generate: [
					["direct"],
					// Roll for type
					{ "id": "lookup", "action": "inject", "args": ["dice.rolls.roll_against_table", ["game_d", "tables.area_type"]] },
					{ "id": "check", "action": "math", "args": ["<lookup.1>", "==", "room"] },
					// Copy model to store data in
					{ "id": "copy", "action": "copy", "args": ["game_d", "models.area.floor_plan"] },
					{ "id": "copy", "action": "set", "args": ["<copy>", "type", "<lookup.1>"] },
					{ "id": "copy", "action": "set", "args": ["<copy>", "shift_by", "<direct>"] },
					// Write the model to the domain map data
					{ "id": "map_d", "action": "write", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>", "<copy>"] },
					// Branch to room or corridor rule logic
					{ "id": "branch", "action": "branch", "args": ["<check>", { "action": "inject", "args": ["traverse.area.type.room"] }, { "action": "inject", "args": ["traverse.area.type.corridor"] }] },
				],

				room: [
					{ "id": "notify", "action": "notify", "args": ["-------------- Entering Room -------------- "] },
					{ "id": "doors", "action": "inject", "args": ["traverse.area.door.roll"] },
					{ "id": "tension", "action": "inject", "args": ["dice.usage.check", ["domains.<$d_idx>.tension_die", "Tension", "traverse.area.check.tension.flow", true]] },
					{ "id": "light_source", "action": "inject", "args": ["character.light_sources.use.party", ["character_party"]] },
					{ "id": "null", "action": "inject", "args": ["traverse.area.check.layer_or_exit.flow"] },
					{ "id": "area_f", "action": "read", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.flags"] },
					// If layer or exit then return
					{ "id": "null", "action": "branch", "args": [["<area_f>", "!=", 0], { "action": "return" }] },
					{ "id": "is_encounter", "action": "inject", "args": ["dice.rolls.roll", [20, "Encounter Check (pass: <10)"]] },
					{ "id": "null", "action": "branch", "args": [["<is_encounter>", ">=", 10], { "action": "inject", "args": ["traverse.area.check.encounter.lookup"] }, { "action": "inject", "args": ["traverse.area.check.event.lookup"] }] },
					{ "id": "scavenge", "action": "inject", "args": ["traverse.area.check.scavenge.generate"] },
				],

				corridor: [
					{ "id": "notify", "action": "notify", "args": ["------------ Entering Corridor ------------ "] },
					{ "id": "doors", "action": "inject", "args": ["traverse.area.door.roll"] },
					{ "id": "tension", "action": "inject", "args": ["dice.usage.check", ["domains.<$d_idx>.tension_die", "Tension", "traverse.area.check.tension.flow", true]] },
					{ "id": "area_f", "action": "read", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.flags"] },
					{ "id": "is_encounter", "action": "inject", "args": ["dice.rolls.roll", [20, "Encounter Check (pass: <15)"]] },
					{ "id": "null", "action": "branch", "args": [["<is_encounter>", ">=", 15], { "action": "inject", "args": ["traverse.area.check.encounter.lookup"] }] },
				],
			},

			door: {
				roll: [
					// Get Save Data -----------
					{ "id": "shift", "action": "read", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.shift_by"] },
					// Doors -------------------
					{ "id": "d_lookup", "action": "inject", "args": ["dice.rolls.roll_against_table", ["game_d", "tables.doors"]] },
					{ "id": "check", "action": "math", "args": ["<d_lookup.0>", "==", 0] },
					{ "id": "d_lookup", "action": "shift", "args": ["<d_lookup.1>", "<shift>"] },
					{ "id": "sum", "action": "resolve", "args": ["<d_lookup>"] },
					{ "id": "write", "action": "write", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.doors", "<sum>"] },
					{ "id": "return", "action": "branch", "args": ["<check>", { "action": "return" }, null] },
					// Locked ------------------
					{ "id": "locked", "action": "inject", "args": ["dice.rolls.roll_against_table", ["game_d", "tables.locked"]] },
					{ "id": "locked", "action": "shift", "args": ["<locked.1>", "<shift>"] },
					{ "id": "temp", "action": "math", "args": ["<locked>", "*", "<d_lookup>"] },
					{ "id": "sum", "action": "math", "args": ["<temp>", "+", "<sum>"] },
					{ "id": "write", "action": "write", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.doors", "<sum>"] },
					// Trapped -----------------
					{ "id": "trapped", "action": "inject", "args": ["dice.rolls.roll_against_table", ["game_d", "tables.trapped"]] },
					{ "id": "trapped", "action": "shift", "args": ["<trapped.1>", "<shift>"] },
					{ "id": "temp", "action": "math", "args": ["<trapped>", "*", "<d_lookup>"] },
					{ "id": "sum", "action": "math", "args": ["<temp>", "+", "<sum>"] },
					{ "id": "write", "action": "write", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.doors", "<sum>"] },
				],

				open: [
					["direct"],
					{ "id": "door", "action": "read", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.doors.<direct>"] },
					// Did you pass the disarm check
					{ "id": "trapped", "action": "math", "args": ["<door>", "&", 4] },
					{ "id": "trap", "action": "template", "args": ["traverse.area.door.check", ["The door is trapped would you like to attempt to disarm the trap?", "<direct>", 4]] },
					{ "id": "branch", "action": "branch", "args": ["<trapped>", { "action": "inject", "args": ["<trap>"] }, null] },
					{ "id": "door", "action": "read", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.doors.<direct>"] },
					{ "id": "trapped", "action": "math", "args": ["<door>", "&", 4] },
					{ "id": "return", "action": "branch", "args": ["<trapped>", { "action": "return" }, null] },
					// Did you pass the unlock check
					{ "id": "locked", "action": "math", "args": ["<door>", "&", 2] },
					{ "id": "lock", "action": "template", "args": ["traverse.area.door.check", ["The door is locked would you like to attempt to unlock it?", "<direct>", 2]] },
					{ "id": "branch", "action": "branch", "args": ["<locked>", { "action": "inject", "args": ["<lock>"] }, null] },
					{ "id": "door", "action": "read", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.doors.<direct>"] },
					{ "id": "locked", "action": "math", "args": ["<door>", "&", 2] },
					{ "id": "return", "action": "branch", "args": ["<locked>", { "action": "return" }, null] },
					// Update the door state to opened
					{ "id": "door", "action": "read", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.doors.<direct>"] },
					{ "id": "state", "action": "math", "args": ["<door>", "+", 8] },
					{ "id": "door", "action": "write", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.doors.<direct>", "<state>"] },
					//Enter door
					{ "id": "enter_d", "action": "inject", "args": ["traverse.area.door.enter", ["<direct>"]] },
				],

				check: [
					["text", "direct", "door_state"],
					{ "id": "choice", "action": "choice", "args": ["<text>", ["yes", "no"]] },
					{ "id": "check", "action": "math", "args": ["<choice.data>", "==", "no"] },
					{ "id": "return", "action": "branch", "args": ["<check>", { "action": "return", "args": [false] }, null] },
					{ "id": "char_idx", "action": "read", "args": ["save_d", "character_idx"] },
					{ "id": "skill", "action": "inject", "args": ["character.attributes.stats.get.total", ["character_party", "<char_idx>", "skill", "thievery"]] },
					{ "id": "check", "action": "inject", "args": ["dice.skill.check", ["character_party", "<char_idx>", ["skill.thievery"], "+skill+thievery+door"]] },
					{ "id": "value", "action": "ifelse", "args": ["<check.roll.pass>", "<door_state>", 0] },
					{ "id": "door", "action": "read", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.doors.<direct>"] },
					{ "id": "state", "action": "math", "args": ["<door>", "-", "<value>"] },
					{ "id": "door", "action": "write", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.doors.<direct>", "<state>"] },
				],

				enter: [
					["direct"],
					// Update the party coord to reflect the new area
					{ "id": "x_or_y", "action": "math", "args": ["<direct>", "&", 1] },
					{ "id": "x_or_y", "action": "ifelse", "args": ["<x_or_y>", 0, 1] },
					{ "id": "is_plus", "action": "math", "args": ["<direct>", ">", 1] },
					{ "id": "a_coord", "action": "read", "args": ["save_d", "domains.<$d_idx>.party_coord.<x_or_y>"] },
					{ "id": "op", "action": "ifelse", "args": ["<is_plus>", "+", "-"] },
					{ "id": "n_coord", "action": "math", "args": ["<a_coord>", "<op>", 1] },
					{ "id": "coord", "action": "write", "args": ["save_d", "domains.<$d_idx>.party_coord.<x_or_y>", "<n_coord>"] },
					// If the map has no data for the cell inject an area type rule
					{ "id": "check", "action": "null", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>"] },
					{ "id": "shift_by", "action": "math", "args": ["<direct>", "+", 2] },
					{ "id": "shift_by", "action": "math", "args": ["<shift_by>", "%", 4] },
					{ "id": "branch", "action": "branch", "args": ["<check>", { "action": "inject", "args": ["traverse.area.type.generate", ["<shift_by>"]] }, null] },
					{ "id": "return", "action": "branch", "args": ["<check>", { "action": "return" }, null] },
					// The party has been here before inject a backtrack rule
					{ "id": "a_type", "action": "read", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.type"] },
					{ "id": "null", "action": "inject", "args": ["traverse.move.backtrack", ["<a_type>"]] },
				],
			},

			check: {
				layer_or_exit: {
					flow: [
						{ "id": "layer_die", "action": "read", "args": ["save_d", "domains.<$d_idx>.layer_die"] },
						// Check for the domain exit if layer die < 3
						{ "id": "exit_die", "action": "read", "args": ["save_d", "domains.<$d_idx>.exit_die"] },
						{ "id": "null", "action": "branch", "args": [[["<exit_die.0>", ">", 3], "&", ["<layer_die.0>", "<", 4]], { "action": "inject", "args": ["dice.usage.check", ["domains.<$d_idx>.exit_die", "Exit", "traverse.area.check.layer_or_exit.is_exit", false]] }] },
						// Check for overseer Layer if it hasn't been found
						{ "id": "layer_die", "action": "branch", "args": [["<layer_die.0>", ">", 3], { "action": "inject", "args": ["dice.usage.check", ["domains.<$d_idx>.layer_die", "Layer", "traverse.area.check.layer_or_exit.is_layer", false]] }] },
					],

					is_layer: [
						{ "id": "notify", "action": "notify", "args": ["You have found the Overseer's layer."] },
						// Get layer_flag + area.flag and save
						{ "id": "flag", "action": "read", "args": ["game_d", "models.area.flags.contents.is_layer"] },
						{ "id": "area_f", "action": "read", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.flags"] },
						{ "id": "flag", "action": "math", "args": ["<flag>", "+", "<area_f>"] },
						{ "id": "null", "action": "write", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.flags", "<flag>"] },
						// Generate area data
						{ "id": "id", "action": "read", "args": ["save_d", "domains.<$d_idx>.overseer"] },
						{ "id": "overseer_m", "action": "read", "args": ["game_d", "overseers.<id>"] },
						{ "id": "overseer_m", "action": "inject", "args": ["traverse.area.check.encounter.generate", ["<overseer_m.id>", 0, "<overseer_m.stats.health>", "<overseer_m.adaptions>"]] },
						// Save to area.data
						{ "id": "area_d", "action": "read", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.data"] },
						{ "id": "area_d", "action": "set", "args": ["<area_d>", "<area_f>", ["<overseer_m>"]] },
						{ "id": "null", "action": "write", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.data", "<area_d>"] },
					],

					is_exit: [
						{ "id": "notify", "action": "notify", "args": ["You have found the entrance to the next domain."] },
						// Get exit_flag + area.flags and save
						{ "id": "flag", "action": "copy", "args": ["game_d", "models.area.flags.contents.is_exit_down"] },
						{ "id": "area_f", "action": "read", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.flags"] },
						{ "id": "flag", "action": "math", "args": ["<flag>", "+", "<area_f>"] },
						{ "id": "null", "action": "write", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.flags", "<flag>"] },
						// Generate area data
						{ "id": "exit_m", "action": "copy", "args": ["game_d", "models.area.contents.exit"] },
						{ "id": "exit_m", "action": "set", "args": ["<exit_m>", "direction", 1] },
						// Save to area.data
						{ "id": "area_d", "action": "read", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.data"] },
						{ "id": "area_d", "action": "set", "args": ["<area_d>", "<area_f>", "<exit_m>"] },
						{ "id": "null", "action": "write", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.data", "<area_d>"] },
					],
				},

				tension: {
					flow: [
						{ "id": "size", "action": "size", "args": ["game_d", "tables.darkness"] },
						{ "id": "roll", "action": "roll", "args": ["<size>"] },
						{ "id": "lookup", "action": "lookup", "args": ["game_d", "tables.darkness", "<roll>"] },
						{ "id": "roll_p", "action": "math", "args": ["<roll>", "+", 1] },
						{ "id": "confirm", "action": "confirm", "args": ["Rolled a (<roll_p>/d<size>) on Table(tables.darkness): <lookup>.", ["Next", true], ["Set", "roll", "<size>"], ["Reroll", "roll"]] },
						{ "id": "null", "action": "concat", "args": ["save_d", "domains.<$d_idx>.darkness", "<lookup>"] },
					],
				},

				event: {
					lookup: [
						// Look up Event
						{ "id": "event", "action": "inject", "args": ["dice.rolls.roll_against_table", ["game_d", "tables.events"]] },
						// Get event_flag + area_flags and save
						{ "id": "flag", "action": "read", "args": ["game_d", "models.area.flags.contents.is_event"] },
						{ "id": "area_f", "action": "read", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.flags"] },
						{ "id": "area_f", "action": "math", "args": ["<flag>", "+", "<area_f>"] },
						{ "id": "null", "action": "write", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.flags", "<flag>"] },
						// Generate event data
						{ "id": "event_m", "action": "copy", "args": ["game_d", "models.area.contents.event"] },
						{ "id": "event_m", "action": "set", "args": ["<event_m>", "id", "<event.0>"] },
						// Save to area.data
						{ "id": "area_d", "action": "read", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.data"] },
						{ "id": "f_key", "action": "resolve", "args": ["_<flag>"] },
						{ "id": "area_d", "action": "set", "args": ["<area_d>", "<f_key>", "<event_m>"] },
						{ "id": "null", "action": "write", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.data", "<area_d>"] },
					],
				},

				encounter: {
					lookup: [
						{ "id": "lookup", "action": "inject", "args": ["dice.rolls.roll_against_table", ["save_d", "domains.<$d_idx>.enemy_pool"]] },
						// Get encounter_flag + area_flags and save
						{ "id": "flag", "action": "read", "args": ["game_d", "models.area.flags.contents.is_encounter"] },
						{ "id": "area_f", "action": "read", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.flags"] },
						{ "id": "area_f", "action": "math", "args": ["<flag>", "+", "<area_f>"] },
						{ "id": "null", "action": "write", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.flags", "<flag>"] },
						// Generate encounter enemy data
						{ "id": "encounter", "action": "inject", "args": ["traverse.area.check.encounter.generate", ["<lookup.1>"]] },
						// Save to area.data
						{ "id": "area_d", "action": "read", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.data"] },
						{ "id": "f_key", "action": "resolve", "args": ["_<flag>"] },
						{ "id": "area_d", "action": "set", "args": ["<area_d>", "<f_key>", "<encounter>"] },
						{ "id": "null", "action": "write", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.data", "<area_d>"] },
					],

					generate: [
						["enemy_id"],
						// Copy models and load enemy data
						{ "id": "encounter_m", "action": "copy", "args": ["game_d", "models.area.contents.encounter"] },
						// Fill in enemy instance details
						{ "id": "encounter_m", "action": "set", "args": ["<encounter_m>", "id", "<enemy_id>"] },
						// Return encounter enemy data
						{ "id": "null", "action": "return", "args": ["<encounter_m>"] },
					],
				},

				scavenge: {
					do: [
						{ "id": "area_f", "action": "read", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.flags"] },
						{ "id": "scavenge_f", "action": "read", "args": ["game_d", "models.area.flags.contents.is_scavenge"] },
						{ "id": "is_loot", "action": "math", "args": ["<area_f>", "&", "<scavenge_f>"] },
						// If nothing to scavenge then return
						{ "id": "null", "action": "branch", "args": ["<is_loot>", null, { "action": "log", "args": ["There is nothing to scavenge in this room."] }] },
						{ "id": "null", "action": "branch", "args": ["<is_loot>", null, { "action": "return" }] },
						// Roll scavenging
						{ "id": "loot", "action": "inject", "args": ["dice.rolls.roll_against_table", ["game_d", "tables.scavenge"]] },
						//{"id": "save",				"action": "concat", 	"args": ["save_d", "character_party.<char_idx>.inventory", ["crafting_supplies", "<modifier>"]]},
						// Update area.data
						{ "id": "f_key", "action": "resolve", "args": ["_<scavenge_f>"] },
						{ "id": "scavenge_d", "action": "read", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.data.<f_key>"] },
						{ "id": "scavenged", "action": "math", "args": ["<scavenge_d.tries.0>", "+", 1] },
						{ "id": "is_cleared", "action": "math", "args": ["<scavenge_d.tries.1>", "==", "<scavenged>"] },
						{ "id": "null", "action": "write", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.data.<f_key>.0", "<scavenged>"] },
						{ "id": "null", "action": "branch", "args": ["<is_cleared>", null, { "action": "return" }] },
						// If the room is completely scavenged then clean up area.data
						{ "id": "null", "action": "delete", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.data.<f_key>"] },
						{ "id": "updated_f", "action": "math", "args": ["<area_f>", "-", "<scavenge_f>"] },
						{ "id": "null", "action": "write", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.flags", "<updated_f>"] },
					],

					generate: [
						// Get scavenge flags + area_flags and save
						{ "id": "flag", "action": "read", "args": ["game_d", "models.area_flags.is_scavenge"] },
						{ "id": "area_f", "action": "read", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.flags"] },
						{ "id": "area_f", "action": "math", "args": ["<flag>", "+", "<area_f>"] },
						{ "id": "f_key", "action": "resolve", "args": ["_<flag>"] },
						{ "id": "null", "action": "write", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.flags", "<area_f>"] },
						// Generate scavenge data
						{ "id": "scavenge_m", "action": "copy", "args": ["game_d", "models.area.contents.scavenge"] },
						// Save to area.data
						{ "id": "area_d", "action": "read", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.data"] },
						{ "id": "area_d", "action": "set", "args": ["<area_d>", "<f_key>", "<scavenge_m>"] },
						{ "id": "null", "action": "write", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.data", "<area_d>"] },
					],
				},
			}
		},
	},

	// ------------------------------------------------------------------------------------------------------- Rest
	rest: {
		camp: {
			actions: [
				{ "id": "choices", "action": "resolve", "args": [["attune", "barricade", "cook", "craft_bandages", "craft_oil", "craft_rituals", "craft_torches", "heal_condition", "repair", "rest", "swap_amulet", "camp_check"]] },
				{ "id": "choice", "action": "choice", "args": ["What action will you take?", "<choices>"] },
				{ "id": "log", "action": "log", "args": ["You chose to <choice.data>."] },
				{ "id": "inject", "action": "inject", "args": ["<choice.data>"] },
			],
		},

		breather: {
			flow: [
				{ "id": "toughness", "action": "inject", "args": ["dice.rolls.roll", [10, " recovered Toughness"]] },
				{ "id": "toughness", "action": "math", "args": ["<toughness>", "+", 1] },
				// Get all party members that are player characters
				{ "id": "party_size", "action": "size", "args": ["save_d", "character_party"] },
				{ "id": "p_range", "action": "range", "args": ["<party_size>"] },
				{ "id": "p_type", "action": "read", "args": ["save_d", "character_party.*.type"] },
				{ "id": "p_players", "action": "math", "args": ["<p_type>", "==", "player"] },
				{ "id": "char_idxs", "action": "filter", "args": ["<p_range>", "<p_players>", "is", "1:1"] },
				// Apply stats to all party members
				{ "id": "loop", "action": "loop", "args": ["rest.breather.recover_stats", "<char_idxs>", ["$idx$", "<toughness>", 1, 2, 5]] },
				// Reduce Tension Die
				{ "id": "tension", "action": "resolve", "args": [2] },
				{ "id": "null", "action": "event", "args": ["breather.tension", "<tension>"] },
				{ "id": "toughness", "action": "inject", "args": ["dice.usage.reduce", ["domains.<$d_idx>.tension_die", "Tension", "encroaching_darkness", true, "<tension>"]] },
			],

			recover_stats: [
				["char_idx", "by_toughness", "by_health", "by_exhaustion", "by_light"],
				// Recover Toughness
				{ "id": "toughness", "action": "inject", "args": ["character.attributes.stats.add", ["character_party.<char_idx>", "base", "toughness", { "base": "<by_toughness>" }]] },
				// Recover Health
				{ "id": "health", "action": "inject", "args": ["character.attributes.stats.add", ["character_party.<char_idx>", "base", "health", { "base": "<by_health>" }]] },
				// Reduce Exhaustion
				{ "id": "exhaustion", "action": "inject", "args": ["character.attributes.stats.delete", ["character_party.<char_idx>", "base", "exhaustion", { "base": "<by_exhaustion>" }]] },
				// Reduce Light Source
				{ "id": "name", "action": "read", "args": ["save_d", "character_party.<char_idx>.name"] },
				{ "id": "null", "action": "log", "args": ["<name>'s Toughness: +<by_toughness> to (<toughness.total>/<toughness.max>)"] },
				{ "id": "null", "action": "log", "args": ["<name>'s Health: +<by_health> to (<health.total>/<health.max>)"] },
				{ "id": "null", "action": "log", "args": ["<name>'s Exhaustion: -<by_exhaustion> to (<exhaustion.total>/<exhaustion.max>)"] },
				{ "id": "null", "action": "inject", "args": ["character.light_sources.use.by", ["character_party", "<char_idx>", "<by_light>"]] },
			],
		}
	},

	// ------------------------------------------------------------------------------------------------------- Combat
	combat: {
		actions: [
			// Make sure encounter is setup
			{ "id": "null", "action": "inject", "args": ["combat.setup.process"] },
			// If the encounter is not over then process the next step
			{ "id": "null", "action": "inject", "args": ["combat.round.next"] },
			// Determine if the encounter is over
			{ "id": "encounter", "action": "inject", "args": ["combat.destruct.process"] },
		],

		setup: {
			process: [
				{ "id": "is_null", "action": "null", "args": ["save_d", "encounter"] },
				// If encounter is null then the encounter needs to be setup
				{ "id": "null", "action": "branch", "args": ["<is_null>", null, { "action": "return" }] },
				// Copy encounter to base level for ease of use
				{ "id": "encntr_f", "action": "read", "args": ["game_d", "models.area.flags.contents.is_encounter"] },
				{ "id": "encounter", "action": "read", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.data._<encntr_f>"] },
				{ "id": "null", "action": "write", "args": ["save_d", "encounter", "<encounter>"] },

				// If the combat reset flag is true then reset the enemies
				{ "id": "reset", "action": "branch", "args": [[["<encounter.id>", "is"], "&", "<encounter.reset>"], { "action": "loop", "args": ["combat.enemies.reset", "<encounter.enemies>", ["$idx$"]] }] },
				// Generate/Load the enemies if they have not been already
				{ "id": "enemies", "action": "branch", "args": [[["<encounter.id>", "is"], "&", ["<encounter.enemies>", "isnt"]], { "action": "inject", "args": ["combat.enemies.generate"] }] },
				// Determine party order for combat if it has not been already 
				{ "id": "order", "action": "branch", "args": [[["<encounter.id>", "is"], "&", ["<encounter.order>", "isnt"]], { "action": "inject", "args": ["combat.setup.order"] }] },

				// Copy enemy to enemy_party/idx/turns for parity with character_party/idx/turns
				{ "id": "null", "action": "write", "args": ["save_d", "enemy_party", "<encounter.enemies>"] },
				{ "id": "null", "action": "write", "args": ["save_d", "enemy_idx", 0] },
				{ "id": "null", "action": "write", "args": ["save_d", "enemy_turns", []] },

				// Setup character_turns
				{ "id": "characters", "action": "range", "args": ["save_d", "character_party"] },
				{ "id": "null", "action": "write", "args": ["save_d", "character_idx", 0] },
				{ "id": "null", "action": "write", "args": ["save_d", "character_turns", []] },

				// Add variables to watch list
				{ "id": "null", "action": "watch", "args": ["p_idx", "encounters\\.order\\.idx", "encounter.order.idx"] },
				{ "id": "null", "action": "watch", "args": ["party", "encounters\\.order\\.parties", "encounter.order.<$p_idx>"] },
			],

			order: [
				// Was the character party ambushed
				{ "id": "encounter", "action": "read", "args": ["save_d", "encounter"] },
				{ "id": "branch", "action": "branch", "args": [["<encounter.ambushed>", "isnt"], { "action": "goto", "args": ["id.parties.next"] }] },
				// Create dummy results since there is no roll for ambush
				{ "id": "results", "action": "inject", "args": ["dice.skill.models.inflate.none_to_oppose", ["enemy_party", 0, "character_party", 0]] },
				{ "id": "null", "action": "goto", "args": ["id.order.next"] },
				// Determine how to initiate combat
				{ "id": "parties", "action": "resolve", "args": ["character_party", "enemy_party"] },
				{ "id": "choice", "action": "choice", "args": ["How will the party start combat?", ["ambush", "attack"]] },
				{ "id": "chosen", "action": "log", "args": ["Rolling for: <choice.data>"] },
				// If chose ambush then roll surprise
				{ "id": "results", "action": "branch", "args": [["<choice.0>", "==", 1], { "action": "inject", "args": ["combat.setup.surprise", "<parties>"] }] },
				// If chose initiative or failed surprise then roll initiative
				{ "id": "results", "action": "branch", "args": [[["<results.pass>", "==", "2"], "|", ["<choice.0>", "==", 1]], { "action": "inject", "args": ["combat.setup.initiative", "<parties>"] }, { "action": "resolve", "args": ["<result>"] }] },
				// Save the combat party order
				{
					"id": "order", "action": "branch", "args": [["<results.pass>", "==", "1"],
					{ "action": "write", "args": ["save_d", "combat_order", ["<results.1.party>", "<results.2.party>", "reset"]] },
					{ "action": "write", "args": ["save_d", "combat_order", ["<results.2.party>", "<results.1.party>", "reset"]] }]
				},
				{ "id": "null", "action": "return", "args": ["<results>"] },
			],

			surprise: [
				["i_party", "d_party"],
				// Get the highest stealth skill from the attacking party 
				{ "id": "i_stealth", "action": "read", "args": ["save_d", "<i_party>.*.stats.skill.stealth.total"] },
				{ "id": "i_highest_s", "action": "reduce", "args": ["<i_stealth>", ">="] },
				// Get the highest perception skill for the defending party
				{ "id": "d_perception", "action": "read", "args": ["save_d", "<d_party>.*.stats.skill.perception.total"] },
				{ "id": "d_highest_p", "action": "reduce", "args": ["<d_perception>", ">="] },
				// Add the listener for the surprise penalty
				{ "id": "null", "action": "inject", "args": ["effects.add", ["<i_party>", "<i_highest_s.0>", "/combat.initiate.surprise/", "listener.surprise_companion_penalty"]] },
				// Emit events for triggers on surprise rolls
				{ "id": "event", "action": "event", "args": ["<i_party>.<i_highest_s.0>.stealth.roll.surprise"] },
				{ "id": "event", "action": "event", "args": ["<d_party>.<d_highest_p.0>.perception.roll.surprise"] },
				// Make the opposing roll
				{
					"id": "results", "action": "inject", "args": ["dice.skill.oppose", [true,
						{ "party": "<i_party>", "idx": "<i_highest_s>", "keys": ["skill.stealth"], "check": "+skill+stealth+surprise" },
						{ "party": "<d_party>", "idx": "<d_highest_p>", "keys": ["skill.perception"], "check": "+skill+perception+initiative" }]]
				},
				// Handle i_party passing opposed check
				{ "id": "on_pass", "action": "branch", "args": [["<results.pass>", "==", "2"], { "action": "goto", "args": ["id.on_fail.next"] }] },
				{ "id": "null", "action": "inject", "args": ["effects.add_to_party", ["<i_party>", "/combat.initiate.surprise_bonus/", "listener.surprise_bonus"]] },
				{ "id": "event", "action": "event", "args": ["combat.surprised"] },
				// Handle i_party failing opposed check
				{ "id": "on_fail", "action": "branch", "args": [["<results.pass>", "==", "1"], { "action": "goto", "args": ["id.return.next"] }] },
				{ "id": "null", "action": "inject", "args": ["effects.add", ["<i_party>", "<i_highest_s.0>", "/combat.initiate.surprise/", "listener.surprise_fail_penalty"]] },
				// Return results
				{ "id": "return", "action": "return", "args": ["<results>"] },
			],

			initiative: [
				["i_party", "d_party"],
				// Get the highest stealth skill from the initiating party 
				{ "id": "i_perception", "action": "read", "args": ["save_d", "<i_party>.*.stats.skill.perception.total"] },
				{ "id": "i_highest_p", "action": "reduce", "args": ["<a_perception>", ">="] },
				// Get the highest perception skill for the defending party
				{ "id": "d_perception", "action": "read", "args": ["save_d", "<d_party>.*.stats.skill.perception.total"] },
				{ "id": "d_highest_p", "action": "reduce", "args": ["<d_perception>", ">="] },
				// Emit events for triggers on surprise rolls
				{ "id": "event", "action": "event", "args": ["<i_party>.<i_highest_p.0>.perception.roll.initiative"] },
				{ "id": "event", "action": "event", "args": ["<d_party>.<d_highest_p.0>.perception.roll.initiative"] },
				// Make the opposing roll
				{
					"id": "results", "action": "inject", "args": ["dice.skill.oppose", [true,
						{ "party": "<i_party>", "idx": "<i_highest_p>", "keys": ["skill.perception"], "check": "+skill+perception+initiative" },
						{ "party": "<d_party>", "idx": "<d_highest_p>", "keys": ["skill.perception"], "check": "+skill+perception+initiative" }]]
				},
				// Return results
				{ "id": "return", "action": "return", "args": ["<results>"] },
			],
		},

		destruct: {
			process: [

			],

			is_finished: [
				// If enemy_party is empty then return encounter over true
				{ "id": "enemies", "action": "size", "args": ["save_d", "enemy_party"] },
				{ "id": "null", "action": "branch", "args": ["<enemies>", null, { "action": "return", "args": [true, "character"] }] },

				// If character_party is empty then return encounter over true
				{ "id": "characters", "action": "read", "args": ["save_d", "character_party"] },
				{ "id": "has_player", "action": "filter", "args": ["<characters.type>", "player", "~", "1:*"] },
				{ "id": "null", "action": "branch", "args": ["<has_player>", null, { "action": "return", "args": [true, "enemy"] }] },

				// Else check flee flag

				// Return false and no party
				{ "id": "null", "action": "return", "args": [false, "none"] }
			],

			save: [],
			delete: [],
			rewards: [],
		},

		round: {
			reset: [
				// Reset order_idx
				{ "id": "null", "action": "write", "args": ["save_d", "encounter.order.idx", 0] },
				// Reset character idx/turns
				{ "id": "null", "action": "write", "args": ["save_d", "character_idx", 0] },
				{ "id": "null", "action": "write", "args": ["save_d", "character_turns", []] },
				// Reset enemy idx/turns
				{ "id": "null", "action": "write", "args": ["save_d", "enemy_idx", 0] },
				{ "id": "null", "action": "write", "args": ["save_d", "enemy_turns", []] },
				// Event round start
				{ "id": "event", "action": "event", "args": ["encounter.round.start"] },
			],

			next: [
				// If the combat__data.party is reset then reset the party turn sets
				{ "id": "is_reset", "action": "branch", "args": [["<$p_idx>", ">=", 2], { "action": "inject", "args": ["combat.round.reset"] }] },
				// Is character party turn
				{ "id": "is_char", "action": "branch", "args": [["<$party>", "!=", "character_party"], { "action": "goto", "args": ["id.is_enemy.next"] }] },
				{ "id": "char_idx", "action": "inject", "args": ["combat.turn.character.choose.who"] },
				{ "id": "null", "action": "inject", "args": ["combat.turn.resolve", ["character", "<char_idx>"]] },
				// Is enemy party turn
				{ "id": "is_enemy", "action": "branch", "args": [["<$party>", "!=", "enemy_party"], { "action": "goto", "args": [] }] },
				{ "id": "enemy_idx", "action": "inject", "args": ["combat.turn.enemy.choose.who"] },
				{ "id": "null", "action": "inject", "args": ["combat.turn.resolve", ["enemy", "<enemy_idx>"]] },
				// Increment combat_idx if needed
				{ "id": "null", "action": "inject", "args": ["combat.round.increment"] }
			],

			increment: [
				{ "id": "p_size", "action": "size", "args": ["save_d", "<$party>_party"] },
				{ "id": "t_size", "action": "size", "args": ["save_d", "<$party>_turns"] },
				{ "id": "p_idx", "action": "branch", "args": [["<t_size>", ">=", "<p_size>"], { "action": "math", "args": ["<$p_idx>", "+", 1] }, { "action": "resolve", "args": ["<$p_idx>"] }] },
				{ "id": "null", "action": "write", "args": ["save_d", "encounter.order.idx", "<p_idx>"] },
			],
		},

		turn: {
			steps: {
				who: [
					// Choose character's turn
					{ "id": "char_names", "action": "read", "args": ["save_d", "character_party.*.name"] },
					{ "id": "char_turns", "action": "read", "args": ["save_d", "character_turns"] },
					{ "id": "char_left", "action": "remove", "args": ["<char_names>", "<char_turns>"] },

					// Choose from characters not in the character_turns list
					{ "id": "result", "action": "inject", "args": ["combat.turn.<$party>.choose.who", ["<char_left>"]] },
					{ "id": "character", "action": "filter", "args": ["<char_names>", "<choice.1>", "==", "1:*"] },

					// Save to state
					{ "id": "char_idx", "action": "write", "args": ["save_d", "character_idx", "<character.0>"] },
					{ "id": "char_turn", "action": "concat", "args": ["save_d", "enemy_turns", "<character.1>"] },
					{ "id": "null", "action": "return", "args": ["<character.0>"] },
				],

				action: {
					type: [
						{ "id": "type", "action": "inject", "args": ["combat.turn.<$party>.choose.action.type"] },
						// Get action type
						{ "id": "null", "action": "branch", "args": [["<choice.0>", "==", 2], { "action": "return", "args": { "type": false, "name": null } }] },
						{ "id": "type", "action": "resolve", "args": [["<choice.0>", "==", 0], "free", "standard"] },
						// Return action type
						{ "id": "null", "action": "return", "args": ["<type>"] },
					],

					get: [
						["char_idx", "type"],
						// Get actions 
						{ "id": "actions", "action": "keys", "args": ["save_d", "<$party>.<char_idx>.actions.combat.<type>"] },
						// Get action type id
						{ "id": "action", "action": "inject", "args": ["combat.turn.<$party>.choose.action.id", ["<char_left>"]] },
						// Load action and return
						{ "id": "action", "action": "read", "args": ["save_d", "<$party>.<char_idx>.actions.combat.<type>.<action.name>"] },
						{ "id": "null", "action": "return", "args": ["<action>"] },
					],
				},

				target: {
					entity: [
						["char_idx", "action"],
						// Get the action data for targeting party and single or multi target
						{ "id": "party_idx", "action": "math", "args": [["<action.target.party>", "+", "<$p_idx>"], "%", 2] },
						{ "id": "party_id", "action": "read", "args": ["save_d", "encounter.order.parties.<party_idx>"] },
						{ "id": "p_chars", "action": "read", "args": ["save_d", "<party_id>"] },
						// Format lists to choose from for party chars
						{ "id": "names", "action": "math", "args": ["<p_chars>", ".", "name"] },
						{ "id": "idx_range", "action": "range", "args": ["<p_chars>"] },
						// If is multi targeting then skip target logic and return list of party
						{ "id": "is_multi", "action": "branch", "args": [["<action.target.count>", "==", -1], { "action": "return", "args": [{ "party": "<party_id>", "chars": "<idx_range>" }] }] },
						// If is self targeting then skip target logic and return own char_idx
						{ "id": "is_self", "action": "branch", "args": [["<action.target.count>", "==", 0], { "action": "return", "args": [{ "party": "<party_id>", "chars": ["<char_idx>"] }] }] },
						// Else run targeting logic
						{ "id": "p_chars", "action": "concat", "args": ["<p_chars>", "back"] },
						{ "id": "target", "action": "inject", "args": ["combat.turn.<$party>.choose.target.entity", ["<action.name>", "<names>"]] },
						{ "id": "null", "action": "return", "args": [{ "party": "<party_id>", "chars": ["<target.0>"] }] },
					],

					body_part: [
						["char_idx", "action", "target"],
						// If it is not a physical attack return
						{ "id": "is_physical", "action": "branch", "args": [["<action.check>", "!=", "physical"], { "action": "return", "args": [-1] }] },
						// Look up targets body type info
						{ "id": "body_type", "action": "read", "args": ["save_d", "<target.party>.<target.chars.0>.body"] },
						{ "id": "weak_spot", "action": "read", "args": ["save_d", "<target.party>.<target.chars.0>.biography.body.weak_spot"] },

						// Is a targeted body part attack?
						{ "id": "is_aimed", "action": "inject", "args": ["combat.turn.<$party>.choose.target.is_aim", ["<action>"]] },

						// Handle if it is a random body part
						{ "id": "is_random", "action": "branch", "args": [["<is_aimed>", "==", 1], { "action": "goto", "args": ["id.is_aimed.next"] }] },
						{ "id": "body_part", "action": "read", "args": ["dice.roll_against_table", ["game_d", "tables.bodies.distribution.<body_type>"]] },
						{ "id": "body_part", "action": "resolve", "args": [{ "type": "<body_type>", "part": "<body_part>", "weaK": "<weak_spot>" }] },
						{ "id": "null", "action": "goto", "args": ["id.return.next"] },

						// Handle if it is a targeted body part
						{ "id": "is_aimed", "action": "branch", "args": [["<is_aimed>", "==", 0], { "action": "goto", "args": ["id.return.next"] }] },
						{ "id": "body_parts", "action": "read", "args": ["game_d", "tables.bodies.unique.<body_type>"] },
						{ "id": "body_part", "action": "inject", "args": ["combat.turn.<$party>.choose.target.body_part", ["<body_type>", "<weak_spot>", "<body_parts>"]] },
						{ "id": "body_part", "action": "resolve", "args": [{ "type": "<body_type>", "part": "<body_part>", "weaK": "<weak_spot>" }] },
						{ "id": "null", "action": "inject", "args": ["effects.add", ["<$party>", "<char_idx>", "targeted_attack", "listener.target_attack_penalty"]] },

						{ "id": "return", "action": "return", "args": ["<body_part>"] },
					],
				},
			},

			character: {
				choose: {
					who: [
						["options"],
						// Choose from characters not in the character_turns list
						{ "id": "choice", "action": "choice", "args": ["Whose turn is it?", "<options>"] },
						{ "id": "null", "action": "return", "args": ["<choice>"] },
					],

					action: {
						type: [
							{ "id": "choice", "action": "choice", "args": ["What type of action will <name> take?", ["free", "standard", "end"]] },
							{ "id": "null", "action": "return", "args": ["<choice.1>"] },
						],

						id: [
							["actions"],
							// Add back option
							{ "id": "actions", "action": "concat", "args": ["<actions>", "back"] },
							// Get action type id
							{ "id": "choice", "action": "choice", "args": ["Which <type> action?", "<actions>"] },
							{ "id": "null", "action": "return", "args": ["<choice.1>"] },
						],
					},

					target: {
						entity: [
							["name", "targets"],
							{ "id": "p_chars", "action": "concat", "args": ["<p_chars>", "back"] },
							{ "id": "choice", "action": "choice", "args": ["<name> targets?", "<targets>"] },
							{ "id": "null", "action": "return", "args": ["<choice.1>"] },
						],

						is_aim: [
							["action"],
							{ "id": "choice", "action": "choice", "args": ["Is <action.name> targeting a body part(-30 combat roll)?", "No (Random)", "Yes (Targeted)"] },
							{ "id": "null", "action": "return", "args": ["<choice.1>"] },
						],

						body_part: [
							["body_type", "weak_spot", "<body_parts>"],
							{ "id": "choice", "action": "choice", "args": ["For body: <body_type> with weak_spot: <weak_spot> target?", "<body_parts>"] },
							{ "id": "return", "action": "return", "args": ["<choice>"] },
						],
					},

					reaction: [
						["party", "char_idx", "type", "filters"],
						{ "id": "reactions", "action": "keys", "args": ["save_d", "<party>.<char_idx>.combat.reactions.actions"] },
						{ "id": "reactions", "action": "remove", "args": ["<reactions>", "<filters>"] },
						{ "id": "choice", "action": "choice", "args": ["What reaction will you take?", "<reactions>"] },
						{ "id": "skill", "action": "get", "args": ["<reactions>", "<choice>"] },
						{ "id": "return", "action": "return", "args": ["<skill>"] },
					],

					defensive_maneuver: [
						["party", "char_path"],
						{ "id": "result", "action": "inject", "args": ["dice.roll_against_table", ["game_d", "tables.defensive_maneuvers"]] },
						{ "id": "dummy", "action": "log", "args": ["<result.1.desc>"] },
						{ "id": "rule", "action": "branch", "args": [["<result.1.rule>", "!=", null], { "action": "format", "args": ["<result.1.rule>", "<char_path>"] }, null] },
						{ "id": "dummy", "action": "branch", "args": [["<rule>", "!=", null], { "action": "inject", "args": ["<rule>"] }, null] },
					],
				},
			},

			enemy: {
				choose: {
					who: [
						// Choose character's turn
						{ "id": "char_names", "action": "read", "args": ["save_d", "enemy_party.*.name"] },
						{ "id": "char_turns", "action": "read", "args": ["save_d", "enemy_party"] },
						{ "id": "char_left", "action": "remove", "args": ["<char_names>", "<char_turns>"] },

						// Choose from characters not in the character_turns list
						{ "id": "character", "action": "filter", "args": ["<char_names>", "<char_left.0>", "==", "1:*"] },

						// Save to state
						{ "id": "char_idx", "action": "write", "args": ["save_d", "enemy_idx", "<character.0>"] },
						{ "id": "char_turn", "action": "concat", "args": ["save_d", "enemy_turns", "<character.1>"] },
						{ "id": "null", "action": "return", "args": ["<character.0>"] },
					],

					action: [
						["char_idx"],
						{ "id": "action_id", "action": "inject", "args": ["dice.roll_against_table", ["save_d", "<$party>.<char_idx>.biography.distribution"]] },
						{ "id": "null", "action": "return", "args": [{ "type": "standard", "name": "<action_id.1>" }] },
					],

					target: [
						["char_idx", "action"],
						// Get the action data for targeting party and single or multi target
						{ "id": "party_idx", "action": "math", "args": [["<action.target.party>", "+", "<$p_idx>"], "%", 2] },
						{ "id": "party_id", "action": "math", "args": ["save_d", "encounter.order.parties.<party_idx>"] },
						{ "id": "p_chars", "action": "read", "args": ["save_d", "<party_id>"] },
						// Format lists to choose from for party chars
						{ "id": "names", "action": "math", "args": ["<p_chars>", ".", "name"] },
						{ "id": "idx_range", "action": "range", "args": ["<p_chars>"] },
						// If is multi targeting then skip target logic and return list of party
						{ "id": "is_multi", "action": "branch", "args": [["<action.target.count>", "==", -1], { "action": "return", "args": [{ "party": "<party_id>", "chars": "<idx_range>" }] }] },
						// If is self targeting then skip target logic and return own char_idx
						{ "id": "is_self", "action": "branch", "args": [["<action.target.count>", "==", 0], { "action": "return", "args": [{ "party": "<party_id>", "chars": ["<char_idx>"] }] }] },
						// Else run targeting logic
						{ "id": "target", "action": "inject", "args": ["dice.roll_against_table", ["save_d", "<party_id>"]] },
						{ "id": "null", "action": "return", "args": [{ "party": "<party_id>", "chars": ["<target.0>"] }] },
					],

					body_part: [
						["char_idx", "action", "target"],
						{ "id": "action", "action": "read", "args": ["save_d", "<$party>.<char_idx>.actions.combat.<action.type>.<action.name>"] },
						// If it is not a physical attack return
						{ "id": "is_physical", "action": "branch", "args": [["<action.check>", "!=", "physical"], { "action": "return", "args": [-1] }] },
						// Look up targets body type info
						{ "id": "body_type", "action": "read", "args": ["save_d", "<target.party>.<target.chars.0>.body"] },
						{ "id": "weak_spot", "action": "read", "args": ["save_d", "<target.party>.<target.chars.0>.biography.weak_spot"] },
						// Is a targeted body part attack? 
						// ToDo add logic to check if it has a defensive move to get +30 and go for a crit
						{ "id": "aimed", "action": "resolve", "args": [0] },

						// Handle if it is a random body part
						{ "id": "is_random", "action": "branch", "args": [["<is_aimed>", "==", 1], { "action": "goto", "args": ["id.is_aimed.next"] }] },
						{ "id": "body_part", "action": "read", "args": ["dice.roll_against_table", ["game_d", "tables.bodies.distribution.<body_type>"]] },
						{ "id": "body_part", "action": "resolve", "args": [{ "type": "<body_type>", "part": "<body_part>", "weaK": "<weak_spot>" }] },
						{ "id": "null", "action": "goto", "args": ["id.return.next"] },

						// Handle if it is a targeted body part
						{ "id": "is_aimed", "action": "branch", "args": [["<is_aimed>", "==", 0], { "action": "goto", "args": ["id.return.next"] }] },
						{ "id": "body_parts", "action": "read", "args": ["game_d", "tables.bodies.unique.<body_type>"] },
						{ "id": "body_part", "action": "choice", "args": ["For body: <body_type> with weak_spot: <weak_spot> target?", "<body_parts>"] },
						{ "id": "body_part", "action": "resolve", "args": [{ "type": "<body_type>", "part": "<body_part>", "weaK": "<weak_spot>" }] },
						{ "id": "null", "action": "inject", "args": ["effects.add", ["<$party>", "<char_idx>", "targeted_attack", "listener.target_attack_penalty"]] },

						{ "id": "return", "action": "return", "args": ["<body_part>"] },
					],

					reaction: [],

					defensive_move: [],
				},
			},

			resolve: [
				["type", "char_idx"],
				// Event turn start
				{ "id": "event", "action": "event", "args": ["<$party>.<char_idx>.combat.turn.start"] },
				// Get character data
				{ "id": "name", "action": "read", "args": ["save_d", "<$party>.<char_idx>.name"] },
				// Add listener for decrementing action counters
				{ "id": "null", "action": "inject", "args": ["effects.add", ["<$party>", "<char_idx>", "turn", "listener.standard_action"]] },
				{ "id": "null", "action": "inject", "args": ["effects.add", ["<$party>", "<char_idx>", "turn", "listener.free_action"]] },
				{ "id": "null", "action": "inject", "args": ["effects.add", ["<$party>", "<char_idx>", "turn", "listener.re_action"]] },
				// The start of the loop to go through all character actions
				{ "id": "loop_start", "action": "resolve", "args": [true] },
				// Get the current count for free and standard actions
				{ "id": "standard", "action": "inject", "args": ["character.attributes.stats.get.total", "<$party>", "<char_idx>", "actions", "standard"] },
				{ "id": "free", "action": "inject", "args": ["character.attributes.stats.get.total", "<$party>", "<char_idx>", "actions", "free"] },
				// Display action info and choices
				{ "id": "null", "action": "log", "args": ["<name> has free: <free>, standard: <standard>, actions left."] },
				// The exit condition ran out of actions
				{ "id": "null", "action": "branch", "args": [[["<free>", "+", "<standard>"], "<=", 0], { "action": "goto", "args": ["id.event.next"] }] },

				// Make action type choice 
				{ "id": "type", "action": "inject", "args": ["combat.turn.steps.action.type"] },
				// Chose to end turn
				{ "id": "null", "action": "branch", "args": [["<type>", "==", "end"], { "action": "return" }] },

				// Choose the action of type
				{ "id": "action", "action": "inject", "args": ["combat.turn.steps.action.get", ["<char_idx>", "<type.1>"]] },
				// Chose to go back aka restart choice
				{ "id": "null", "action": "branch", "args": [["<action.name>", "==", "back"], { "action": "goto", "args": ["id.type.prev"] }] },

				// Choose action target entity
				{ "id": "targets", "action": "inject", "args": ["combat.turn.steps.target.entity", ["<char_idx>", "<action>"]] },
				// Chose to go back aka restart choice
				{ "id": "null", "action": "branch", "args": [["<targets.1>", "==", "back"], { "action": "goto", "args": ["id.action.prev"] }] },

				// If it is a physical attack then go through body targeting logic
				{ "id": "is_physical", "action": "branch", "args": [["<action.check>", "!=", "physical"], { "action": "goto", "args": [-1] }] },
				// Choose action target body part
				{ "id": "body", "action": "inject", "args": ["combat.turn.steps.choose.body_part", ["<char_idx>", "<action>", "<targets>"]] },
				// Choose to go back aka restart choice
				{ "id": "null", "action": "branch", "args": [["<targets.1>", "==", "back"], { "action": "goto", "args": ["id.action.prev"] }] },

				// Log action choices
				{ "id": "null", "action": "log", "args": ["<name> uses: <action.name> (<action.type>) on: <targets.chars>."] },
				// Check if action passes to be applied
				{ "id": "null", "action": "inject", "args": ["combat.turn.action.inject", ["<char_idx>", "<action>", "<targets>", "<body>"]] },
				// Loop back to id.loop_start.start
				{ "id": "null", "action": "goto", "args": ["id.loop_start.start"] },
				// Event turn end
				{ "id": "event", "action": "event", "args": ["<$party>.<char_idx>.combat.turn.end"] },
			],

			action: {
				inject: [
					["char_idx", "action", "targets", "body"],
					// Log action choices
					{ "id": "name", "action": "read", "args": ["save_d", "<$party>.<char_idx>.name"] },
					{ "id": "null", "action": "log", "args": ["<name> uses: <action.name> (<action.type>) on: <targets.chars>."] },
					// Check if action passes to be applied
					{ "id": "initiator", "action": "resolve", "args": [{ "party": "<$party>", "idx": "<char_idx>" }] },
					{ "id": "null", "action": "loop", "args": ["combat.turn.character.action.resolve", "<targets>", ["<char_idx>", "<action>", "$idx$", "<body>"]] },
				],

				resolve: [
					["char_idx", "action", "target_party", "target_idx", "body_part"],
					// Resolve a physical action
					{ "id": "physical", "action": "branch", "args": [["<action.check.type>", "==", "oppose"], null, { "action": "goto", "args": ["id.magical.next"] }] },
					// A stub for the event response to inject a value into
					{ "id": "reaction", "action": "resolve", "args": [{ "skills": ["combat.parry"], "vantage": "+combat+parry" }] },
					{ "id": "null", "action": "event", "args": ["<target_party>.<target_idx>.combat.reaction", "reaction"] },
					// Make the opposing roll
					{
						"id": "roll_results", "action": "inject", "args": ["dice.skill.oppose", [false,
							{ "party": "<$party>", "idx": "<char_idx>", "keys": "<action.check.skills>", "check": "<action.check.vantage>" },
							{ "party": "<target_party>", "idx": "<target_idx>", "keys": "<reaction.check.skills>", "check": "<reaction.check.vantage>" }]]
					},

					// Resolve a magical action
					{ "id": "magical", "action": "branch", "args": [["<action.check>", "==", "magical"], null, { "action": "goto", "args": ["id.none.next"] }] },
					// Vantage is the only way to influence magic rolls as an initiator
					{ "id": "i_vantage", "action": "inject", "args": ["character.attributes.checks.get", ["<$party>.<char_idx>", "vantage", "<check>"]] },
					// If initiator has a vantage then apply it to the defender vantage
					{ "id": "null", "action": "branch", "args": [["<i_vantage>", "==", 0], { "action": "goto", "args": ["id.results.next"] }] },
					{ "id": "i_vantage", "action": "ifelse", "args": [["<i_vantage>", "==", 1], "+", "-"] },
					{ "id": "null", "action": "inject", "args": ["effects.add", ["<target_party>", "<target_idx>", "attacker_vantage", "skill.magic_resist.<i_vantage>"]] },
					// Make the skill check roll
					{
						"id": "roll_results", "action": "inject", "args": ["dice.skill.check", [
							{ "party": "<target_party>", "idx": "<target_idx>", "keys": ["skill.magic_resist"], "check": "skill+magic_resist" }]]
					},
					{ "id": "roll_results", "action": "inject", "args": ["dice.skill.models.inflate.magic_to_oppose", ["<$party>", "<char_idx>", "<roll_results>"]] },
					// If initiator has a vantage then remove it to the defender vantage
					{ "id": "null", "action": "branch", "args": [["<i_vantage>", "!=", 0], { "action": "inject", "args": ["effects.delete", ["<target_party>", "<target_idx>", "attacker_vantage", "skill.magic_resist.<i_vantage>"]] }] },

					// Resolve an action that requires no check, (ex: Healing a party member)
					{ "id": "none", "action": "branch", "args": [["<action.check>", "==", "none"], null, { "action": "goto", "args": ["id.return.next"] }] },
					{ "id": "roll_results", "action": "inject", "args": ["dice.skill.models.inflate.none_to_oppose", ["<$party>", "<char_idx>", "<target_party>", "<target_idx>"]] },

					// If initiator passes then trigger the action
					{ "id": "i_action", "action": "branch", "args": [["<roll_results.pass>", "==", "1"], null, { "action": "goto", "args": ["id.d_action.next"] }] },
					{ "id": "action_args", "action": "var_sub", "args": [0, "<action.rule.1>"] },
					{ "id": "null", "action": "inject", "args": ["<action.rule.0>", "<action_args>"] },

					// If defender passes an oppose check then event for a defensive maneuver
					{ "id": "d_action", "action": "branch", "args": [[["<roll_results.pass>", "==", "2"], "&", ["<action.check.type>", "==", "oppose"]], null, { "action": "goto", "args": ["id.return.next"] }] },
					{ "id": "null", "action": "event", "args": ["<target_party>.<target_idx>.combat.defensive.maneuver"] },

					{ "id": "return", "action": "return", "args": [] },
				],
			},
		},

		enemies: {
			generate: [
				["enemy_id", "encounter_key"],
				{ "id": "count", "action": "read", "args": ["game_d", "encounters.<enemy_id>.biography.number"] },
				{ "id": "count", "action": "range", "args": ["<count>"] },
				{ "id": "null", "action": "loop", "args": ["combat.enemies.add", "<count>", ["<enemy_id>", "$idx$"]] },
				{ "id": "null", "action": "return", "args": ["<count>"] },
			],

			add: [
				["enemy_id", "key"],
				{ "id": "enemy", "action": "copy", "args": ["game_d", "models.character"] },
				{ "id": "enemy", "action": "concat", "args": ["save_d", "enemy_party", "<enemy>"] },
				{ "id": "entries", "action": "copy", "args": ["game_d", "encounters.<type>.<enemy_id>"] },
				{ "id": "entries", "action": "entries", "args": ["<entries>"] },
				{ "id": "size", "action": "size", "args": ["<entries>"] },
				// Create iter
				{ "id": "iter", "action": "resolve", "args": [-1] },
				{ "id": "iter", "action": "math", "args": ["<iter>", "+", 1] },
				// Update the entries of the enemy with its data values
				{ "id": "entry", "action": "get", "args": ["<entries>", "<iter>"] },
				{ "id": "enemy", "action": "set_at", "args": ["save_d", "enemy_party.<enemy.idx>.<entry.0>", "<entry.1>"] },
				{ "id": "null", "action": "inject", "args": ["effects.add", ["enemy_party", "<enemy.idx>", "death", "listener.death_check"]] },
				{ "id": "null", "action": "branch", "args": [["<iter>", "<", "<size>"], { "action": "goto", "args": ["id.iter.prev"] }] },
			],

			reset: [
				["party", "idx", "enemy"],
				{ "id": "max_hp", "action": "inject", "args": ["character.attributes.stats.get.total", ["<party>", "<idx>", "base", "health"]] },
				{ "id": "null", "action": "inject", "args": ["character.attributes.stats.points.minus", ["<party>", "<idx>", "base", "health", "<all_dealt>"]] },
			],

			load: [
				["flag"],
				{ "id": "count", "action": "size", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.data.<flag>.enemies"] },
				{ "id": "enemies", "action": "read", "args": ["save_d", "domains.<$d_idx>.map.<$y>.<$x>.data.<flag>.enemies"] },
				{ "id": "null", "action": "write", "args": ["save_d", "enemy_party", "<enemies>"] },
				// ToDo put in logic to reset enemy health and conditions if camped between combat

				{ "id": "null", "action": "return", "args": ["<count>"] },
			],

			delete: [],
		},
	},

	// ------------------------------------------------------------------------------------------------------- Dice
	dice: {
		rolls: {
			re_roll: [
				["value"],
				{ "id": "null", "action": "goto", "args": ["<parent_process>", "<value>"] },
				{ "id": "null", "action": "log", "args": ["------- Re-Rolling -------"] }
			],

			set_roll: [
				["value", "new_roll", "max"],
				{ "id": "idx", "action": "goto", "args": ["<parent_process>", "<value>"] },
				{ "id": "roll", "action": "clamp", "args": ["<new_roll>", 0, "<max>"] },
				{ "id": "roll_p", "action": "math", "args": ["<roll>", "+", 1] },
				{ "id": "null", "action": "step_result", "args": ["<parent_process>", "<idx>", "<roll>"] },
				{ "id": "null", "action": "log", "args": [`------- Roll set to: <roll_p> -------`] }
			],

			set_vantage_roll: [
				["values", "new_roll", "max"],
				// The roll to set to
				{ "id": "roll", "action": "clamp", "args": ["<new_roll>", 0, "<max>"] },
				{ "id": "roll_p", "action": "math", "args": ["<roll>", "+", 1] },
				// Set up iterator for values
				{ "id": "count", "action": "size", "args": ["<values>"] },
				{ "id": "iter", "action": "resolve", "args": [[-1, "<count>"]] },
				// Increment iterator
				{ "id": "incr", "action": "math", "args": ["<iter.0>", "+", 1] },
				{ "id": "iter", "action": "set", "args": ["<iter>", 0, "<incr>"] },
				// Basic until loop to set all the rolls (must start with the first and work forward)
				{ "id": "value", "action": "get", "args": ["<values>", "<iter.0>"] },
				{ "id": "idx", "action": "goto", "args": ["<parent_process>", "<value>"] },
				{ "id": "null", "action": "step_result", "args": ["<parent_process>", "<idx>", "<roll>"] },
				// Determine if all the values have been processed
				{ "id": "null", "action": "branch", "args": [["<iter.0>", "<", "<iter.1>"], { "action": "goto", "args": ["id.incr.prev"] }] },
				{ "id": "null", "action": "log", "args": [`------- Roll set to: <roll_p> -------`] }
			],

			roll: [
				["die", "desc"],
				{ "id": "roll", "action": "roll", "args": ["<die>"] },
				{ "id": "roll_p", "action": "math", "args": ["<roll>", "+", 1] },
				{ "id": "confirm", "action": "confirm", "args": ["Rolled a (<roll_p>/<die>) for <desc>.", ["Next", true], ["Set", "dice.rolls.set_roll", "action.roll.prev", "<die>"], ["Reroll", "dice.rolls.re_roll", "action.roll.prev"]] },
				{ "id": "return", "action": "return", "args": ["<roll>"] },
			],

			save_roll: [
				["die", "desc", "path"],
				{ "id": "roll", "action": "roll", "args": ["<die>"] },
				{ "id": "roll_p", "action": "math", "args": ["<roll>", "+", 1] },
				{ "id": "confirm", "action": "confirm", "args": ["Rolled a (<roll_p>/<die>) for <desc>.", ["Next", true], ["Set", "dice.rolls.set_roll", "action.roll.prev", "<die>"], ["Reroll", "dice.rolls.re_roll", "action.roll.prev"]] },
				{ "id": "save", "action": "write", "args": ["save_d", "<path>", "<lookup>"] },
				{ "id": "return", "action": "return", "args": ["<lookup>"] },
			],

			roll_plus_one: [
				["die", "desc"],
				{ "id": "roll", "action": "roll", "args": ["<die>"] },
				{ "id": "roll_p", "action": "math", "args": ["<roll>", "+", 1] },
				{ "id": "confirm", "action": "confirm", "args": ["Rolled a (<roll_p>/<die>) for <desc>.", ["Next", true], ["Set", "dice.rolls.set_roll", "action.roll.prev", "<die>"], ["Reroll", "dice.rolls.re_roll", "action.roll.prev"]] },
				{ "id": "return", "action": "return", "args": ["<roll_p>"] },
			],

			save_roll_plus_one: [
				["die", "desc", "path"],
				{ "id": "roll", "action": "roll", "args": ["<die>"] },
				{ "id": "roll_p", "action": "math", "args": ["<roll>", "+", 1] },
				{ "id": "confirm", "action": "confirm", "args": ["Rolled a (<roll_p>/<die>) for <desc>.", ["Next", true], ["Set", "dice.rolls.set_roll", "action.roll.prev", "<die>"], ["Reroll", "dice.rolls.re_roll", "action.roll.prev"]] },
				{ "id": "save", "action": "write", "args": ["save_d", "<path>", "<roll_p>"] },
				{ "id": "return", "action": "return", "args": ["<roll_p>"] },
			],

			roll_against_table: [
				["data_set", "path"],
				{ "id": "size", "action": "size", "args": ["<data_set>", "<path>"] },
				{ "id": "roll", "action": "roll", "args": ["<size>"] },
				{ "id": "lookup", "action": "lookup", "args": ["<data_set>", "<path>", "<roll>"] },
				{ "id": "roll_p", "action": "math", "args": ["<roll>", "+", 1] },
				{ "id": "confirm", "action": "confirm", "args": ["Rolled a (<roll_p>/d<size>) on Table(<path>): <lookup>.", ["Next", true], ["Set", "dice.rolls.set_roll", "action.roll.prev", "<size>"], ["Reroll", "dice.rolls.re_roll", "action.roll.prev"]] },
				{ "id": "return", "action": "return", "args": [["<roll>", "<lookup>"]] },
			],

			lookup_against_table: [
				["path", "roll"],
				{ "id": "lookup", "action": "lookup", "args": ["game_d", "<path>", "<roll>"] },
				{ "id": "confirm", "action": "notify", "args": ["Table(<path>) resolves to: <lookup>."] },
				{ "id": "return", "action": "return", "args": ["<lookup>"] },
			],

			save_roll_against_table: [
				["table", "path"],
				{ "id": "size", "action": "size", "args": ["game_d", "<table>"] },
				{ "id": "roll", "action": "roll", "args": ["<size>"] },
				{ "id": "lookup", "action": "lookup", "args": ["game_d", "<table>", "<roll>"] },
				{ "id": "roll_p", "action": "math", "args": ["<roll>", "+", 1] },
				{ "id": "confirm", "action": "confirm", "args": ["Rolled a (<roll_p>/d<size>) on Table(<table>): <lookup>", ["Next", true], ["Set", "dice.rolls.set_roll", "action.roll.prev", "<size>"], ["Reroll", "dice.rolls.re_roll", "action.roll.prev"]] },
				{ "id": "save", "action": "write", "args": ["save_d", "<path>", "<lookup>"] },
				{ "id": "return", "action": "return", "args": ["<lookup>"] },
			],
		},

		usage: {
			check: [
				["die_path", "desc", "injectable", "resetable"],
				{ "id": "die", "action": "read", "args": ["save_d", "<die_path>"] },
				{ "id": "roll", "action": "roll", "args": ["<die.0>"] },
				{ "id": "roll_p", "action": "math", "args": ["<roll>", "+", 1] },
				{ "id": "confirm", "action": "confirm", "args": ["Rolled a (<roll_p>/d<die.0>) on <desc>:(<=2 fail).", ["Next", true], ["Set", "dice.rolls.set_roll", "action.roll.prev", "<die.0>"], ["Reroll", "dice.rolls.re_roll", "action.roll.prev"]] },
				{ "id": "die", "action": "branch", "args": [["<roll>", "<", 2], { "action": "inject", "args": ["dice.usage.fail", ["<die>", "<die_path>", 2]] }, { "action": "resolve", "args": ["<die>"] }] },
				{ "id": "event", "action": "branch", "args": [["<die.0>", "<", 4], { "action": "inject", "args": ["<injectable>"] }, null] },
				{ "id": "die", "action": "branch", "args": [[["<die.0>", "<", 4], "&", "<resetable>"], { "action": "inject", "args": ["dice.usage.reset", ["<die_path>"]] }, { "action": "resolve", "args": ["<die>"] }] },
				{ "id": "return", "action": "return", "args": ["<die>"] },
			],

			reduce: [
				["die_path", "desc", "injectable", "resetable", "by"],
				{ "id": "die", "action": "read", "args": ["save_d", "<die_path>"] },
				{ "id": "die", "action": "inject", "args": ["dice.usage.fail", ["<die>", "<die_path>", "<by>"]] },
				{ "id": "event", "action": "branch", "args": [["<die.0>", "<", 4], { "action": "inject", "args": ["<injectable>"] }, null] },
				{ "id": "die", "action": "branch", "args": [[["<die.0>", "<", 4], "&", "<resetable>"], { "action": "inject", "args": ["dice.usage.reset", ["<die_path>"]] }, { "action": "resolve", "args": ["<die>"] }] },
				{ "id": "return", "action": "return", "args": ["<die>"] },
			],

			fail: [
				["die", "die_path", "by"],
				{ "id": "die", "action": "resolve", "args": ["<die>"] },
				{ "id": "die_0", "action": "math", "args": ["<die.0>", "-", "<by>"] },
				{ "id": "n_die", "action": "write", "args": ["save_d", "<die_path>", ["<die_0>", "<die.1>"]] },
				{ "id": "die_name", "action": "at", "args": ["<die_path>", -1] },
				{ "id": "notify", "action": "notify", "args": ["Reduced <die_name> die to a d<die_0>."] },
				{ "id": "return", "action": "return", "args": ["<n_die>"] },
			],

			reset: [
				["die_path"],
				{ "id": "die", "action": "read", "args": ["save_d", "<die_path>"] },
				{ "id": "write", "action": "write", "args": ["save_d", "<die_path>", ["<die.1>", "<die.1>"]] },
				{ "id": "die_name", "action": "at", "args": ["<die_path>", -1] },
				{ "id": "notify", "action": "notify", "args": ["Reset <die_name> die to a d<die.1>."] },
			],
		},

		skill: {
			roll: [
				["die", "desc", "vantage", "threshold"],
				// Roll 2 die
				{ "id": "roll_1", "action": "roll", "args": ["<die>"] },
				{ "id": "roll_2", "action": "roll", "args": ["<die>"] },
				{ "id": "roll_1p", "action": "math", "args": ["<roll_1>", "+", 1] },
				{ "id": "roll_2p", "action": "math", "args": ["<roll_2>", "+", 1] },
				// Determine if rolls pass and are critical
				{ "id": "r1_crit", "action": "palindrome", "args": ["<roll_1p>"] },
				{ "id": "r2_crit", "action": "palindrome", "args": ["<roll_2p>"] },
				{ "id": "r1_pass", "action": "math", "args": ["<roll_1p>", "<=", "<threshold>"] },
				{ "id": "r2_pass", "action": "math", "args": ["<roll_2p>", "<=", "<threshold>"] },
				{ "id": "lowest", "action": "ifelse", "args": [["<roll_1p>", "<", "<roll_2p>"], "<roll_1p>", "<roll_2p>"] },
				{ "id": "highest", "action": "ifelse", "args": [["<roll_1p>", ">", "<roll_2p>"], "<roll_1p>", "<roll_2p>"] },
				// Process logic for advantage roll
				{ "id": "advantage", "action": "branch", "args": [["<vantage>", "<", 1], { "action": "goto", "args": ["id.disadvantage.next"] }] },
				{ "id": "is_roll1", "action": "math", "args": [["<r1_pass>"], "&", [["<r2_pass>", "==", false], "|", [["<roll_p1>", "==", "<highest>"], "&", [["<r2_crit>", "==", false], "|", "<r1_crit>"]]]] },
				{
					"id": "result", "action": "branch", "args": [["<is_roll1>", "|", [["<r2_pass>", "==", false], "&"["<roll_p1>", "==", "<lowest>"]]],
					{ "action": "inject", "args": ["dice.skill.model.roll", ["<threshold>", "<roll_1p>", "<r1_crit>", "<r1_pass>"]] },
					{ "action": "inject", "args": ["dice.skill.model.roll", ["<threshold>", "<roll_2p>", "<r2_crit>", "<r2_pass>"]] }]
				},
				// Process logic for disadvantage
				{ "id": "disadvantage", "action": "branch", "args": [["<vantage>", ">", -1], { "action": "goto", "args": ["id.neutral.next"] }] },
				{ "id": "is_roll1", "action": "math", "args": [["<r1_pass>", "==", false], "|", [["<r2_pass>"], "&", [["<roll_p1>", "==", "<lowest>"], "&", [["<r1_crit>", "==", false], "|", "<r2_crit>"]]]] },
				{
					"id": "result", "action": "branch", "args": [["<is_roll1>", "|", ["<r2_pass>", "&"["<roll_p1>", "==", "<highest>"]]],
					{ "action": "inject", "args": ["dice.skill.model.roll", ["<threshold>", "<roll_1p>", "<r1_crit>", "<r1_pass>"]] },
					{ "action": "inject", "args": ["dice.skill.model.roll", ["<threshold>", "<roll_2p>", "<r2_crit>", "<r2_pass>"]] }]
				},
				// Process logic for neutral
				{ "id": "neutral", "action": "branch", "args": [["<vantage>", "!=", 0], { "action": "goto", "args": ["id.confirm.next"] }] },
				{ "id": "result", "action": "inject", "args": ["dice.skill.model.roll", ["<threshold>", "<roll_1p>", "<r1_crit>", "<r1_pass>"]] },
				// Determine sentence prefix
				{ "id": "prefix", "action": "resolve", "args": ["Roll: (<roll_1p>/<die>)"] },
				{ "id": "prefix", "action": "ifelse", "args": [["<vantage>", "==", 1], "Advantaged roll: ([<roll_1p>, <roll_2p>]/<die>)", "<prefix>"] },
				{ "id": "prefix", "action": "ifelse", "args": [["<vantage>", "==", -1], "Disadvantaged roll: ([<roll_1p>, <roll_2p>]/<die>)", "<prefix>"] },
				// Send the result to the user to confirm results
				{ "id": "confirm", "action": "confirm", "args": ["<prefix> result: <result.pass> (<result.roll>/<result.threshold>) for <desc>.", ["Next", true], ["Set", "dice.rolls.set_vantage_roll", ["id.roll_1.start", "id.roll_2.next"], "<die>"], ["Reroll", "dice.rolls.re_roll", "id.roll_1.start"]] },
				{ "id": "return", "action": "return", "args": ["<result>"] },
			],

			resolve: [
				["i", "d"],
				// Initiator check
				{
					"id": "passing_roll", "action": "branch", "args": [
						["<i.roll.pass>", "&", ["<d.roll.pass>", "==", false]], "|", [
							["<i.roll.pass>", "^", "<d.roll.pass>"], "&", [
								[["<i.roll.roll>", ">", "<d.roll.roll>"], "&", ["<d.roll.crit>", "==", false]],
								"|",
								[["<i.roll.roll>", "==", "<d.roll.roll>"], "&", ["<i.roll.threshold>", ">=", "<d.roll.threshold>"]],
								"|",
								[["<i.roll.roll>", "<", "<d.roll.roll>"], "&", ["<i.roll.crit>", "&", ["<d.roll.crit>", "==", false]]]
							]
						],
						{ "action": "resolve", "args": ["1"] }, { "action": "resolve", "args": ["0"] }]
				},
				// Defender check
				{
					"id": "passing_roll", "action": "branch", "args": [
						["<d.roll.pass>", "&", ["<i.roll.pass>", "==", false]], "|", [
							["<d.roll.pass>", "^", "<i.roll.pass>"], "&", [
								[["<d.roll.roll>", ">", "<i.roll.roll>"], "&", ["<i.roll.crit>", "==", false]],
								"|",
								[["<d.roll.roll>", "==", "<i.roll.roll>"], "&", ["<d.roll.threshold>", ">=", "<i.roll.threshold>"]],
								"|",
								[["<d.roll.roll>", "<", "<i.roll.roll>"], "&", ["<d.roll.crit>", "&", ["<i.roll.crit>", "==", false]]]
							]
						],
						{ "action": "resolve", "args": ["2"] }, { "action": "resolve", "args": ["<passing_roll>"] }]
				},
				// Determine failing roll from passing roll
				{ "id": "failing_roll", "action": "ifelse", "args": [["<passing_roll>", "==", "1"], "2", "0"] },
				{ "id": "failing_roll", "action": "ifelse", "args": [["<passing_roll>", "==", "2"], "1", "<failing_roll>"] },
				// Format and return results
				{ "id": "results", "action": "inject", "args": ["dice.skill.model.oppose", ["<passing_roll>", "<failing_roll>", "<i>", "<d>"]] },
				{ "id": "null", "action": "return", "args": ["<results>"] },
			],

			check: [
				["party", "char_idx", "keys", "check"],
				{ "id": "skills", "action": "loop", "args": ["character.attributes.stats.get.total", "<keys>", ["<party>", "<char_idx>", "$idx$", null]] },
				{ "id": "values", "action": "math", "args": ["<skills>", ".", "value"] },
				{ "id": "total", "action": "reduce", "args": ["<values>", "+", 0] },
				{ "id": "modifier", "action": "choice", "args": ["Add skill check modifiers", [0, 10, 20, 30, 40, 50, -10, -20, -30, -40, -50]] },
				{ "id": "total", "action": "math", "args": ["<total.1>", "+", "<modifier.data>"] },
				{ "id": "vantage", "action": "inject", "args": ["character.attributes.checks.get", ["<party>.<char_idx>", "vantage", "<check>"]] },
				{ "id": "roll", "action": "inject", "args": ["dice.skill.roll", [100, "check <keys>", "<vantage>", "<total>"]] },
				{ "id": "results", "action": "inject", "args": ["dice.skill.model.skill_check", ["<party>", "<char_idx>", "<keys>", "<check>", "<roll>"]] },
				{ "id": "null", "action": "return", "args": ["<results>"] },
			],

			oppose: [
				["reroll_until_winner", "initiator", "defender"],
				// Skill check roll for initiator
				{ "id": "initiator", "action": "inject", "args": ["dice.skill.check", ["<initiator.party>", "<initiator.idx>", "<initiator.keys>", "<initiator.check>"]] },
				// Skill check roll for defender
				{ "id": "defender", "action": "inject", "args": ["dice.skill.check", ["<defender.party>", "<defender.idx>", "<defender.keys>", "<defender.check>"]] },
				// Inject resolve to figure out which roll wins
				{ "id": "results", "action": "inject", "args": ["dice.skill.resolve", ["<initiator>", "<defender>"]] },
				// If no one won the roll and reroll_until_winner is true then redo the check
				{ "id": "null", "action": "branch", "args": [["<reroll_until_winner>", "&"["<results.pass>", "==", "0"]], null, { "action": "goto", "args": ["id.return.next"] }] },
				{ "id": "null", "action": "log", "args": ["Both parties failed their respective rolls, re-rolling."] },
				{ "id": "null", "action": "goto", "args": ["id.initiator.start"] },
				// Return the roll results
				{ "id": "null", "action": "return", "args": ["<results>"] },
			],

			model: {
				inflate: {
					magic_to_oppose: [
						["i_party", "i_idx", "<d_check>"],
						// Use the defender skill_check to determine the outcome for the initiator
						{ "id": "pass_idx", "action": "ifelse", "args": ["<d_check.roll.pass>", "1", "2"] },
						{ "id": "fail_idx", "action": "ifelse", "args": ["<d_check.roll.pass>", "2", "1"] },
						{ "id": "is_pass", "action": "math", "args": ["<d_check.roll.pass>", "==", false] },
						{ "id": "is_crit", "action": "math", "args": [["<d_check.roll.pass>", "==", false], "&", "<d_check.roll.crit>"] },
						// Inflate the models for roll, skill check, and oppose
						{ "id": "i_roll", "action": "inject", "args": ["dice.skill.model.roll", ["<d_check.roll.threshold>", "<d_check.roll.roll>", "<is_crit>", "<is_pass>"]] },
						{ "id": "i_check", "action": "inject", "args": ["dice.skill.model.skill_check", ["<i_party>", "<i_idx>", "<i_roll>"]] },
						{ "id": "oppose", "action": "return", "args": [{ "pass": "<pass_idx>", "fail": "<fail_idx>", "1": "<i_check>", "2": "<d_check>" }] },
						{ "id": "null", "action": "return", "args": ["<oppose>"] },
					],

					none_to_oppose: [
						["i_party", "i_idx", "d_party", "d_idx"],
						// Inflate rolls
						{ "id": "i_roll", "action": "inject", "args": ["dice.skill.model.roll", [1, 0, false, true]] },
						{ "id": "d_roll", "action": "inject", "args": ["dice.skill.model.roll", [0, 0, false, false]] },
						// Inflate checks
						{ "id": "i_check", "action": "inject", "args": ["dice.skill.model.skill_check", ["<i_party>", "<i_idx>", "<i_roll>"]] },
						{ "id": "d_check", "action": "inject", "args": ["dice.skill.model.skill_check", ["<d_party>", "<d_idx>", "<d_roll>"]] },
						// Inflate oppose
						{ "id": "oppose", "action": "inject", "args": ["dice.skill.model.oppose", ["1", "2", "<e_check>", "<c_check>"]] },
						// Return model
						{ "id": "null", "action": "return", "args": ["<oppose>"] },
					],
				},

				oppose: [
					["passing", "failing", "i", "d"],
					{ "id": "oppose", "action": "return", "args": [{ "pass": "<passing>", "fail": "<failing>", "1": "<i>", "2": "<d>" }] },
					{ "id": "null", "action": "return", "args": ["<oppose>"] },
				],

				skill_check: [
					["party", "char_idx", "skills", "vantage", "roll"],
					{ "id": "skill_check", "action": "resolve", "args": [{ "party": "<party>", "idx": "<char_idx>", "skills": "<skills>", "vantage": "<vantage>", "roll": "<roll>" }] },
					{ "id": "null", "action": "return", "args": ["<skill_check>"] },
				],

				roll: [
					["threshold", "roll", "crit", "pass"],
					{ "id": "roll", "action": "resolve", "args": [{ "threshold": "<threshold>", "roll": "<roll>", "crit": "<crit>", "pass": "<pass>" }] },
					{ "id": "null", "action": "return", "args": ["<roll>"] },
				],
			}
		},
	},

	loot: {
		roll_armor: [
			{ "id": "armor", "action": "inject", "args": ["dice.rolls.roll_against_table", ["game_d", "tables.items.distribution.random.armor"]] },
			{
				"id": "type", "action": "branch", "args": [["<armor.0>", ">", 17],
				{ "action": "inject", "args": ["dice.rolls.roll_against_table", ["game_d", "tables.items.distribution.random.shield"]] },
				{ "action": "inject", "args": ["dice.rolls.roll_against_table", ["game_d", "tables.items.distribution.random.material"]] }]
			},
			{
				"id": "armors", "action": "branch", "args": [["<armor.0>", "<", 2],
				{ "action": "read", "args": ["game_d", "tables.items.distribution.suit"] },
				{ "action": "resolve", "args": [["<armor.1>"]] }]
			},
			{ "id": "gear", "action": "loop", "args": ["loot.suit_to_pieces", "<armors>", ["$idx$", "<type.1>"]] },
			{ "id": "null", "action": "return", "args": ["<gear>"] },
		],

		suit_to_pieces: [
			["armor", "type"],
			{ "id": "gear", "action": "read", "args": ["game_d", "tables.items.<armor>.<type>"] },
			{ "id": "null", "action": "return", "args": ["<gear>"] },
		],
	},

	// ------------------------------------------------------------------------------------------------------- Character
	character: {
		creation: {
			wizard: [
				["char_idx"],
				// Wire up Context and Audiences for character events
				{ "id": "null", "action": "context", "args": ["character_party.0", "+", ["^character_party\\.[<char_idx>\\*]"]] },
				{ "id": "null", "action": "audience", "args": ["character_party.0:default", "+", { "start": "character_party.[<char_idx>\\*].create", "delete": "character_party.[<char_idx>\\*].die" }] },
				{ "id": "null", "action": "audience", "args": ["character_party.0:traverse", "+", { "start": "character_party.[<char_idx>\\*].traverse", "stop": "character_party.[<char_idx>\\*].[camp|combat]", "delete": "character_party.[<char_idx>\\*].die" }] },
				{ "id": "null", "action": "audience", "args": ["character_party.0:camp", "+", { "start": "character_party.[<char_idx>\\*].camp", "stop": "character_party.[<char_idx>\\*].[traverse|combat]", "delete": "character_party.[<char_idx>\\*].die" }] },
				{ "id": "null", "action": "event", "args": ["character_party.<char_idx>.create"] },
				// Generate the character from the model
				{ "id": "log", "action": "log", "args": ["------------- Character Creation ------------"] },
				{ "id": "copy", "action": "copy", "args": ["game_d", "models.character"] },
				{ "id": "sheet", "action": "write", "args": ["save_d", "character_party.<char_idx>", "<copy>"] },
				// Set the character name
				{ "id": "name", "action": "profile", "args": [] },
				{ "id": "save", "action": "write", "args": ["save_d", "character_party.<char_idx>.name", "<name>"] },
				// Intro text
				{ "id": "intro", "action": "read", "args": ["game_d", "emersion_text.general.introduction"] },
				{ "id": "intro", "action": "format", "args": ["<intro>", "<name>"] },
				{ "id": "notify", "action": "notify", "args": ["<intro>"] },
				// Roll for Crime
				{ "id": "notify", "action": "notify", "args": ["They were thrown into Underverse for having committed the crime of: "] },
				{ "id": "inject", "action": "inject", "args": ["dice.rolls.save_roll_against_table", ["tables.crimes", "character_party.<char_idx>.biography.crime"]] },
				// Set Merits
				{ "id": "log", "action": "log", "args": ["---------------- Merits ---------------"] },
				{ "id": "merits", "action": "modal", "args": ["select_multi", "Merits", [0, 2], "game_d", "tables.merits"] },
				{ "id": "na_flaws", "action": "loop", "args": ["character.biography.activate_entry", "<merits>", ["merits", "$idx$", "<char_idx>"]] },
				// Set Flaws
				{ "id": "log", "action": "log", "args": ["----------------- Flaws ---------------"] },
				{ "id": "all_flaws", "action": "keys", "args": ["game_d", "tables.flaws"] },
				{ "id": "fltr_flaws", "action": "remove", "args": ["<all_flaws>", "<na_flaws>"] },
				{ "id": "m_count", "action": "size", "args": ["<merits>"] },
				{ "id": "flaws", "action": "modal", "args": ["select_multi", "Flaws", ["<m_count>", "<m_count>"], null, "<fltr_flaws>"] },
				{ "id": "null", "action": "loop", "args": ["character.biography.activate_entry", "<flaws>", ["flaws", "$idx$", "<char_idx>"]] },
				// Roll for Health
				{ "id": "log", "action": "log", "args": ["---------------- Attributes ---------------"] },
				{ "id": "h_die", "action": "event", "args": ["character_party.0.stats.health.roll", 6] },
				{ "id": "log", "action": "log", "args": ["Rolling for <name>'s Health: d<h_die> + 8"] },
				{ "id": "inject", "action": "inject", "args": ["dice.rolls.roll_plus_one", ["<h_die>", "Health"]] },
				{ "id": "modifier", "action": "math", "args": ["<inject>", "+", 8] },
				{ "id": "null", "action": "inject", "args": ["character.attributes.stats.add", ["character_party.<char_idx>", "base", "health", { "base": "<modifier>", "max": "<modifier>" }]] },
				{ "id": "log", "action": "log", "args": ["<name>'s Health is <modifier>"] },
				// Roll for Toughness
				{ "id": "t_die", "action": "event", "args": ["character_party.0.stats.toughness.roll", 6] },
				{ "id": "log", "action": "log", "args": ["Rolling for <name>'s Toughness: 2d<t_die> + 8"] },
				{ "id": "inject", "action": "inject", "args": ["dice.rolls.roll_plus_one", ["<t_die>", "Toughness"]] },
				{ "id": "modifier", "action": "math", "args": ["<inject>", "+", 8] },
				{ "id": "inject", "action": "inject", "args": ["dice.rolls.roll_plus_one", ["<t_die>", "Toughness"]] },
				{ "id": "modifier", "action": "math", "args": ["<inject>", "+", "<modifier>"] },
				{ "id": "null", "action": "inject", "args": ["character.attributes.stats.add", ["character_party.<char_idx>", "base", "toughness", { "base": "<modifier>", "max": "<modifier>" }]] },
				{ "id": "log", "action": "log", "args": ["<name>'s Toughness is <modifier>"] },
				// Roll for Aether
				{ "id": "a_die", "action": "event", "args": ["character_party.0.stats.aether.roll", 6] },
				{ "id": "log", "action": "log", "args": ["Rolling for <name>'s Aether: d<a_die> + 8"] },
				{ "id": "inject", "action": "inject", "args": ["dice.rolls.roll_plus_one", ["<a_die>", "Aether"]] },
				{ "id": "modifier", "action": "math", "args": ["<inject>", "+", 8] },
				{ "id": "null", "action": "inject", "args": ["character.attributes.stats.add", ["character_party.<char_idx>", "base", "aether", { "base": "<modifier>", "max": "<modifier>" }]] },
				{ "id": "log", "action": "log", "args": ["<name>'s Aether is <modifier>"] },
				// Roll for Sanity
				{ "id": "s_die", "action": "event", "args": ["character_party.0.stats.sanity.roll", 6] },
				{ "id": "log", "action": "log", "args": ["Rolling for <name>'s Sanity: d<s_die> + 8"] },
				{ "id": "inject", "action": "inject", "args": ["dice.rolls.roll_plus_one", ["<s_die>", "Sanity"]] },
				{ "id": "modifier", "action": "math", "args": ["<inject>", "+", 8] },
				{ "id": "null", "action": "inject", "args": ["character.attributes.stats.add", ["character_party.<char_idx>", "base", "sanity", { "base": "<modifier>", "max": "<modifier>" }]] },
				{ "id": "log", "action": "log", "args": ["<name>'s Sanity is <modifier>"] },
				// Set Magic Resist
				{ "id": "null", "action": "inject", "args": ["character.attributes.stats.add", ["character_party.<char_idx>", "skill", "magic_resist", { "base": 20, "max": 20 }]] },
				{ "id": "log", "action": "log", "args": ["<name>'s Magic Resist is 20"] },
				{ "id": "log", "action": "log", "args": ["------------------- Skills ------------------"] },
				// Set Primary Weapon Skill
				{ "id": "null", "action": "inject", "args": ["character.creation.skill_setup", ["skills.weapon", "Pick <name>'s primary weapon skill (+60)", "character_party", "<char_idx>", "weapon", { "base": 60 }, "<name>"]] },
				// Set Secondary Weapon Skill
				{ "id": "null", "action": "inject", "args": ["character.creation.skill_setup", ["skills.weapon", "Pick <name>'s secondary weapon skill (+40)", "character_party", "<char_idx>", "weapon", { "base": 40 }, "<name>"]] },
				// Set Primary Skills x3
				{ "id": "s_range", "action": "range", "args": [3] },
				{ "id": "null", "action": "loop", "args": ["character.creation.skill_setup", "<s_range>", ["skills.ability", "Pick <name>'s primary skill (+30)", "character_party", "<char_idx>", "skill", { "base": 30 }, "<name>"]] },
				// Set Secondary Skills x3
				{ "id": "null", "action": "loop", "args": ["character.creation.skill_setup", "<s_range>", ["skills.ability", "Pick <name>'s secondary skill (+20)", "character_party", "<char_idx>", "skill", { "base": 20 }, "<name>"]] },
				// Set Tertiary Skills x4
				{ "id": "s_range", "action": "range", "args": [4] },
				{ "id": "null", "action": "loop", "args": ["character.creation.skill_setup", "<s_range>", ["skills.ability", "Pick <name>'s tertiary skill (+10)", "character_party", "<char_idx>", "skill", { "base": 10 }, "<name>"]] },
				// Set Masteries x2
				{ "id": "log", "action": "log", "args": ["---------------- Masteries ---------------"] },
				{ "id": "choice", "action": "modal", "args": ["select_multi", "Masteries", [2, 2], "game_d", "tables.masteries"] },
				{ "id": "null", "action": "loop", "args": ["character.biography.masteries.add", "<choice>", ["<char_idx>", "$idx$"]] },
				{ "id": "log", "action": "log", "args": ["<name>'s masteries are <choice>."] },
				// Set Goals
				{ "id": "log", "action": "log", "args": ["------------- Personal Goals ------------"] },
				{ "id": "goals", "action": "modal", "args": ["select_multi", "Personal Goals", [2, 2], "game_d", "tables.goals"] },
				{ "id": "null", "action": "loop", "args": ["character.biography.goals.add", "<goals>", ["<char_idx>", "$idx$"]] },
				{ "id": "log", "action": "log", "args": ["<name>'s personal goals are <goals>."] },
				// Roll Equipment
				{ "id": "log", "action": "log", "args": ["--------------- Equipment ---------------"] },
				// Select Weapon
				{ "id": "weapon", "action": "modal", "args": ["select_multi", "Pick Weapon", [1, 1], "game_d", "tables.items.weapon"] },
				{ "id": "obj", "action": "inject", "args": ["character.inventory.item.get", ["weapon", "<weapon>"]] },
				{ "id": "path", "action": "inject", "args": ["character.inventory.item.add", ["character_party", "<char_idx>", "<obj>"]] },
				{ "id": "null", "action": "inject", "args": ["character.inventory.item.use", ["character_party", "<char_idx>", "<path>"]] },
				// Equip Torch
				{ "id": "obj", "action": "inject", "args": ["character.inventory.item.get", ["common", "torch"]] },
				{ "id": "path", "action": "inject", "args": ["character.inventory.item.add", ["character_party", "<char_idx>", "<obj>"]] },
				{ "id": "null", "action": "inject", "args": ["character.inventory.item.use", ["character_party", "<char_idx>", "<path>"]] },
				// Roll Armor
				{ "id": "obj", "action": "inject", "args": ["loot.roll_armor"] },
				{ "id": "path", "action": "loop", "args": ["character.inventory.item.add", "<obj>", ["character_party", "<char_idx>", "$idx$"]] },
				{ "id": "null", "action": "loop", "args": ["character.inventory.item.use", "<path>", ["character_party", "<char_idx>", "$idx$"]] },
				// Roll Cooking Supplies
				{ "id": "count", "action": "inject", "args": ["dice.rolls.roll_plus_one", [10, "Cooking Supplies"]] },
				{ "id": "obj", "action": "inject", "args": ["character.inventory.supply.edit", ["character_party", "<char_idx>", "cooking", "<count>"]] },
				// Roll Crafting Supplies
				{ "id": "count", "action": "inject", "args": ["dice.rolls.roll_plus_one", [10, "Crafting Supplies"]] },
				{ "id": "count", "action": "math", "args": ["<count>", "+", 5] },
				{ "id": "obj", "action": "inject", "args": ["character.inventory.supply.edit", ["character_party", "<char_idx>", "crafting", "<count>"]] },
				// Roll Gold Supplies
				{ "id": "count", "action": "inject", "args": ["dice.rolls.roll_plus_one", [20, "Gold"]] },
				{ "id": "obj", "action": "inject", "args": ["character.inventory.supply.edit", ["character_party", "<char_idx>", "gold", "<count>"]] },
				// Add listener for player dying
				{ "id": "null", "action": "inject", "args": ["effects.add", ["character_party", 0, "death", "listener.death_check"]] },
			],

			skill_setup: [
				["table", "message", "party", "char_idx", "type", "modifier", "name"],
				// Disable already selected choices and present them to the player
				{ "id": "disabled", "action": "h_get", "args": ["selected_attrs", []] },
				{ "id": "attrs", "action": "read", "args": ["game_d", "tables.<table>"] },
				{ "id": "choice", "action": "choice", "args": ["<message>", "<attrs>", "<disabled>"] },
				{ "id": "disabled", "action": "concat", "args": ["<disabled>", "<choice.data>"] },
				{ "id": "disabled", "action": "h_put", "args": ["selected_attrs", "<disabled.data>"] },
				// Add the modifier to the skill base
				{ "id": "null", "action": "inject", "args": ["character.attributes.stats.add", ["<party>.<char_idx>", "<type>", "<choice.data>", "<modifier>"]] },
				// Log and return the choice
				{ "id": "log", "action": "log", "args": ["<name>'s <choice.data> skill is <modifier.base>"] },
				{ "id": "null", "action": "return", "args": ["<choice.data>"] },
			],
		},

		death: [
			["party", "idx"],
			// Get character info and display it
			{ "id": "name", "action": "read", "args": ["save_d", "<party>.<idx>.name"] },
			{ "id": "type", "action": "read", "args": ["save_d", "<party>.<idx>.type"] },

			// Event deaths_door 
			{ "id": "is_dead", "action": "resolve", "args": [true] },
			{ "id": "null", "action": "event", "args": ["<party>.<idx>.deaths_door"] },
			// Allow a listener to override death from life saving procs
			{ "id": "null", "action": "branch", "args": ["<is_dead>", null, { "action": "return" }] },

			// Event for character's death
			{ "id": "null", "action": "event", "args": ["<party>.<idx>.dead"] },
			// Notify user of death
			{ "id": "null", "action": "notify", "args": ["<name> has died."] },

			// Remove the character from the party
			{ "id": "null", "action": "delete", "args": ["save_d", "<party>.<idx>"] },
			// If it is the player that died emit game over event
			{ "id": "character", "action": "branch", "args": [["<type>", "!=", "player"], { "action": "return" }] },
			{ "id": "null", "action": "event", "args": ["<party>.<idx>.game_over"] },
			{ "id": "null", "action": "h_put", "args": ["<party>.<idx>.game_over", true] },
		],

		biography: {
			refs: {
				add: [
					["party", "char_idx", "type", "key"],
					{ "id": "obj", "action": "copy", "args": ["game_d", "tables.<type>.<key>"] },
					{ "id": "null", "action": "set_at", "args": ["save_d", "<party>.<char_idx>.biography.<type>.<key>", "<obj>"] },
					{ "id": "null", "action": "return", "args": ["biography.<type>.<key>"] },
				],

				delete: [
					["party", "char_idx", "type", "key",],
					{ "id": "null", "action": "inject", "args": ["character.modifier.delete", ["<party>", "<char_idx>", "<reference>"]] },
					{ "id": "obj", "action": "delete", "args": ["save_d", "<party>.<char_idx>.<reference>"] },
				],
			},

			activate_entry: [
				["category", "type", "char_idx"],
				{ "id": "meta", "action": "read", "args": ["game_d", "tables.<category>.<type>"] },
				{ "id": "results", "action": "inject", "args": ["<meta.rule>", ["<char_idx>", "<meta.args>"]] },
				{ "id": "null", "action": "return", "args": ["<results>"] },
			],

			merits: {
				blessed: [
					["char_idx", "args"],
					{ "id": "ref_key", "action": "inject", "args": ["character.biography.refs.add", ["character_party", "<char_idx>", "merits", "blessed", "+10 to Magic Resist"]] },
					{ "id": "null", "action": "inject", "args": ["effects.add", ["character_party", "<char_idx>", "<ref_key>", "skill.magic_resist.10"]] },
					{ "id": "null", "action": "log", "args": [`Blessed: Magic Resist +10`] },
					{ "id": "null", "action": "return", "args": ["cursed"] },
				],
				eagle_eyed: [
					["char_idx", "args"],
					{ "id": "ref_key", "action": "inject", "args": ["character.biography.refs.add", ["character_party", "<char_idx>", "merits", "eagle_eyed", "+10 to Perception"]] },
					{ "id": "null", "action": "inject", "args": ["effects.add", ["character_party", "<char_idx>", "<ref_key>", "skill.perception.10"]] },
					{ "id": "null", "action": "log", "args": [`Eagle Eye: Perception +10`] },
					{ "id": "null", "action": "return", "args": ["short_sighted"] },
				],
				fearless: [
					["char_idx", "args"],
					{ "id": "ref_key", "action": "inject", "args": ["character.biography.refs.add", ["character_party", "<char_idx>", "merits", "fearless", "Advantage on Resolve.Fear checks"]] },
					{ "id": "null", "action": "inject", "args": ["effects.add", ["character_party", "<char_idx>", "<ref_key>", "skill.resolve.fear.+"]] },
					{ "id": "null", "action": "log", "args": [`Fearless: Gain Advantage on Resolve checks involving Fear.`] },
					{ "id": "null", "action": "return", "args": ["coward"] },
				],
				haggler: [
					["char_idx", "args"],
					{ "id": "ref_key", "action": "inject", "args": ["character.biography.refs.add", ["character_party", "<char_idx>", "merits", "haggler", "ToDo"]] },
					{ "id": "null", "action": "log", "args": [`Haggler: ToDo`] },
				],
				lucky: [
					["char_idx", "args"],
					{ "id": "ref_key", "action": "inject", "args": ["character.biography.refs.add", ["character_party", "<char_idx>", "merits", "lucky", "ToDo"]] },
					{ "id": "null", "action": "log", "args": [`Lucky: ToDo`] },
				],
				natural_healer: [
					["char_idx", "args"],
					{ "id": "ref_key", "action": "inject", "args": ["character.biography.refs.add", ["character_party", "<char_idx>", "merits", "natural_healer", "ToDo"]] },
					{ "id": "null", "action": "log", "args": [`Natural Healer: ToDo`] },
				],
				hearty: [
					["char_idx", "args"],
					{ "id": "ref_key", "action": "inject", "args": ["character.biography.refs.add", ["character_party", "<char_idx>", "merits", "hearty", "Advantage on Endurance.Disease|Poison checks"]] },
					{ "id": "null", "action": "loop", "args": ["effects.add", ["skill.endurance.disease.+", "skill.endurance.poison.+"], ["character_party", "<char_idx>", "<ref_key>", "$idx$"]] },
					{ "id": "null", "action": "log", "args": [`Hearty : Gain Advantage on Endurance checks related to disease and poison.`] },
					{ "id": "null", "action": "return", "args": ["sickly"] },
				],
				scavenger: [
					["char_idx", "args"],
					{ "id": "ref_key", "action": "inject", "args": ["character.biography.refs.add", ["character_party", "<char_idx>", "merits", "scavenger", "+10 to Scavenge"]] },
					{ "id": "null", "action": "inject", "args": ["effects.add", ["character_party", "<char_idx>", "<ref_key>", "skill.scavenge.10"]] },
					{ "id": "null", "action": "log", "args": [`Scavenger: Scavenge +10`] }
				],
				tracker: [
					["char_idx", "args"],
					{ "id": "ref_key", "action": "inject", "args": ["character.biography.refs.add", ["character_party", "<char_idx>", "merits", "tracker", "ToDo"]] },
					{ "id": "null", "action": "log", "args": [`Tracker: ToDo`] },
				],
				trained: [
					["char_idx", "args"],
					{ "id": "ref_key", "action": "inject", "args": ["character.biography.refs.add", ["character_party", "<char_idx>", "merits", "trained", "ToDo"]] },
					{ "id": "null", "action": "log", "args": [`Trained: ToDo`] },
				],
			},

			flaws: {
				armor_averse: [
					["char_idx", "args"],
					{ "id": "ref_key", "action": "inject", "args": ["character.biography.refs.add", ["character_party", "<char_idx>", "flaws", "armor_averse", "ToDo"]] },
					{ "id": "null", "action": "log", "args": [`Armor Averse: ToDo`] },
				],
				addict: [
					["char_idx", "args"],
					{ "id": "ref_key", "action": "inject", "args": ["character.biography.refs.add", ["character_party", "<char_idx>", "flaws", "addict", "ToDo"]] },
					{ "id": "null", "action": "log", "args": [`Addict: ToDo`] },
				],
				coward: [
					["char_idx", "args"],
					{ "id": "ref_key", "action": "inject", "args": ["character.biography.refs.add", ["character_party", "<char_idx>", "flaws", "coward", "Disadvantage on Resolve.Fear checks"]] },
					{ "id": "null", "action": "inject", "args": ["effects.add", ["character_party", "<char_idx>", "<ref_key>", "skill.resolve.fear.-"]] },
					{ "id": "null", "action": "log", "args": [`Coward: Gain Disadvantage on Resolve checks involving Fear.`] },
				],
				cracked_soul: [
					["char_idx", "args"],
					{ "id": "ref_key", "action": "inject", "args": ["character.biography.refs.add", ["character_party", "<char_idx>", "flaws", "cracked_soul", "Aether Roll Die D6->D4."]] },
					{ "id": "null", "action": "inject", "args": ["effects.add", ["character_party", "<char_idx>", "<ref_key>", "listener.cracked_soul"]] },
					{ "id": "null", "action": "log", "args": [`Cracked Soul: Reduce Aether Die from d6 -> d4`] },
				],
				cracked_soul_proc: [
					["event_idx", "new_die"],
					{ "id": "null", "action": "step_result", "args": ["<parent_process>", "<event_idx>", "<new_die>"] },
					{ "id": "null", "action": "log", "args": [`Cracked Soul: Reduce Aether Die from d6 -> d4`] },
				],
				cursed: [
					["char_idx", "args"],
					{ "id": "ref_key", "action": "inject", "args": ["character.biography.refs.add", ["character_party", "<char_idx>", "flaws", "cursed", "-10 to Magic Resist"]] },
					{ "id": "null", "action": "inject", "args": ["effects.add", ["character_party", "<char_idx>", "<ref_key>", "skill.magic_resist.-10"]] },
					{ "id": "null", "action": "log", "args": [`Cursed: Magic Resist -10`] },
				],
				damaged_nerve: [
					["char_idx", "args"],
					{ "id": "ref_key", "action": "inject", "args": ["character.biography.refs.add", ["character_party", "<char_idx>", "flaws", "damaged_nerve", "-10 to Acrobatics"]] },
					{ "id": "null", "action": "inject", "args": ["effects.add", ["character_party", "<char_idx>", "<ref_key>", "skill.acrobatics.-10"]] },
					{ "id": "null", "action": "log", "args": [`Damaged Nerve: Acrobatics -10`] },
				],
				fragile_mind: [
					["char_idx", "args"],
					{ "id": "ref_key", "action": "inject", "args": ["character.biography.refs.add", ["character_party", "<char_idx>", "flaws", "fragile_mind", "Sanity Roll Die D6->D4."]] },
					{ "id": "null", "action": "inject", "args": ["effects.add", ["character_party", "<char_idx>", "<ref_key>", "listener.fragile_mind"]] },
					{ "id": "null", "action": "log", "args": [`Fragile Mind: Reduce Sanity Die from d6 -> d4`] },
				],
				fragile_mind_proc: [
					["event_idx", "new_die"],
					{ "id": "null", "action": "step_result", "args": ["<parent_process>", "<event_idx>", "<new_die>"] },
					{ "id": "null", "action": "log", "args": [`Fragile Mind: Reduce Sanity Die from d6 -> d4`] },
				],
				queasy: [
					["char_idx", "args"],
					{ "id": "ref_key", "action": "inject", "args": ["character.biography.refs.add", ["character_party", "<char_idx>", "flaws", "queasy", "-10 to Medicine"]] },
					{ "id": "null", "action": "inject", "args": ["effects.add", ["character_party", "<char_idx>", "<ref_key>", "skill.medicine.-10"]] },
					{ "id": "null", "action": "log", "args": [`Queasy: Medicine -10`] },
				],
				short_sighted: [
					["char_idx", "args"],
					{ "id": "ref_key", "action": "inject", "args": ["character.biography.refs.add", ["character_party", "<char_idx>", "flaws", "short_sighted", "-10 to Perception"]] },
					{ "id": "null", "action": "inject", "args": ["effects.add", ["character_party", "<char_idx>", "<ref_key>", "skill.perception.-10"]] },
					{ "id": "null", "action": "log", "args": [`Short Sighted: Perception -10`] },
				],
				sickly: [
					["char_idx", "args"],
					{ "id": "ref_key", "action": "inject", "args": ["character.biography.refs.add", ["character_party", "<char_idx>", "flaws", "sickly", "Disadvantage on Endurance.Disease|Poison checks"]] },
					{ "id": "null", "action": "loop", "args": ["effects.add", ["skill.endurance.disease.-", "skill.endurance.poison.-"], ["character_party", "<char_idx>", "<ref_key>", "$idx$"]] },
					{ "id": "null", "action": "log", "args": [`Sickly: Gain Disadvantage on Endurance checks related to disease and poison.`] },
				],
			},

			levels: {
				add_experience: [
					["party", "char_idx", "exp"],
					{ "id": "obj", "action": "read", "args": ["save_d", "<party>.<char_idx>.biography.levels"] },
					{ "id": "total_exp", "action": "math", "args": ["<obj.base>", "+", "<exp>"] },
					{ "id": "mod_exp", "action": "math", "args": ["<total_exp>", "%", "<obj.max>"] },
					// If the moded value differs it means we have hit the level threshold
					{ "id": "is_level", "action": "branch", "args": [["<mod_exp>", "!=", "<total_exp>"], { "action": "goto", "args": ["id.base_exp.next"] }] },
					{ "id": "total_exp", "action": "math", "args": ["<obj.total>", "+", 1] },
					// ToDo: Inject level up call
					{ "id": "base_exp", "action": "write", "args": ["save_d", "<party>.<char_idx>.biography.levels.base", "<mod_exp>"] },
				],

				level_up: [],
			},

			masteries: {
				add: [
					["char_idx", "mastery_id"],
					{ "id": "mastery", "action": "copy", "args": ["game_d", "tables.masteries.<mastery_id>"] },
					{ "id": "obj", "action": "set_at", "args": ["save_d", "character_party.<char_idx>.biography.masteries.<mastery_id>", "<mastery>"] },
				],

				level_up: [],
				swap: [],
			},

			goals: {
				add: [
					["char_idx", "goal_id"],
					{ "id": "goal", "action": "copy", "args": ["game_d", "tables.goals.<goal_id>"] },
					{ "id": "obj", "action": "set_at", "args": ["save_d", "character_party.<char_idx>.biography.goals.<goal_id>", "<goal>"] },
				],

				update: [],
				finish: [],
				remove: [],
			},

			perks: {},
			madness: {},
			domain: {},
		},

		attributes: {
			references: {
				add: [
					["party", "char_idx", "source_ref", "effect_id"],
					// Make sure the paths exist
					{ "id": "key_path", "action": "touch", "args": ["save_d", "<party>:[].<char_idx>:{}.modifiers:{}./<source_ref>/:[]"] },
					// Set the keys to the data 
					{ "id": "m_ref", "action": "concat", "args": ["save_d", "<party>.<char_idx>.modifiers./<source_ref>/", "<effect_id>"] },
					// Return the path to the key and the data
					{ "id": "null", "action": "return", "args": ["<party>.<char_idx>.modifiers.<source_ref>", "<effect_id>"] },
				],

				delete: [
					["party", "char_idx", "source_ref", "effect_id"],
					// Remove the reference
					{ "id": "effects", "action": "read", "args": ["save_d", "<party>.<char_idx>.modifiers./<source_ref>/"] },
					{ "id": "effects", "action": "remove", "args": ["<effects>", "<effect_id>"] },
					{ "id": "null", "action": "write", "args": ["save_d", "<party>.<char_idx>.modifiers./<source_ref>/", "<effects>"] },
					// Return the path to the key and the data
					{ "id": "null", "action": "return", "args": ["<party>.<char_idx>.modifiers.<source_ref>", "<effect_id>"] },
				],
			},

			modifiers: {
				add: [
					["party", "char_idx", "category", "type", "sub_type", "source_ref", "effect_id", "obj"],
					// Make sure the paths exist
					{ "id": "key_path", "action": "touch", "args": ["save_d", "<party>:[].<char_idx>:{}.modifiers:{}./<source_ref>/:[]"] },
					// Set the keys to the data 
					{ "id": "m_ref", "action": "concat", "args": ["save_d", "<party>.<char_idx>.modifiers./<source_ref>/", "<effect_id>"] },
					// Call the category add for the modifier
					{ "id": "result", "action": "inject", "args": ["character.attributes.<category>.add", ["<party>.<char_idx>", "<type>", "<sub_type>", "<obj>"]] },
					// Return the path to the key and the data
					{ "id": "null", "action": "return", "args": ["<party>.<char_idx>.modifiers.<source_ref>", "<effect_id>"] },
				],

				delete: [
					["party", "char_idx", "category", "type", "sub_type", "source_ref", "effect_id", "obj"],
					// Call the category delete for the modifier
					{ "id": "null", "action": "inject", "args": ["character.attributes.<category>.delete", ["<party>.<char_idx>", "<type>", "<sub_type>", "<obj>"]] },
					{ "id": "effects", "action": "read", "args": ["save_d", "<party>.<char_idx>.modifiers./<source_ref>/"] },
					{ "id": "effects", "action": "remove", "args": ["<effects>", "<effect_id>"] },
					{ "id": "null", "action": "write", "args": ["save_d", "<party>.<char_idx>.modifiers./<source_ref>/", "<effects>"] },
					// Return the path to the key and the data
					{ "id": "null", "action": "return", "args": ["<party>.<char_idx>.modifiers.<source_ref>", "<effect_id>"] },
				],
			},

			actions: {
				add: [
					["char_path", "type", "sub_type", "delta"],
					{ "id": "value", "action": "read", "args": ["game_d", "tables.actions.<type>.<sub_type>./<delta>/"] },
					{ "id": "null", "action": "set_at", "args": ["save_d", "<char_path>.actions.<type>.<sub_type>./<delta>/", "<value>"] },
				],

				delete: [
					["char_path", "type", "sub_type", "delta"],
					{ "id": "null", "action": "delete", "args": ["save_d", "<char_path>.actions.<type>.<sub_type>./<delta>/"] },
				],
			},

			checks: {
				add: [
					["char_path", "type", "sub_type", "delta"],
					{ "id": "value", "action": "at_t", "args": ["save_d", "<char_path>.checks<sub_type>", "<type>", 0] },
					{ "id": "check", "action": "math", "args": ["<value>", "+", "<delta>"] },
					{ "id": "null", "action": "write_t", "args": ["save_d", "<char_path>.checks<sub_type>", "<type>", "<check>"] },
				],

				get: [
					["char_path", "type", "sub_type"],
					{ "id": "values", "action": "resolve_t", "args": ["save_d", "<char_path>.checks<sub_type>", "<type>", 0] },
					{ "id": "clamped", "action": "math", "args": ["<values>", "clmp", { "min": -1, "max": 1 }] },
					{ "id": "check", "action": "reduce", "args": ["<values>", "+"] },
					{ "id": "null", "action": "return", "args": ["<check.1>"] },
				],

				delete: [
					["char_path", "type", "sub_type", "delta"],
					{ "id": "value", "action": "at_t", "args": ["save_d", "<char_path>.checks<sub_type>", "<type>", 0] },
					{ "id": "check", "action": "math", "args": ["<value>", "-", "<delta>"] },
					{ "id": "null", "action": "write_t", "args": ["save_d", "<char_path>.checks<sub_type>", "<type>", "<check>"] },
				],
			},

			enums: {
				add: [
					["char_path", "type", "sub_type", "delta"],
					// Read the existing modifiers for the character
					{ "id": "value", "action": "read", "args": ["save_d", "<char_path>.enums.<type>.<sub_type>"] },
					// Calculate the new type's total
					{ "id": "enum", "action": "math", "args": ["<value>", "+", "<delta>"] },
					// Save the edits to the character sheet
					{ "id": "null", "action": "write", "args": ["save_d", "<char_path>.enums.<type>.<sub_type>", "<enum>"] },
					{ "id": "null", "action": "return", "args": ["<enum>"] },
				],

				get: [
					["char_path", "type", "sub_type"],
					{ "id": "value", "action": "read", "args": ["save_d", "<char_path>.enums.<type>.<sub_type>"] },
					{ "id": "null", "action": "return", "args": ["<value>"] },
				],

				delete: [
					["char_path", "type", "sub_type", "delta"],
					// Read the existing modifiers for the character
					{ "id": "value", "action": "read", "args": ["save_d", "<char_path>.enums.<type>.<sub_type>"] },
					// Calculate the new type's total
					{ "id": "enum", "action": "math", "args": ["<value>", "-", "<delta>"] },
					// Save the edits to the character sheet
					{ "id": "null", "action": "write", "args": ["save_d", "<char_path>.enums.<type>.<sub_type>", "<enum>"] },
					{ "id": "null", "action": "return", "args": ["<enum>"] },
				],
			},

			stats: {
				add: [
					["char_path", "type", "sub_type", "delta"],
					// Read the existing modifiers for the character
					{ "id": "obj", "action": "read", "args": ["save_d", "<char_path>.stats.<type>.<sub_type>"] },
					{ "id": "adjust", "action": "resolve", "args": [0] },

					// Update the max if it has a delta
					{ "id": "d_max", "action": "ifelse", "args": [["<delta>", ".", "max"], "<delta.max>", 0] },
					{ "id": "null", "action": "branch", "args": [["<d_max>", "==", 0], { "action": "goto", "args": ["id.d_base.next"] }] },
					{ "id": "max", "action": "math", "args": ["<obj.max>", "+", "<d_max>"] },
					{ "id": "obj", "action": "set", "args": ["<obj>", "max", "<max>"] },
					// If the max is lower than the base clamp the base to the max
					{ "id": "adjust", "action": "math", "args": [["<obj.base>", "min", "<obj.max>"], "-", "<obj.base>"] },
					{ "id": "base", "action": "math", "args": ["<obj.base>", "-", "<adjust>"] },
					{ "id": "obj", "action": "set", "args": ["<obj>", "base", "<base>"] },

					// Update the base if it has a delta
					{ "id": "d_base", "action": "ifelse", "args": [["<delta>", ".", "base"], "<delta.base>", 0] },
					{ "id": "null", "action": "branch", "args": [["<d_base>", "==", 0], { "action": "goto", "args": ["id.d_total.next"] }] },
					// Adjust the delta base value if it exceeds the max
					{ "id": "d_base", "action": "math", "args": [[["<obj.base>", "+", "<d_base>"], "min", "<obj.max>"], "-", "<obj.base>"] },
					{ "id": "base", "action": "math", "args": ["<obj.base>", "+", "<d_base>"] },
					{ "id": "obj", "action": "set", "args": ["<obj>", "base", "<base>"] },

					// Update the total if it has a delta or if base value changed
					{ "id": "d_total", "action": "ifelse", "args": [["<delta>", ".", "total"], "<delta.total>", 0] },
					// Adjust the total if it would have been affected by a previous change in base or max
					{ "id": "total", "action": "math", "args": ["<obj.total>", "+", "<adjust>"] },
					{ "id": "obj", "action": "set", "args": ["<obj>", "total", "<total>"] },
					{ "id": "null", "action": "branch", "args": [[["<d_total>", "==", 0], "&", ["<d_base>", "==", 0]], { "action": "goto", "args": ["id.d_write.next"] }] },
					{ "id": "total", "action": "math", "args": [["<obj.total>", "+", "<d_total>"], "+", "<d_base>"] },
					{ "id": "obj", "action": "set", "args": ["<obj>", "total", "<total>"] },

					// Write the updates back to the stat
					{ "id": "d_write", "action": "write", "args": ["save_d", "<char_path>.stats.<type>.<sub_type>", "<obj>"] },
					{ "id": "null", "action": "return", "args": ["<obj>"] },
				],

				get: {
					base: [
						["party", "char_idx", "type", "sub_type"],
						{
							"id": "stat", "action": "branch", "args": [["<sub_type>", "==", null],
							{ "action": "read", "args": ["save_d", "<party>.<char_idx>.stats.<type>.base"] },
							{ "action": "read", "args": ["save_d", "<party>.<char_idx>.stats.<type>.<sub_type>.base"] }]
						},
						{
							"id": "stat", "action": "branch", "args": [["<sub_type>", "==", null],
							{ "action": "return", "args": [{ "type": "<type>", "value": "<stat>" }] },
							{ "action": "return", "args": [{ "type": "<type>", "sub_type": "<sub_type>", "value": "<stat>" }] }]
						},
					],

					max: [
						["party", "char_idx", "type", "sub_type"],
						{
							"id": "stat", "action": "branch", "args": [["<sub_type>", "==", null],
							{ "action": "read", "args": ["save_d", "<party>.<char_idx>.stats.<type>.max"] },
							{ "action": "read", "args": ["save_d", "<party>.<char_idx>.stats.<type>.<sub_type>.max"] }]
						},
						{
							"id": "stat", "action": "branch", "args": [["<sub_type>", "==", null],
							{ "action": "return", "args": [{ "type": "<type>", "value": "<stat>" }] },
							{ "action": "return", "args": [{ "type": "<type>", "sub_type": "<sub_type>", "value": "<stat>" }] }]
						},
					],

					total: [
						["party", "char_idx", "type", "sub_type"],
						{
							"id": "stat", "action": "branch", "args": [["<sub_type>", "==", null],
							{ "action": "read", "args": ["save_d", "<party>.<char_idx>.stats.<type>.total"] },
							{ "action": "read", "args": ["save_d", "<party>.<char_idx>.stats.<type>.<sub_type>.total"] }]
						},
						{
							"id": "stat", "action": "branch", "args": [["<sub_type>", "==", null],
							{ "action": "return", "args": [{ "type": "<type>", "value": "<stat>" }] },
							{ "action": "return", "args": [{ "type": "<type>", "sub_type": "<sub_type>", "value": "<stat>" }] }]
						},
					],
				},

				delete: [
					["char_path", "type", "sub_type", "delta"],
					// Read the existing modifiers for the character
					{ "id": "obj", "action": "read", "args": ["save_d", "<char_path>.stats.<type>.<sub_type>"] },
					{ "id": "adjust", "action": "resolve", "args": [0] },

					// Update the max if it has a delta
					{ "id": "d_max", "action": "ifelse", "args": [["delta", ".", "max"], "<delta.max>", 0] },
					{ "id": "null", "action": "branch", "args": [["<d_max>", "==", 0], { "action": "goto", "args": ["id.d_base.next"] }] },
					{ "id": "max", "action": "math", "args": [["<obj.max>", "-", "<d_max>"], "max", 0] },
					{ "id": "obj", "action": "set", "args": ["<obj>", "max", "<max>"] },
					// If the max is lower than the base clamp the base to the max
					{ "id": "adjust", "action": "math", "args": [[["<obj.base>", "min", "<obj.max>"]], "-", "<obj.base>"] },
					{ "id": "base", "action": "math", "args": ["<obj.base>", "-", "<adjust>"] },
					{ "id": "obj", "action": "set", "args": ["<obj.base>", "base", "<base>"] },

					// Update the base if it has a delta
					{ "id": "d_base", "action": "ifelse", "args": [["delta", ".", "base"], "<delta.base>", 0] },
					{ "id": "null", "action": "branch", "args": [["<d_base>", "==", 0], { "action": "goto", "args": ["id.d_total.next"] }] },
					// Adjust the delta base value if it goes below 0
					{ "id": "d_base", "action": "math", "args": [["<d_base>", "+", [["<obj.base>", "-", "<d_base>"], "min", 0]]] },
					{ "id": "base", "action": "math", "args": ["<obj.base>", "-", "<d_base>"] },
					{ "id": "obj", "action": "set", "args": ["<obj>", "base", "<base>"] },
					{ "id": "adjust", "action": "math", "args": ["<adjust>", "-", "<d_base>"] },

					// Update the total if it has a delta or if base value changed
					{ "id": "d_total", "action": "ifelse", "args": [["<delta>", ".", "total"], "<delta.total>", 0] },
					// Adjust the total if it would have been affected by a previous change in base or max, (adjust is negative)
					{ "id": "total", "action": "math", "args": ["<obj.total>", "+", "<adjust>"] },
					{ "id": "obj", "action": "set", "args": ["<obj>", "total", "<total>"] },
					{ "id": "null", "action": "branch", "args": [["<d_total>", "==", 0], { "action": "goto", "args": ["id.d_write.next"] }] },
					{ "id": "total", "action": "math", "args": [["<obj.total>", "-", "<d_total>"], "max", 0] },
					{ "id": "obj", "action": "set", "args": ["<obj>", "total", "<total>"] },

					// Write the updates back to the stat
					{ "id": "d_write", "action": "write", "args": ["save_d", "<char_path>.stats.<type>.<sub_type>", "<obj>"] },
					{ "id": "null", "action": "return", "args": ["<obj>"] },
				],

				points: {
					plus: [
						["char_path", "type", "sub_type", "amount"],
						// Read the existing values for the character
						{ "id": "obj", "action": "read", "args": ["save_d", "<char_path>.stats.<type>.<sub_type>"] },
						// Get the amount ot fill by and any left over amount
						{ "id": "diff_gap", "action": "math", "args": [["<obj.max>", "-", "<obj.total>"], "max", 0] },
						{ "id": "fill_by", "action": "ifelse", "args": [["<diff_gap>", "<=", "<amount>"], "<amount>", "<diff_gap>"] },
						{ "id": "left_over", "action": "branch", "args": [["<diff_gap>", "<=", "<amount>"], { "action": "resolve", "args": [0] }, { "action": "math", "args": ["<amount>", "-", "<diff_gap>"] }] },
						// Add it back to the attribute
						{ "id": "total", "action": "math", "args": ["<obj.total>", "+", "<fill_by>"] },
						{ "id": "obj", "action": "set", "args": ["<obj>", "total", "<total>"] },
						// Write the updates back to the stat
						{ "id": "d_write", "action": "write", "args": ["save_d", "<char_path>.stats.<type>.<sub_type>", "<obj>"] },
						{ "id": "null", "action": "return", "args": [{ "used": "<fill_by>", "unused": "<left_over>" }] },
					],

					minus: [
						["char_path", "type", "sub_type", "amount"],
						// Read the existing values for the character
						{ "id": "obj", "action": "read", "args": ["save_d", "<char_path>.stats.<type>.<sub_type>"] },
						// Get the amount to empty by and any left over amount
						{ "id": "use_by", "action": "ifelse", "args": [["<obj.total>", ">=", "<amount>"], "<amount>", "<obj.total>"] },
						{ "id": "left_over", "action": "branch", "args": [["<obj.total>", ">=", "<amount>"], { "action": "resolve", "args": [0] }, { "action": "math", "args": ["<amount>", "-", "<obj.total>"] }] },
						// Add it back to the attribute
						{ "id": "total", "action": "math", "args": ["<obj.total>", "-", "<use_by>"] },
						{ "id": "obj", "action": "set", "args": ["<obj>", "total", "<total>"] },
						// Write the updates back to the stat
						{ "id": "d_write", "action": "write", "args": ["save_d", "<char_path>.stats.<type>.<sub_type>", "<obj>"] },
						{ "id": "null", "action": "event", "args": ["<char_path>.stats.<type>.<sub_type>.<total>"] },
						{ "id": "null", "action": "return", "args": [{ "used": "<use_by>", "unused": "<left_over>" }] },
					],
				}
			},
		},

		inventory: {
			item: {
				add: [
					["party", "char_idx", "item"],
					{ "id": "item_at", "action": "concat", "args": ["save_d", "<party>.<char_idx>.inventory.items", "<item>"] },
					{ "id": "null", "action": "return", "args": ["inventory.items.<item_at.idx>"] },
				],

				get: [
					["type", "item"],
					{ "id": "item", "action": "copy", "args": ["game_d", "tables.items.<type>.<item>"] },
					{ "id": "null", "action": "return", "args": ["<item>"] },
				],

				use: [
					["party", "char_idx", "item_path"],
					{ "id": "item", "action": "read", "args": ["save_d", "<party>.<char_idx>.<item_path>"] },

					// Get and run the reference effect and store the key in the heap
					{ "id": "meta", "action": "get", "args": ["<item>", "item"] },
					{ "id": "results", "action": "loop", "args": ["effects.add", "<meta>", ["<party>", "<char_idx>", "<item_path>", "$idx$"]] },

					// If an equipped.* is in the meta retrieve the path to return
					{ "id": "path", "action": "filter", "args": ["<results>", "equipped", "~", "1:*"] },
					{ "id": "item_path", "action": "ifelse", "args": [["<path>", "!=", undefined], "<path>", "<item_path>"] },

					// Trigger the rest of the effects with the reference in the heap
					{ "id": "effects", "action": "get", "args": ["<item>", "effects"] },
					{ "id": "item", "action": "loop", "args": ["effects.add", "<effects>", ["<party>", "<char_idx>", "<item_path>", "$idx$"]] },
					{ "id": "null", "action": "return", "args": ["<item_path>"] },
				],

				drop: [],
			},

			supply: {
				edit: [
					["party", "char_idx", "type", "amount"],
					{ "id": "supply", "action": "read", "args": ["save_d", "<party>.<char_idx>.inventory.supplies.<type>"] },
					{ "id": "supply", "action": "math", "args": ["<supply>", "+", "<amount>"] },
					{ "id": "supply", "action": "clamp", "args": ["<supply>", 0, 100] },
					{ "id": "supply", "action": "write", "args": ["save_d", "<party>.<char_idx>.inventory.supplies.<type>", "<supply>"] },
					// Log delta
					{ "id": "name", "action": "read", "args": ["save_d", "<party>.<char_idx>.name"] },
					{ "id": "log", "action": "log", "args": ["<name> gained <amount> supplies.<type>."] },
				],

				check: [
					["char_idx", "type", "amount"],
					{ "id": "supply", "action": "read", "args": ["save_d", "<party>.<char_idx>.inventory.supplies.<type>"] },
					{ "id": "is_enough", "action": "math", "args": ["<supply>", ">=", "<amount>"] },
					{ "id": "null", "action": "return", "args": ["<is_enough>"] },
				],
			},

			equipment: {
				equip: [
					["party", "char_idx", "source_ref", "equip_slot"],
					// Read the equipment slot value and the inventory slot value
					{ "id": "equipped", "action": "read", "args": ["save_d", "<party>.<char_idx>.<equip_slot>"] },
					{ "id": "item", "action": "read", "args": ["save_d", "<party>.<char_idx>.<source_ref>"] },
					// If the equipment slot is not empty then remove all modifiers given by the equipment slot item
					{ "id": "keys", "action": "read", "args": ["save_d", "<party>.<char_idx>.modifiers./<equip_slot>/:[]"] },
					{ "id": "null", "action": "loop", "args": ["effects.delete", "<keys>", ["<party>", "<char_idx>", "<equip_slot>", "$idx$"]] },
					// Swap the items places in memory
					{ "id": "null", "action": "write", "args": ["save_d", "<party>.<char_idx>.<equip_slot>", "<item>"] },
					{
						"id": "null", "action": "branch", "args": [["<equipped>", "==", null],
						{ "action": "delete", "args": ["save_d", "<party>.<char_idx>.<source_ref>"] },
						{ "action": "write", "args": ["save_d", "<party>.<char_idx>.<source_ref>", "<equipped>"] }]
					},
					// Log equipping
					{ "id": "name", "action": "read", "args": ["save_d", "<party>.<char_idx>.name"] },
					{ "id": "log", "action": "notify", "args": ["<name> equipped a <item.name> to <equip_slot>"] },
					// Event equips
					{ "id": "null", "action": "event", "args": ["<party>.<char_idx>.<equip_slot>.<item.name>", ["<party>.<char_idx>.<equip_slot>.<item.name>", "<item>"]] },
					{ "id": "null", "action": "return", "args": ["<equip_slot>"] },
				],

				unequip: [
					["party", "char_idx", "source_ref", "equip_slot"],
					{ "id": "equipped", "action": "read", "args": ["save_d", "<party>.<char_idx>.<equip_slot>"] },
					//Clean up all the effects
					{ "id": "keys", "action": "read", "args": ["save_d", "<party>.<char_idx>.modifiers./<equip_slot>/:[]"] },
					{ "id": "null", "action": "loop", "args": ["effects.delete", "<keys>", ["<party>", "<char_idx>", "<equip_slot>", "$idx$"]] },
					{ "id": "null", "action": "delete", "args": ["save_d", "<party>.<char_idx>.modifiers./<equip_slot>/"] },
					// Move the item to the inventory
					{ "id": "item_at", "action": "concat", "args": ["save_d", "<party>.<char_idx>.inventory.items", "<equipped>"] },
					{ "id": "null", "action": "write", "args": ["save_d", "<party>.<char_idx>.<equip_slot>", "null"] },
					// Notify about the changes
					{ "id": "null", "action": "event", "args": ["<party>.<char_idx>.<equip_slot>", ["<party>.<char_idx>.<equip_slot>", null]] },
					{ "id": "name", "action": "read", "args": ["save_d", "<party>.<char_idx>.name"] },
					{ "id": "log", "action": "notify", "args": ["<name> unequipped a <equipped.name> from <equip_slot>"] },
				],

				repair: [],
			},
		},

		light_sources: {
			add: [
				["party", "char_idx", "source_ref", "effect_id"],
				// Add a reference to the effect
				{ "id": "result", "action": "inject", "args": ["character.attributes.references.add", ["<party>", "<char_idx>", "<source_ref>", "<effect_id>"]] },
				// Set the light_source
				{ "id": "null", "action": "write", "args": ["save_d", "<party>.<char_idx>.light_source", "<source_ref.0>"] },
			],

			delete: [
				["party", "char_idx", "source_ref", "effect_id"],
				// Delete the reference to the effect
				{ "id": "result", "action": "inject", "args": ["character.attributes.references.delete", ["<party>", "<char_idx>", "<source_ref>", "<effect_id>"]] },
				// Delete the light_source
				{ "id": "null", "action": "write", "args": ["save_d", "<party>.<char_idx>.light_source", "null"] },
			],

			use: {
				party: [
					["party"],
					{ "id": "party_size", "action": "size", "args": ["save_d", "<party>"] },
					{ "id": "p_range", "action": "range", "args": ["<party_size>"] },
					{ "id": "loop", "action": "loop", "args": ["character.light_sources.use.tick", "<p_range>", ["<party>", "$idx$"]] },
				],

				tick: [
					["party", "char_idx"],
					{ "id": "source_ref", "action": "read", "args": ["save_d", "<party>.<char_idx>.light_source"] },
					// If the light source is null then return
					{ "id": "null", "action": "branch", "args": [["<source_ref>", "==", undefined], { "action": "return" }] },
					// Decrement the use counter
					{ "id": "uses", "action": "read", "args": ["save_d", "<party>.<char_idx>.<source_ref>.meta.use"] },
					{ "id": "light", "action": "math", "args": [["<uses.at>", "-", "<uses.by>"], "max", 0] },
					{ "id": "light", "action": "write", "args": ["save_d", "<party>.<char_idx>.<source_ref>.meta.use.at", "<light>"] },
					// Log light source stats
					{ "id": "name", "action": "read", "args": ["save_d", "<party>.<char_idx>.name"] },
					{ "id": "null", "action": "log", "args": ["<name>'s used light source: (<uses.at>/<uses.max>)"] },
					// If 0 and a consumable item then delete it
					{ "id": "null", "action": "branch", "args": [["<uses.at>", "==", 0], { "action": "inject", "args": ["character.light_sources.use.consumed", ["<party>", "<char_idx>", "<source_ref>"]] }] },
				],

				by: [
					["party", "char_idx", "by_amount"],
					{ "id": "source_ref", "action": "read", "args": ["save_d", "<party>.<char_idx>.light_source"] },
					// If the light source is null then return
					{ "id": "null", "action": "branch", "args": [["<source_ref>", "==", undefined], { "action": "return" }] },
					// Decrement the use counter
					{ "id": "uses", "action": "read", "args": ["save_d", "<party>.<char_idx>.<source_ref>.meta.use"] },
					{ "id": "light", "action": "math", "args": [["<uses.at>", "-", "<by_amount>"], "max", 0] },
					{ "id": "light", "action": "write", "args": ["save_d", "<party>.<char_idx>.<source_ref>.meta.use.at", "<light>"] },
					// Log light source stats
					{ "id": "name", "action": "read", "args": ["save_d", "<party>.<char_idx>.name"] },
					{ "id": "null", "action": "log", "args": ["<name>'s used light source: (<uses.at>/<uses.max>)"] },
					// If 0 and a consumable item then delete it
					{ "id": "null", "action": "branch", "args": [["<uses.at>", "==", 0], { "action": "inject", "args": ["character.light_sources.use.consumed", ["<party>", "<char_idx>", "<source_ref>"]] }] },
				],

				consumed: [
					["party", "char_idx", "source_ref"],
					// Log the light source being consumed
					{ "id": "name", "action": "read", "args": ["save_d", "<party>.<char_idx>.name"] },
					{ "id": "source", "action": "read", "args": ["save_d", "<party>.<char_idx>.<source_ref>.name"] },
					{ "id": "type", "action": "read", "args": ["save_d", "<party>.<char_idx>.<source_ref>.type"] },
					{ "id": "null", "action": "log", "args": ["<name>'s <source> has run out"] },
					// Is if a consumable
					{ "id": "null", "action": "branch", "args": [["<type>", "!=", "light_use"], { "action": "return" }] },
					// Delete the item
					{ "id": "null", "action": "write", "args": ["save_d", "<party>.<char_idx>.<source_ref>", "null"] },
					{ "id": "null", "action": "inject", "args": ["character.light_sources.delete", ["<party>", "<char_idx>", "<source_ref>", "light_source"]] },
				],
			}
		},

		listener: {
			add: [
				["party", "char_idx", "audience", "listener", "limit", "events"],
				{ "id": "log", "action": "log", "args": ["<party>.<char_idx>:<audience>:<listener>"] },
				{ "id": "null", "action": "listen", "args": ["<party>.<char_idx>:<audience>:<listener>", "+", "<events>", "<limit>"] }
			],

			delete: [
				["party", "char_idx", "audience", "listener", "limit", "events"],
				{ "id": "log", "action": "log", "args": ["<party>.<char_idx>:<audience>:<listener>"] },
				{ "id": "null", "action": "listen", "args": ["<party>.<char_idx>:<audience>:<listener>", "-", "<events>", "<limit>"] }
			],
		},
	},

	// ------------------------------------------------------------------------------------------------------- Effects
	effects: {
		add: [
			["party", "char_idx", "source_ref", "effect_id"],
			{ "id": "effect", "action": "copy", "args": ["game_d", "tables.effects.<effect_id>"] },
			{ "id": "e_rule", "action": "get", "args": ["<effect>", "rule"] },
			{ "id": "e_args", "action": "get", "args": ["<effect>", "args"] },
			{ "id": "e_args", "action": "var_sub", "args": [0, "<e_args>"] },
			{ "id": "result", "action": "inject", "args": ["<e_rule.0>.<e_rule.1>", "<e_args>"] },
			{ "id": "null", "action": "return", "args": ["<result>"] },
		],

		add_to_party: [
			["party", "source_ref", "effect_id"],
			{ "id": "party_size", "action": "size", "args": ["save_d", "<party>"] },
			{ "id": "p_range", "action": "range", "args": ["<party_size>"] },
			{ "id": "effects", "action": "loop", "args": ["effects.add", "<p_range>", ["<party>", "$idx$", "<source_ref>", "<effect_id>"]] },
			{ "id": "null", "action": "return", "args": ["<effects>"] },
		],

		add_many: [
			["party", "char_idx", "source_ref", "effect_ids"],
			{ "id": "effects", "action": "loop", "args": ["effects.add", "<effect_ids>", ["<party>", "<char_idx>", "<source_ref>", "$idx$"]] },
			{ "id": "null", "action": "return", "args": ["<effects>"] },
		],

		add_many_to_party: [
			["party", "source_ref", "effect_ids"],
			{ "id": "party_size", "action": "size", "args": ["save_d", "<party>"] },
			{ "id": "p_range", "action": "range", "args": ["<party_size>"] },
			{ "id": "effects", "action": "loop", "args": ["effects.add_many", "<p_range>", ["<party>", "$idx$", "<source_ref>", "<effect_ids>"]] },
			{ "id": "null", "action": "return", "args": ["<effects>"] },
		],

		delete: [
			["party", "char_idx", "source_ref", "effect_id"],
			{ "id": "effect", "action": "copy", "args": ["game_d", "tables.effects.<effect_id>"] },
			{ "id": "e_rule", "action": "get", "args": ["<effect>", "rule"] },
			{ "id": "e_args", "action": "get", "args": ["<effect>", "args"] },
			{ "id": "e_args", "action": "var_sub", "args": [0, "<e_args>"] },
			{ "id": "result", "action": "branch", "args": ["<e_rule.2>", { "action": "inject", "args": ["<e_rule.0>.<e_rule.2>", "<e_args>"] }] },
			{ "id": "null", "action": "return", "args": ["<result>"] },
		],

		counters: {
			add: [
				["party", "char_idx", "source_ref", "type", "counter"],
				{ "id": "counter", "action": "set", "args": ["<counter>", "max", "<counter.at>"] },
				{ "id": "null", "action": "write", "args": ["save_d", "<party>.<char_idx>.<source_ref>.meta:{}.<type>", "<counter>"] },
			],

			reduce: [
				["party", "char_idx", "source_ref", "type"],
				{ "id": "counter", "action": "read", "args": ["save_d", "<party>.<char_idx>.<source_ref>.meta:{}.<type>"] },
				{ "id": "delta", "action": "math", "args": ["<counter.at>", "-", "<counter.by>"] },
				{ "id": "counter", "action": "set", "args": ["<counter>", "at", "<delta>"] },
				{ "id": "null", "action": "write", "args": ["save_d", "<party>.<char_idx>.<source_ref>.meta:{}.<type>", "<counter>"] },
			],

			reset: [
				["party", "char_idx", "source_ref", "type"],
				{ "id": "counter", "action": "read", "args": ["save_d", "<party>.<char_idx>.<source_ref>.meta:{}.<type>"] },
				{ "id": "counter", "action": "set", "args": ["<counter>", "at", "<counter.max>"] },
				{ "id": "null", "action": "write", "args": ["save_d", "<party>.<char_idx>.<source_ref>.meta:{}.<type>", "<counter>"] },
			],
		},

		surprise_companion_penalty: {
			add: [
				["party", "char_idx", "source_ref", "effect_id"],
				// Determine surprise penalty and subtract it from the stealth check: (n - 1) * 10
				{ "id": "attack_s", "action": "size", "args": ["save_d", "<party>"] },
				{ "id": "penalty", "action": "math", "args": [[["<attack_s>", "-", 1], "*", 10]] },
				{ "id": "null", "action": "branch", "args": [["<penalty>", "==", 0], { "action": "return" }] },
				{ "id": "null", "action": "inject", "args": ["effects.add", ["<party>", "<char_idx>", "<source_ref>.proc", "skill.stealth.-<penalty>"]] },
			],

			delete: [
				["party", "char_idx", "source_ref", "effect_id"],
				{ "id": "attack_s", "action": "size", "args": ["save_d", "<party>"] },
				{ "id": "penalty", "action": "math", "args": [[["<attack_s>", "-", 1], "*", 10]] },
				{ "id": "null", "action": "branch", "args": [["<penalty>", "==", 0], { "action": "return" }] },
				{ "id": "null", "action": "inject", "args": ["effects.delete", ["<party>", "<char_idx>", "<source_ref>.proc", "skill.stealth.-<penalty>"]] },
			],
		},

		surprise_fail_penalty: {
			add: [
				["party", "char_idx", "source_ref", "effect_id"],
				{ "id": "null", "action": "inject", "args": ["effects.add", ["<party>", "<char_idx>", "<source_ref>.proc", "skill.stealth.-10"]] },
			],

			delete: [
				["party", "char_idx", "source_ref", "effect_id"],
				{ "id": "null", "action": "inject", "args": ["effects.delete", ["<party>", "<char_idx>", "<source_ref>.proc", "skill.stealth.-10"]] },
			],
		},
	},

	// ------------------------------------------------------------------------------------------------------- Actions
	actions: {
		flow: {
			damage: {
				resolve: [
					["results", "body_idx", "action"],
					// Is the initiator first in move order: for piercing damage
					{ "id": "is_first", "action": "read", "args": ["save_d", "combat_order"] },
					{ "id": "is_first", "action": "math", "args": ["<is_first.0>", "==", "<results.1.party>"] },
					// Is the defender armored: for slash/bludgeon damage
					{ "id": "armor", "action": "inject", "args": ["character.attributes.enums.get", "<results.2.party>.<results.2.idx>", "defense", "armor"] },
					{ "id": "armor", "action": "math", "args": ["<armor>", ".", "<body_idx>"] },
					{ "id": "is_armor", "action": "math", "args": ["<armor>", ">", 0] },
					// Create var with armor and first
					{ "id": "meta", "action": "resolve", "args": [{ "is_first": "<is_first>", "is_armor": "<is_armor>", "armor": "<armor>" }] },

					// Store values in the heap so that other events can add to it
					{ "id": "name", "action": "read", "args": ["save_d", "<results.1.party>.<results.1.idx>.name"] },
					{ "id": "null", "action": "h_put", "args": ["<results.1.party>.<results.1.idx>.<name>", "<action>"] },
					{ "id": "null", "action": "event", "args": ["<results.1.party>.<results.1.idx>.combat.action.damage", { "path": "<results.1.party>.<results.1.idx>", "name": "<name>" }] },
					{ "id": "actions", "action": "h_get", "args": ["<results.1.party>.<results.1.idx>.<name>"] },

					// Critical count for determining how many times to apply the action (aka some perks x3 crit)
					{ "id": "crit_itr", "action": "resolve", "args": [{ "idx": 0, "limit": 0 }] },
					{ "id": "null", "action": "branch", "args": ["<results.1.roll.crit>", null, { "action": "goto", "args": ["id.rolls.next"] }] },
					{ "id": "tribe", "action": "event", "args": ["save_d", "<results.2.party>.<results.2.idx>.biography.tribe"] },
					{ "id": "crit_itr", "action": "resolve", "args": [{ "idx": 0, "limit": 1 }] },
					{ "id": "null", "action": "event", "args": ["<results.1.party>.<results.1.idx>.combat.action.damage.critical", { "id": "<results.2.party>.<results.2.idx>", "tribe": "<tribe>" }] },

					// Determine how many damage rolls need to happen based off action and crit
					{ "id": "rolls", "action": "resolve", "args": [["<actions>"]] },
					{ "id": "add_rolls", "action": "branch", "args": [["<crit_itr.idx>", "<", "<crit_itr.limit>"], null, { "action": "goto", "args": ["id.dmg_sets.next"] }] },
					{ "id": "rolls", "action": "concat", "args": ["<actions>"] },
					{ "id": "incr", "action": "math", "args": ["<crit_itr.idx>", "+", 1] },
					{ "id": "crit_itr", "action": "set", "args": ["<crit_iter>", "idx", "<incr>"] },
					{ "id": "rolls", "action": "goto", "args": ["id.add_rolls.prev"] },

					// Put the armor value into the heap
					{ "id": "null", "action": "h_put", "args": ["<results.2.party>.<results.2.idx>.armor", "<meta.armor>"] },
					// Loop over all initiator attack die and calculate the damage sets
					{ "id": "dmg_sets", "action": "loop", "args": ["actions.flow.damage.initiator", "<rolls>", ["<results>", "$idx$", "<meta>"]] },
					// Handle Modifiers
					{ "id": "dmg_sets", "action": "inject", "args": ["actions.flow.damage.modifiers", ["<results>", "<dmg_sets>", "<meta>"]] },
					// Loop over all the damage sets and apply them to the defender
					{ "id": "null", "action": "event", "args": ["<results.2.party>.<results.2.idx>.combat.action.damage.amount", "dmg_sets"] },
					{ "id": "hrt_sets", "action": "loop", "args": ["actions.flow.damage.defender", "<dmg_sets>", ["<results>", "$idx$", "<meta>"]] },
				],

				initiator: [
					["results", "action", "meta"],
					// Get damage roll
					{ "id": "damage", "action": "inject", "args": ["roll_plus_one", ["<action.1>"]] },
					{ "id": "pierce", "action": "ifelse", "args": [["meta.is_first", "==", true], "&", ["<action.0>", "==", "piercing"], 1, 0] },
					{ "id": "slash", "action": "ifelse", "args": [["meta.is_armor", "==", false], "&", ["<action.0>", "==", "slashing"], 1, 0] },
					{ "id": "damage", "action": "math", "args": [["<damage>", "+", "<pierce>"], "+", "<slash>"] },
					{ "id": "dealt", "action": "inject", "args": ["lookup_against_table", ["tables.damage_dealt", "<damage>"]] },
					// Return Attacker Rolled Damage set
					{ "id": "return", "action": "return", "args": [{ "roll": "<damage>", "amount": "<dealt>", "type": "<action.0>", "modifier": "<action.2>" }] },
				],

				modifiers: [
					["results", "damage", "meta"],
					// Find the lowest roll among them
					{ "id": "lowest", "action": "reduce", "args": ["<damage.0>", "<"] },
					{ "id": "mod_dmg", "action": "reduce", "args": ["<lowest.1.3>", "+"] },
					// Update the lowest roll with the modifiers
					{ "id": "mod_dmg", "action": "reduce", "args": ["<lowest.1.0>", "+", "<mod_dmg>"] },
					{ "id": "mod_dealt", "action": "inject", "args": ["lookup_against_table", ["tables.damage_dealt", "<mod_dmg>"]] },
					{ "id": "mod", "action": "resolve", "args": [{ "roll": "<mod_dmg>", "amount": "<mod_dealt>", "type": "<lowest.1.2>", "modifier": "<lowest.1.3>" }] },
					// Update the damage list at the lowest idx
					{ "id": "updated", "action": "set", "args": ["<results>", "<lowest.0>", "<mod>"] },
					{ "id": "return", "action": "return", "args": ["<updated>"] },
				],

				defender: [
					["results", "damage", "meta"],
					// Handle armor and Bludgeoning
					{ "id": "armor", "action": "h_get", "args": ["<results.2.party>.<results.2.idx>.armor"] },
					{ "id": "bludge", "action": "ifelse", "args": [[["<armor>", ">", 0], "&", ["<damage.type>", "==", "bludgeoning"], "&", ["<damage.amount>", ">", 0]], 1, 0] },
					{ "id": "armor", "action": "math", "args": ["<armor>", "-", "<bludge>"] },
					{ "id": "armor", "action": "branch", "args": [["<armor>", ">", "<damage.amount>"], { "action": "math", "args": ["<armor>", "-", "<damage.amount>"] }, { "action": "resolve", "args": [0] }] },
					{ "id": "dmg_dlt", "action": "branch", "args": [["<damage.amount>", ">", "<armor>"], { "action": "math", "args": ["<damage.amount>", "-", "<armor>"] }, { "action": "resolve", "args": [0] }] },
					{ "id": "armor", "action": "h_put", "args": ["<results.2.party>.<results.2.idx>.armor", "<armor>"] },

					// Get defense modifiers
					{ "id": "dmg_table", "action": "read", "args": ["game_d", "tables.damage_types"] },
					{ "id": "dmg_idx", "action": "reduce", "args": ["<dmg_table>", "==", "<damage.type>"] },
					{ "id": "affinity", "action": "read", "args": ["save_d", "<results.2.party>.<results.2.idx>.enums.defence.affinity"] },
					{ "id": "affinity", "action": "get", "args": ["<affinity>", "<dmg_idx.0>"] },
					{ "id": "reduction", "action": "read", "args": ["save_d", "<results.2.party>.<results.2.idx>.enums.defence.reduction"] },
					{ "id": "reduction", "action": "get", "args": ["<reduction>", "<dmg_idx.0>"] },

					// Adjust damage by Affinity/Reduction
					{ "id": "dmg_dlt", "action": "math", "args": ["<dmg_dlt>", "*", "<affinity>"] },
					{ "id": "dmg_dlt", "action": "math", "args": ["<dmg_dlt>", "-", "<reduction>"] },
					{ "id": "all_dealt", "action": "resolve", "args": ["<dmg_dlt>"] },

					// Apply Damage to Toughness
					{ "id": "remainder", "action": "inject", "args": ["character.attributes.stats.points.minus", ["<results.2.party>", "<results.2.idx>", "base", "toughness", "<all_dealt>"]] },
					// Apply Damage to Health
					{ "id": "remainder", "action": "inject", "args": ["character.attributes.stats.points.minus", ["<results.2.party>", "<results.2.idx>", "base", "health", "<remainder.unused>"]] },
					// Return received damage
					{ "id": "return", "action": "return", "args": ["<all_dealt>"] },
				]
			},

			recover: {
				resolve: [
					["results", "body_idx", "action"],
					// Store values in the heap so that other events can add to it
					{ "id": "name", "action": "read", "args": ["save_d", "<results.1.party>.<results.1.idx>.name"] },
					{ "id": "null", "action": "h_put", "args": ["<results.1.party>.<results.1.idx>.<name>", "<action>"] },
					{ "id": "null", "action": "event", "args": ["<results.1.party>.<results.1.idx>.combat.action.recover", { "path": "<results.1.party>.<results.1.idx>", "name": "<name>" }] },
					{ "id": "actions", "action": "h_get", "args": ["<results.1.party>.<results.1.idx>.<name>"] },

					// Critical count for determining how many times to apply the action (aka some perks x3 crit)
					{ "id": "crit_itr", "action": "resolve", "args": [{ "idx": 0, "limit": 0 }] },
					{ "id": "null", "action": "branch", "args": ["<results.1.roll.crit>", null, { "action": "goto", "args": ["id.rolls.next"] }] },
					{ "id": "tribe", "action": "event", "args": ["save_d", "<results.2.party>.<results.2.idx>.biography.tribe"] },
					{ "id": "crit_itr", "action": "resolve", "args": [{ "idx": 0, "limit": 1 }] },
					{ "id": "null", "action": "event", "args": ["<results.1.party>.<results.1.idx>.combat.action.recover.critical", { "id": "<results.2.party>.<results.2.idx>", "tribe": "<tribe>" }] },

					// Determine how many damage rolls need to happen based off action and crit
					{ "id": "rolls", "action": "resolve", "args": [["<actions>"]] },
					{ "id": "add_rolls", "action": "branch", "args": [["<crit_itr.idx>", "<", "<crit_itr.limit>"], null, { "action": "goto", "args": ["id.dmg_sets.next"] }] },
					{ "id": "rolls", "action": "concat", "args": ["<actions>"] },
					{ "id": "incr", "action": "math", "args": ["<crit_itr.idx>", "+", 1] },
					{ "id": "crit_itr", "action": "set", "args": ["<crit_iter>", "idx", "<incr>"] },
					{ "id": "rolls", "action": "goto", "args": ["id.add_rolls.prev"] },

					// Loop over all initiator attack die and calculate the damage sets
					{ "id": "rcvr_sets", "action": "loop", "args": ["actions.flow.recover.initiator", "<rolls>", ["<results>", "$idx$"]] },
					// Handle Modifiers
					{ "id": "rcvr_sets", "action": "inject", "args": ["actions.flow.recover.modifiers", ["<results>", "<rcvr_sets>"]] },
					// Loop over all the damage sets and apply them to the defender
					{ "id": "null", "action": "event", "args": ["<results.2.party>.<results.2.idx>.combat.recover.amount", "rcvr_sets"] },
					{ "id": "heal_sets", "action": "loop", "args": ["actions.flow.recover.defender", "<rcvr_sets>", ["<results>", "$idx$"]] },
				],

				initiator: [
					["results", "action"],
					// Get damage roll
					{ "id": "recover", "action": "inject", "args": ["roll_plus_one", ["<action.1>"]] },
					// Return Initiator Rolled Recovery
					{ "id": "return", "action": "return", "args": [{ "roll": "<recover>", "amount": "<recover>", "type": "<action.0>", "modifier": "<action.2>" }] },
				],

				modifiers: [
					["results", "recover"],
					// Find the lowest roll among them
					{ "id": "lowest", "action": "reduce", "args": ["<recover.roll>", "<"] },
					{ "id": "mod_rcvr", "action": "math", "args": ["<recover>", ".", "roll"] },
					{ "id": "mod_rcvr", "action": "reduce", "args": ["<mod_rcvr>", "+"] },
					// Update the lowest roll with the modifiers
					{ "id": "mod_rcvr", "action": "reduce", "args": ["<lowest.1.roll>", "+", "<mod_rcvr>"] },
					{ "id": "mod", "action": "resolve", "args": [{ "roll": "<mod_rcvr>", "amount": "<mod_rcvr>", "type": "<lowest.1.type>", "modifier": "<lowest.1.modifier>" }] },
					// Update the damage list at the lowest idx
					{ "id": "updated", "action": "set", "args": ["<results>", "<lowest.0>", "<mod>"] },
					{ "id": "return", "action": "return", "args": ["<updated>"] },
				],

				defender: [
					["results", "recover", "meta"],
					// Apply Recovery to Toughness
					{ "id": "remainder", "action": "inject", "args": ["character.attributes.stats.fill", ["<results.2.party>", "<results.2.idx>", "base", "toughness", "<recover>"]] },
					// Apply Recovery to Health
					{ "id": "remainder", "action": "inject", "args": ["character.attributes.stats.fill", ["<results.2.party>", "<results.2.idx>", "base", "health", "<remainder.unused>"]] },
					// Return received damage
					{ "id": "return", "action": "return", "args": ["<recover>"] },
				]
			},

			effect: {
				resolve: [
					["results", "body_idx", "status"],
					// Roll for saving throw
					{ "id": "results", "action": "inject", "args": ["dice.skill.check", ["<results.2.party>", "<results.2.idx>", "<status.type>", "<status.sub_type>"]] },
					// If failed apply effect
					{ "id": "check", "action": "branch", "args": ["<results.pass>", { "action": "return" }] },
					{ "id": "effect", "action": "loop", "args": ["effects.add", "<status.effects>", ["<results.2.party>", "<results.2.idx>", "combat.$idx$", "$idx$"]] },
				],
			}
		},

		basic: {
			roll: {
				damage: [
					["results", "body_part", "action"],
					{ "id": "null", "action": "inject", "args": ["actions.flow.damage.resolve", ["<results>", "<body_part>", "<action>"]] },
				],

				recover: [
					["results", "body_part", "action"],
					{ "id": "null", "action": "inject", "args": ["actions.flow.recover.resolve", ["<results>", "<body_part>", "<action>"]] },
				],

				effect: [
					["results", "body_part", "action"],
					{ "id": "null", "action": "inject", "args": ["actions.flow.effect.resolve", ["<results>", "<body_part>", "<action>"]] },
				],
			}
		},

		masteries: {

		},

		// ------------------------------------------------------------------------------------------------------- Enemies
		enemies: {
			skeletal_horror: {
				ethereal_grasp: [
					["initiator_party", "initiator_idx", "defender_party", "defender_idx", "action"],
					// Roll skill check
					{ "id": "is_failed", "action": "inject", "args": ["dice.damage.magical_effect_roll", ["__0__", "__1__", "__2__", "__3__", "__4__"]] },
					{ "id": "extra_mods", "action": "ifelse", "args": ["<is_failed.0>", ["/", 2], ["+", 0]] },
					// Roll Damage
					{ "id": "attacks", "action": "inject", "args": ["handle_damage_rolls", ["__0__", "__1__", "<attack_die>", "<is_armor>"]] },
					{ "id": "defended", "action": "loop", "args": ["resolve_defender_damaged", "<dmg_sets>", ["__2__.__3__", "$idx$", "<is_armor>", "<extra_mods>"]] },
					{ "id": "sum_dmg_1", "action": "reduce", "args": ["<defended>", "+"] },
					// Roll Crit Damage
					{ "id": "attacks", "action": "branch", "args": [["<is_failed.1>", "==", 1], { "action": "inject", "args": ["handle_damage_rolls", ["__0__", "__1__", "<attacks>", "<is_armor>"]] }, null] },
					{ "id": "defended", "action": "branch", "args": [["<is_failed.1>", "==", 1], { "action": "loop", "args": ["resolve_defender_damaged", "<attacks>", ["__2__.__3__", "$idx$", "<is_armor>"]] }, null] },
					{ "id": "sum_dmg_2", "action": "branch", "args": [["<is_failed.1>", "==", 1], { "action": "reduce", "args": ["<defended>", "+"] }, null] },
					{ "id": "dummy", "action": "branch", "args": ["<is_failed.0>", { "action": "return" }] },
					// If is_successful
					{ "id": "healing", "action": "math", "args": [["<sum_dmg_1>", "+", "<sum_dmg_2>"], "/", 2] },
					{ "id": "health", "action": "read", "args": ["<save_d>", "__0__.__1__.stats.health"] },
					{ "id": "healing", "action": "math", "args": ["<healing>", "+", "<health>"] },
					{ "id": "healing", "action": "clamp", "args": ["<healing>", 0, "<health.1>"] },
					{ "id": "healed", "action": "write", "args": ["save_d", "__0__.__1__.stats.health.0", "<healing>"] },
				],

				haunting_wail: [
					["initiator_party", "initiator_idx", "defender_party", "defender_idx", "action"],
					// Roll skill check
					{ "id": "is_failed", "action": "inject", "args": ["dice.damage.magical_effect_roll", ["__0__", "__1__", "__2__", "__3__", "__4__"]] },
					{ "id": "dummy", "action": "branch", "args": ["<is_failed.0>", { "action": "return" }] },
					// Get effects on Char
					{ "id": "def_effect", "action": "read", "args": ["save_d", "__0__.__1__.effects.turn"] },
					{ "id": "effect_ids", "action": "filter", "args": ["id", "<def_effect>", ".", "1:*"] },
					{ "id": "effect_idx", "action": "reduce", "args": ["<effect_ids>", "==", "stun"] },
					{ "id": "stun", "action": "branch", "args": [["<effect_idx.0>", ">=", -1], { "action": "get", "args": ["<def_effect>", "<effect_idx.0>"] }, { "id": "stun", "#": 1 }] },
					{ "id": "stun", "action": "branch", "args": [["<effect_idx.0>", ">=", 0], { "action": "save", "args": ["save_d", "__0__.__1__.effects.turn.<effect_idx>", "<stun>"] }, { "action": "concat", "args": ["save_d", "__0__.__1__.effects.turn", "<stun>"] }] },
				],

				vengeful_onslaught: [
					["initiator_party", "initiator_idx", "defender_party", "defender_idx", "action"],
					// Roll skill check
					{ "id": "is_failed", "action": "inject", "args": ["physical_attack_roll", ["__0__", "__1__", "__2__", "__3__", "__4__"]] },
					{ "id": "dummy", "action": "branch", "args": ["<is_failed.0>", { "action": "return" }] },
					{ "id": "free_action", "action": "inject", "args": ["save_d", ["__0__.__1__.combat.standard.actions.1"]] },
				],
			},
		},
	},
})

</script>

<script>
const Level_Enum = Object.freeze({ "Error": 0, "Warn": 1, "Log": 2, "Func": 3, "Debug": 4 });
const Levels = Object.freeze(["Error", "Warn", "Log", "Log", "Debug"]);
const logger = Object({
	enabled: true,
	filters: {
		context: [],
		level: Level_Enum.Debug,
	},

	_main: function(_level, _caller, _text, _args, _pretty, _template_id) {
		if (this.enabled) {
			let args = [];

			if (_args) {
				if (typeof _args == "object") {
					for(let arg of _args){
						if(typeof arg == "object") {
							args.push((_pretty) ? JSON.stringify(arg,null,2) : JSON.stringify(arg));
						} else if (typeof arg == "function") {
							args.push(`${arg.name}()`);
						} else {
							args.push(arg);
						}
					}
				} else {
					args = [_args];
				}
			}

			let passed_filter = (
				(this.filters.context.length == 0 || 
					this.filters.context.includes(_caller)) &&
					(this.filters.level >= _level)
			)

			if (passed_filter) {
				let method = console[(Levels[_level]).toLowerCase()];
				switch(_template_id) {
					case("func"):
						method(`${_text}(${args})`);
						break;
					default:
						method((args) ? `${_text}: ${args}` : `${_text}`);
				}
			}
		}
	},

	error:	function(_caller, _text, _args=null, _pretty=false, _template_id="default") { this._main(Level_Enum.Error,	_caller, _text, _args, _pretty, _template_id) },
	warn: 	function(_caller, _text, _args=null, _pretty=false, _template_id="default") { this._main(Level_Enum.Warn,	_caller, _text, _args, _pretty, _template_id) },
	func: 	function(_caller, _text, _args=null, _pretty=false, _template_id="func") 	 { this._main(Level_Enum.Func, 	_caller, _text, _args, _pretty, _template_id) },
	log: 	function(_caller, _text, _args=null, _pretty=false, _template_id="default") { this._main(Level_Enum.Log,	_caller, _text, _args, _pretty, _template_id) },
	debug: 	function(_caller, _text, _args=null, _pretty=false, _template_id="default") { this._main(Level_Enum.Debug,	_caller, _text, _args, _pretty, _template_id) },
});
</script>

<script>
const storage = Object({
	db: null,
	version: null,

	_version: function(_namespace, _action=null) {
		this.version = localStorage.getItem("storage-version");

		if (this.version == null) {
			this.version = 1;
			localStorage.setItem(`${_namespace}-storage-version`, this.version);
		}

		switch(_action) {
			case("increment"):
				this.version += 1;
				localStorage.setItem(`${_namespace}-storage-version`, this.version);
				break;
			case("delete"):
				this.version = null;
				localStorage.removeItem(`${_namespace}-storage-version`);
				break;
		}
	},

	_open_db: function(_namespace, _schema) {
		if (this.version == null) { this._version(_namespace); }

		if (this.db && this.db.name == _namespace) {
			return Promise.resolve(this.db);

		} else {
			return new Promise(function(_resolve, _reject) {
				const request = indexedDB.open(_namespace, this.version);
				request.onerror = (_event) => {
					_reject(_event);
				};

				request.onupgradeneeded = function(_event) {
					logger.log("storage", `Updating db schema for: ${_namespace}.`);
					_schema(_event.target.result);
				}.bind(this);

				request.onsuccess = function(_event) {
					logger.log("storage", `Opened db: ${_namespace}`)
					this.db = _event.target.result;
					_resolve(this.db);
				}.bind(this);
			}.bind(this))
		}
	},

	drop_db: function(_namespace) {
		return new Promise(function(_resolve, _reject) {
			if (this.db != null) {
				this.db.close();
			}

			const DBDeleteRequest = indexedDB.deleteDatabase(_namespace);

			DBDeleteRequest.onerror = (_event) => {
				console.error(`Database: ${_namespace}, errored on delete.`);
				_reject(_event)
			};
	
			DBDeleteRequest.onsuccess = (_event) => {
				console.log(`Database: ${_namespace}, deleted successfully`);
				_resolve(true);
			};
	
			this._version(_namespace, "delete");
		}.bind(this));
	},

	drop_table: function(_namespace, _table, _p_key) {
		return this._open_db(_namespace, function(_db) {
			_db.deleteObjectStore(_table);
		});
	},

	get_table_keys: function(_namespace, _table, _key) {
		return this._open_db(_namespace, schemas[_table])
			.then((_db) => {
				return new Promise(function(_resolve, _reject) {
					const store = _db.transaction([_table], "readonly").objectStore(_table);

					let keys = [];
					store.openCursor().onsuccess = (_event) => {
						const cursor = _event.target.result;

						if (cursor) {
							keys.push(cursor.key);
							cursor.continue();
						} else{
							_resolve(keys);
						}
					};
				});
			}
		);
	},

	create_data: function(_namespace, _table, _object) {
		return this._open_db(_namespace, schemas[_table])
			.then((_db) => {
				return new Promise(function(_resolve, _reject) {
					const store = _db.transaction([_table], "readwrite").objectStore(_table);
					const request = store.add(_object);

					request.onerror = (_event) => {
						console.log(_object);
						_reject(_event);
					};
		
					request.onsuccess = (_event) => {
						_resolve(_event);
					};
				});
			}
		);
	},

	read_data: function(_namespace, _table, _key) {
		return this._open_db(_namespace, schemas[_table])
			.then((_db) => {
				return new Promise(function(_resolve, _reject) {
					const store = _db.transaction([_table], "readonly").objectStore(_table);
					const request = store.get(_key);

					request.onerror = (_event) => {
						_reject(_event);
					};
		
					request.onsuccess = (_event) => {
						_resolve(_event.target.result);
					};
				});
			}
		);
	},

	update_data: function(_namespace, _table, _key, _kv_pairs) {
		return this._open_db(_namespace, schemas[_table])
			.then((_db) => {
				return new Promise(function(_resolve, _reject) {
					const store = _db.transaction([_table], "readwrite").objectStore(_table);
					const request = store.get(_key);

					request.onerror = (_event) => {
						_reject(_event);
					};
		
					request.onsuccess = (_event) => {
						const data = _event.target.result;
			
						for (let _pair of Object.entries(_kv_pairs)) {
							data[_pair[0]] = _pair[1];
						}
					
						// Put this updated object back into the database.
						const requestUpdate = store.put(data);
						requestUpdate.onerror = (_event) => {
							_reject(_event);
						}

						requestUpdate.onsuccess = (_event) => {
							_resolve(_event)
						}
					};
				});
			}
		);
	},

	delete_data: function(_namespace, _table, _key) {
		return this._open_db(_namespace, schemas[_table])
			.then((_db) => {
				return new Promise(function(_resolve, _reject) {
					const store = _db.transaction([_table], "readwrite").objectStore(_table);
					const request = store.delete(_key);

					request.onerror = (_event) => {
						_reject(_event);
					};
		
					request.onsuccess = (_event) => {
						_resolve(_event);
					};
				});
			}
		);
	},

	load: function(_namespace, _table, _key) {
		return this.read_data(_namespace, _table, _key);
	},

	save: function(_namespace, _table, _data) {
		logger.log("storage", `Saving data for ${_namespace}.${_table}.${_data.version}`)
		return this.create_data(_namespace, _table, _data);
	},

	prune: function(_namespace, _table, _max_auto_saves=10) {
		return this.get_table_keys(_namespace, _table, "id")
			.then(async function(_keys) {
				_keys = _keys.sort((_a, _b) => { return (parseInt(_a.split("-").at(-1)) < parseInt(_b.split("-").at(-1)) ? -1 : 1) });

				if (_keys.length > 10) {
					for (let idx = 0; _keys.length > _max_auto_saves; ++idx) {
						let key = _keys[idx]
						await this.delete_data(_namespace, _table, key);

						_keys.shift();
					}
				}
			}.bind(this)
		);
	},

	get_databases: function() {
		return indexedDB.databases()
			.then(function(_dbs) {
				let databases = [];

				for(let db of _dbs) {
					databases.push([db.name, db.version]);
				}

				return Promise.resolve(databases);
			}
		)
	},
});

const schemas = Object({
	"auto-save": function(_db) {
		logger.log("storage", "Creating schema for table auto-save.")
		const objectStore = _db.createObjectStore("auto-save", { keyPath: "id" });
		objectStore.createIndex("id", "id", { unique: true });
	},
})
</script>

<script>
const State = Object.freeze({Failed: 0, None: 1, Waiting: 2, Skipped: 3, Finished: 4});

const profile = ({
	name: undefined,
	version: undefined,
	id: undefined,
	is_delta: false,

	references: {},

	get_profiles: function() {
		return storage.get_databases();
	},

	get_saves: async function() {
		if (this.name == undefined) { throw new Error("profile.name must be set before get_saves can be called.") };
		let saves = await storage.get_table_keys(this.name, "auto-save", "id");
		return saves;
	},

	set_profile: function(_name) {
		this.name = _name;
	},

	set_save: function(_version) {
		this.version = _version;
		this.id = `${this.name}-${this.version}`;
	},

	register: function(_key, _serialize, _deserialize) {
		this.references[_key] = {"get": _serialize, "set": _deserialize};
	},

	initialize: function(_name, _version=0, _state=null) {
		this.name 		= _name;
		this.version 	= _version;
		this.id 		= `${this.name}-${this.version}`;
		
		if (_state) {
			let state = JSON.parse(_state);
			Object.entries(state).forEach(function([_k, _v]) { this.references[_k].set(_v)}.bind(this));
			publisher.publish("profile");
		}
	},

	save_data: async function() {
		if (this.name == undefined) 	{ throw new Error("profile.name must be set before save_data can be called.") };
		if (this.version == undefined) 	{ throw new Error("profile.version must be set before save_data can be called.") };
		if (this.is_delta == false) 	{ return; }

		this.version += 1;
		let data = this.dict();

		for (const [_key, _value] of Object.entries(this.references)){
			data["state"][_key] = this.references[_key]["get"]();
		}

		data.state = JSON.stringify(data.state);
		await storage.save(this.name, "auto-save", data)
		.then(() => { return storage.prune(this.name, "auto-save"); });

		this.is_delta = false;
	},

	load_data: async function(_id=null) {
		if (this.name == undefined) { throw new Error("profile.name must be set before load_data can be called.") };
		let id = (_id) ? _id : this.id;
		
		await storage.load(this.name, "auto-save", `${id}`)
		.then(function(_data) {
			this.initialize(
				_data.name, 
				_data.version,
				_data.state,
			)
		}.bind(this));
	},

	delete_data: async function(_id=null) {
		if (this.name == undefined) { throw new Error("profile.name must be set before delete_data can be called.") };
		let id = (_id) ? _id : this.id;

		await storage.delete_data(this.name, "auto-save", `${id}`);
	},

	delete_profile: async function(_name) {
		let name = (_name) ? _name : this.name;
		await storage.drop_db(name);
	},

	on_state: function() {
		this.is_delta = true;
	},

	dict: function() {
		return {
			"id": 		`${this.name}-${this.version}`,
			"name": 	this.name,
			"version":	this.version,
			"state": 	{},
		}
	}
});
</script>

<script>
class Vector {
	static filter_operators = Object.freeze(["&", "|", "^", "<", ">", "<=", ">=", "==", "!=", "is", "isnt", ".", "~", "min", "max", "clmp"]);
	static operations = {
		"+":		function(_x, _y) 	{ return _x + _y; },
		"-":		function(_x, _y) 	{ return _x - _y; },
		"*":		function(_x, _y) 	{ return _x * _y; },
		"%":		function(_x, _y) 	{ return _x % _y; },
		"/":		function(_x, _y) 	{ return _x / _y; },
		"&":		function(_x, _y) 	{ return _x & _y; },
		"|":		function(_x, _y) 	{ return _x | _y; },
		"^":		function(_x, _y) 	{ return _x ^ _y; },
		"<":		function(_x, _y) 	{ return _x < _y; },
		">":		function(_x, _y) 	{ return _x > _y; },
		">=":		function(_x, _y) 	{ return _x >= _y; },
		"<=":		function(_x, _y) 	{ return _x <= _y; },
		"==":		function(_x, _y) 	{ return _x == _y; },
		"!=":		function(_x, _y) 	{ return _x != _y; },
		"is":		function(_x, _y) 	{ return (arguments.length == 1) ? (_x): (_y); },
		"isnt":		function(_x, _y) 	{ return (arguments.length == 1) ? (!_x): (!_y); },
		".":		function(_x, _y) 	{ return _x[_y]; },
		"~":		function(_x, _y) 	{ return new RegExp(_y).test(_x); },
		"min":		function(_x, _y) 	{ return Math.min(_x, _y) },
		"max":		function(_x, _y) 	{ return Math.max(_x, _y) },
		"clmp":		function(_x, _y) 	{ return Math.min(Math.max(_x, _y.min), _y.max) },
	};

	static transform(_vector_1, _operation, _vector_2) {
		if (Array.isArray(_vector_1) && !Array.isArray(_vector_2)) {
			_vector_2 = _vector_1.slice().fill(_vector_2, 0, _vector_1.length);
		}

		let t_vector_1 = _vector_1.slice();
		_operation = (typeof _operation == "string") ? Vector.operations[_operation] : _operation;

		for(let idx = 0; idx < _vector_2.length; ++idx) {
			t_vector_1[idx] = _operation(t_vector_1[idx], _vector_2[idx]);
		}

		return t_vector_1;
	};

	static reduce(_vector_1, _operation, _accumulator = null) {
		if (_vector_1.length == 0) { throw new Error(`Invalid: Vector.reduce(${_vector_1}, ${_operation}) on set with 0 values.`); }

		let accumulator = (_accumulator != null) ? _accumulator : (typeof _vector_1[0] == "string") ? "" : 0;
		let value = _vector_1.reduce(Vector.operations[_operation], accumulator);

		return [_vector_1.indexOf(value), value];
	};

	static relations = Object.freeze(["1:1", "1:*", "*:*"]);
	static filter(_values, _filters, _operation, _relation, _field) {
		if (!Vector.filter_operators.includes(_operation)) {
			throw new Error(`Vector.filter can only use bool operators: ${Vector.filter_operators} not: ${_operation}`)
		}
		if (!Vector.relations.includes(_relation)) {
			throw new Error(`Vector.filter can only use relationships: ${Vector.relations} not: ${_relation}`)
		}

		switch(_relation) {
			case("1:1"):
				if (_values.length != _filters.length) { 
					throw new Error(`Vector.filter using relation=1:1, _filters.length: ${_filters.length} != _values.length: ${_values.length}`)
				}
				
				if (_field ?? false) {
					return _values.filter((elem, idx) => Vector.operations[_operation](elem[_field], _filters[idx][_field]));
				} else {
					return _values.filter((elem, idx) => Vector.operations[_operation](elem, _filters[idx]));
				}

			case("1:*"):
				let filter = (Array.isArray(_filters)) ? _filters[0] : _filters;

				if (_field ?? false) {
					return _values.filter((elem, idx) => Vector.operations[_operation](elem[_field], filter[_field]));
				} else {
					return _values.filter((elem, idx) => Vector.operations[_operation](elem, filter));
				}

			case("*:*"):
				if (_values.length != _filters.length) { 
					throw new Error(`Vector.filter using relation=*:*, _filters.length: ${_filters.length} != _values.length: ${_values.length}`)
				}

				let result_filter = _values.splice().fill(0, 0, _values.length - 1);
				for(let key of _values.keys) {
					result_filter[key] |= _filters.reduce((truthy, filter) => truthy || Vector.operations[_operation](_values[key], filter));
				}

				return _values.filter((elem, idx) => result_filter[key]);
		}
	};

	static remove(_values, _filters) {
		for(let idx = 0; idx < _filters.length; ++idx) {
			let at = _values.indexOf(_filters[idx])
			if (at > -1) {
				_values.splice(at, 1);
			}
		}

		return _values
	};

	static shift(_vector, _by) {
		let t_vector = _vector.slice();
		if(_by > 0) {
			for (let idx = 0; idx < _by; ++idx) { 
				t_vector.unshift(t_vector.pop()); 
			};
		} else if (_by < 0) {
			for (let idx = 0; idx < abs(_by); ++idx) { 
				t_vector.push(t_vector.shift()); 
			};
		}
		return t_vector;
	};

	static clamp(_vector, _low, _high) {
		let t_vector = _vector.slice();
		for (let idx = 0; idx < t_vector.length; ++idx) { 
			t_vector[idx] = ops.clamp(t_vector[idx], _low, _high);
		}; 
		return t_vector;
	};
};
</script>

<script>
const input = Object({
	actions: ["notify", "confirm", "choice", "log", "modal"],

	event_handler: function(_action, _args, _resolve, _reject) {
		logger.func("input", "input.event_handler", arguments);
		let result = null;

		switch(_action) {
			case("notify"):
				result = [this.notify(_resolve, ..._args)];
				break;
			case("confirm"):
				result = [this.confirm(_resolve, _reject, ..._args)];
				break;
			case("choice"):
				result = [this.choice(_resolve, _reject, ..._args)];
				break;
			case("log"):
				result = [this.log(..._args), _resolve, _reject];
				break;
			case("modal"):
				result = [this.modal(_resolve, _reject, _args)]
				break;
			default:
				return _reject(new Error(`input.${_action} is not a valid command`));
		}

		if (result) {
			publisher.publish("html", result);
		}
	},

	notify: function(_resolve, _log_text, _btn_text_1="Next") {
		return [
			["session_log", "log", {"data": _log_text}],
			["button_group", "button", { "id": "resolve", "data": _btn_text_1, "click": () => _resolve(true) }],
		];
	},

	confirm: function() {
		let args =  Array(...arguments);
		let resolve = args.shift();
		let reject	= args.shift();

		return [
			["session_log", "log", {"data": args[0]}],
			["button_group", "button", { "id": "resolve", 	"data": args[1][0], "click": () => resolve(args[1].slice(1)) }],
			["button_group", "button", { "id": "reject_to", "data": args[2][0], "click": () => open_modal("modal_roll", null, reject, args[2].slice())}],
			["button_group", "button", { "id": "reject", 		"data": args[3][0], "click": () => reject([args[3][1], [args[3][2]]])}]
		];
	},

	choice: function() {
		let args 			=  Array(...arguments);
		let resolve 	= args.shift();
		let reject		= args.shift();
		let message		= args.shift();
		let options 	= args.shift();
		let disabled 	= (args[0]) ? args.shift() : [];

		let element_data = [
			["session_log", "log", { "data": `${message}` }]
		]

		options = (typeof options == "object" && !Array.isArray(options) && options) ? Object.entries(options) : options;
		for (let idx = 0; idx < options.length; ++idx) {
			let choice = !Array.isArray(options[idx]) ? [options[idx]] : options[idx];

			element_data.push([
				"button_group", 
				"button", 
				{
					"id": `option_${idx}`, 
					"data": `${choice[0]}`,
					"disabled": (disabled.indexOf(choice[0]) > -1),
					"click": () => resolve({"idx": idx, "name": choice[0], "data": choice.at(-1)})
				}
			]);
		}

		return element_data;
	},

	modal: function(_resolve, _reject, _args) {
		let template = `modal_${_args.shift()}`;
		open_modal(template, _resolve, _reject, _args)

		return [
			["button_group", "button", { "id": "option_0", "data": _args[0], "click": () => open_modal(template, _resolve, _reject, _args)}],
		]
	},

	log: function(_log_text) {
		return [
			["session_log", "log", {"data": _log_text}],
		];
	},
});
</script>

<script>
const io = Object({
	actions: ["size", "has", "keys", "values", "read", "lookup", "write", "concat", "set_at", "copy", "null", "is", "profile", "delete", "at_t", "delete_t", "resolve_t", "write_t", "touch"],

	data_sets: {
		"game_d": game_data,
		"save_d": save_data,
		"rule_d": rule_data
	},

	refresh_data_set: function() {
		this.data_sets["save_d"] = save_data;
		this.data_sets["game_d"] = game_data;
		this.data_sets["rule_d"] = rule_data;
	},

	path_to_keys: function(_path) {
		let results = []

		let is_slice = true;
		let slash	= 0;
		let start = 0;
		let colon = 0;
		for(let idx = 0; idx < _path.length; ++idx) {
			switch(_path[idx]) {
				case(":"):
					colon = idx;
					break;
					
				case("/"):
					is_slice = !is_slice;
					slash = (is_slice) ? 1 : slash;
					break;

				case("."):
					if (is_slice) {
						results.push((colon > start)
							? [_path.slice(start + slash, colon - slash), _path.slice(colon+1, idx)]
							: [_path.slice(start + slash, idx - slash)]);

						slash = 0;
						start = idx + 1;
					}
			}
		}

		if (colon > start) {
			results.push([_path.slice(start + slash, colon - slash), _path.slice(colon+1, _path.length)]);
		} else {
			results.push([_path.slice(start + slash, _path.length - slash)]);
		}
		
		return results;
	},

	event_handler: function(_action, _args, _resolve, _reject) {
		logger.func("io", "io.event_handler", arguments);

		switch(_action) {
			case("read"):
				return _resolve(this.read(..._args));
			case("write"):
				return _resolve(this.write(..._args));
			case("touch"):
				return _resolve(this.read(..._args));
			case("delete"):
				return _resolve(this.delete(..._args));
			case("concat"):
				return _resolve(this.concat(..._args));
			case("set_at"):
				return _resolve(this.set_at(..._args));
			case("size"):
				return _resolve(this.size(_args));
			case("lookup"):
				return _resolve(this.lookup(..._args));
			case("keys"):
				return _resolve(this.keys(..._args));
			case("values"):
				return _resolve(this.values(..._args));
			case("copy"):
				return _resolve(this.copy(..._args));
			case("has"):
				return _resolve(this.has(..._args));
			case("null"):
				return _resolve(this.null(..._args));
			case("is"):
				return _resolve(this.in(..._args));
			case("at_t"):
				return _resolve(this.at_t(..._args));
			case("resolve_t"):
				return _resolve(this.resolve_t(..._args));
			case("write_t"):
				return _resolve(this.write_t(..._args));
			case("delete_t"):
				return _resolve(this.delete_t(..._args));
			case("profile"):
				return _resolve(profile.name);
			default:
				_reject(new Error(`io.${_action} is not a valid command`));
		}
	},

	_recur: function(_node, _path, _value=undefined) {
		if (_path == null && _value == undefined) { return _node; }
		let key = _path.shift()

		// If it is a read operation and a * is encountered at an array entry then recur through all entries
		if (key[0] == "*") {
			if (!_path.length) 					{ throw new Error(`Invalid: * operator, not allowed as last entry in path.`); }
			if (!Array.isArray(_node)) 	{ throw new Error(`Invalid: * operator, ${_node} is not an array.`); }
			if (_value != undefined) 		{ throw new Error(`Invalid: * operator, in write operation.`); }

			let results = [];
			for(let idx = 0; idx < _node.length; ++idx) {
				results.push(this._recur(_node[idx], _path.slice()));
			}

			return results;
		} else {
			// Step into the next entry
			let node = _node[(Array.isArray(_node)) ? parseInt(key[0]) : key[0]];

			// If the entry is nullish then see if we can generate it from a passed in data type.
			if (node == null || node == undefined) {
				switch(key[1]) {
					case("{}"):	_node[key[0]] = {}; node = _node[key[0]]; break;
					case("[]"):	_node[key[0]] = []; node = _node[key[0]]; break;
				}
			}
			
			if ((_value != undefined && _path.length == 1) && ((new String(_path[0]) == `${parseInt(_path[0])}`) || typeof node == "object")) {
				// Write operation
				logger.debug("io", `Writing to: ${key[0]}.${_path[0]}, value`); console.log(_value);
				node[(Array.isArray(node)) ? _path[0] : String(_path[0])] = (_value.data == "null") ? null : _value.data;
				return _value.data;

			} else if (_path.length > 0) {
				// Navigate operation
				return this._recur(node, _path, _value);

			} else {
				// Read operation
				return node;
			}
		}
	},

	// Write operations -----------------------------------------------------------------------------------------
	write: function(_data_set, _path, _value) {
		let result = this._recur(this.data_sets[_data_set], [["data"]].concat(this.path_to_keys(_path)), {"data": _value});
		publisher.publish("state", [_data_set,_path, result]);
		return result;
	},

	delete: function(_data_set, _path, _key) {
		let path = this.path_to_keys(_path);
		let key = (arguments.length < 3) ? path.pop(-1)[0] : _key;

		let result = this._recur(this.data_sets[_data_set].data, path)
		if (result == null || this.data_sets[_data_set].data == undefined) {
			throw new Error(`Cannot delete ${key} from ${result} it doesn't exist.`);
		}

		if (Array.isArray(result)) {
			result.splice(key, 1);
		} else if (typeof result == "object") {
			delete result[key];
		} else {
			result[key] = undefined;
		}

		publisher.publish("state", [_data_set, _path, result]);
		return true;
	},

	concat: function(_data_set, _path, _value) {
		let idx = null;
		// Exposing a raw array.concat vs one that saves to the state. 
		if (Array.isArray(_data_set) && (_value == null || _value == undefined)) {
			idx = _data_set.push(_path);
			return {"idx": idx, "data": _data_set};
		};
		
		let result = this._recur(this.data_sets[_data_set].data, this.path_to_keys(_path));
		if (!Array.isArray(result)) { 
			throw new Error(`io.concat at: ${_data_set}:${_path} can only be used on arrays`);
		}

		idx = result.push(_value);
		publisher.publish("state", [_data_set, _path, result]);
		console.log(result)
		return {"idx": idx - 1, "data": result};
	},

	set_at: function(_data_set, _path, _key, _value) {
		let path = this.path_to_keys(_path);
		let value = (arguments.length < 4) ? _key : _value;
		let key = (arguments.length < 4) ? path.pop(-1)[0] : _key;

		let result = this._recur(this.data_sets[_data_set].data, path);
		if (typeof result != "object" || Array.isArray(result) || result == undefined || result == null) { 
			throw new Error(`io.set_at at: ${_data_set}:${_path} can only be used on dicts`);
		}

		result[key] = value;
		publisher.publish("state", [_data_set, _path, result]);
		return {"key": key, "data": result};
	},

	// Read operations -----------------------------------------------------------------------------------------
	read: function(_data_set, _path) {
		return this._recur(this.data_sets[_data_set].data, this.path_to_keys(_path));
	},

	touch: function(_data_set, _path) {
		this._recur(this.data_sets[_data_set].data, this.path_to_keys(_path));
		return _path;
	},

	size: function(_args) {
		let result = _args;
		if (Object.keys(this.data_sets).includes(_args[0])) {
			result = this._recur(this.data_sets[_args[0]].data, this.path_to_keys(_args[1]));
		} else {
			result = result[0];
		}

		if (typeof result != "object" || result == null || result == undefined) { 
			throw new Error(`io.size at: ${_args[0]}:${_args[1]} can only be used on arrays/dicts not: ${result}`)
		};

		return (Array.isArray(result)) ? result.length : Object.keys(result).length;
	},

	copy: function(_data_set, _path) {
		let result = this._recur(this.data_sets[_data_set].data, this.path_to_keys(_path));
		if ( result == null || result == undefined) { 
			throw new Error(`io.copy at: ${_data_set}:${_path}, is null`)
		};

		return JSON.parse(JSON.stringify(result));
	},

	keys: function(_data_set, _path, _value) {
		let result = this._recur(this.data_sets[_data_set].data, this.path_to_keys(_path));
		if (typeof result != "object" || result == null || result == undefined) { 
			throw new Error(`io.keys at: ${_data_set}:${_path} can only be used on arrays/dicts not: ${result}`)
		};

		if (Array.isArray(result)) {
			return result;
		} else {
			return Object.keys(result);
		}
	},

	values: function(_data_set, _path, _value) {
		let result = this._recur(this.data_sets[_data_set].data, this.path_to_keys(_path));
		if (typeof result != "object" || result == null || result == undefined) { 
			throw new Error(`io.values at: ${_data_set}:${_path} can only be used on arrays/dicts not: ${result}`)
		};

		if (Array.isArray(result)) {
			return result;
		} else {
			return Object.values(result);
		}
	},

	lookup: function(_data_set, _path, _value) {
		let result = this._recur(this.data_sets[_data_set].data, this.path_to_keys(_path));
		if (typeof result != "object" || result == null || result == undefined) { 
			throw new Error(`io.lookup at: ${_data_set}:${_path} can only be used on arrays/dicts not: ${result}`)
		};

		if (Array.isArray(result) == false) {
			result = Object.entries(result);
		}

		return result[ops.clamp(_value, 0, result.length - 1)];
	},

	// Check operations -----------------------------------------------------------------------------------------
	has: function(_data_set, _path, _value) {
		let result = this._recur(this.data_sets[_data_set].data, this.path_to_keys(_path));
		if (typeof result != "object" || result == null || result == undefined) { 
			throw new Error(`io.has at: ${_data_set}:${_path} can only be used on arrays/dicts not: ${result}`)
		};

		if (Array.isArray(result)) {
			return result.includes(_value);
		} else {
			return Object.keys(result).includes(_value);
		}
	},

	null: function(_data_set, _path) {
		let result = this._recur(this.data_sets[_data_set].data, this.path_to_keys(_path));
		return (result == null || result == undefined);
	},

	is: function(_data_set, _path) {
		let result = this._recur(this.data_sets[_data_set].data, this.path_to_keys(_path));
		return (result != null && result != undefined);
	},

	// Tree operations ------------------------------------------------------------------------------------------
	_tree: function(_node, _path, _attribute) {
		// If has result then read the value at the name for the branch
		if (_attribute["results"] ?? false) {
			_attribute.results.push(_node[_attribute.name] ?? _attribute.default);
		}

		if (_path.length == 0) {
			// If at end and has value then write the value to the name for the branch
			if ((_attribute.value ?? false)) 				{ _node[_attribute.name] = _attribute.value }
			// Else if at end and has cascade then delete the node from the the branch
			else if ((_attribute.cascade ?? false))	{ delete _node[_attribute.name] };
			return;
		}

		let key = `+${_path.shift()}`;
		if (!(_node[key] ?? false)) {
			if (_attribute.value ?? false) { // If the branch does not exist on write then create an empty object and continue
				_node[key] = {}; 
			} else if (_attribute.cascade ?? false) { // If the branch does not exist on delete then error
				throw new Error(`There is no child at key: ${key} to process a delete_t on.`)
			} else { //  If the branch does not exist on read, return the results thus far
				return; 
			} 
		}
		
		// Recur down the tree
		this._tree(_node[key], _path, _attribute);

		// As we bubble up from the delete if there are no other nodes then delete the branch at this level
		if ((_attribute.cascade ?? false) && (Object.keys(_node[key]).length == 0)) {
			delete _node[key];
		}
	},

	at_t: function(_data_set, _path, _key, _default) {
		if (_default ?? true) {	throw new Error(`IO.at_t cannot have a null value for default, ${JSON.stringify(arguments)}`); }
		let attribute = {"name": _key, "default": _default, "results": []};

		let split_path 	= this.path_to_keys(_path);
		let tree_path 	= split_path.pop()[0].split("+");
		let root 		= this._recur(this.data_sets[_data_set].data, split_path);

		this._tree(root, tree_path, attribute);
		return attribute.results.at(-1);
	},

	resolve_t: function(_data_set, _path, _key, _default) {
		if (_default ?? true) {	throw new Error(`IO.resolve_t cannot have a null value for default, ${JSON.stringify(arguments)}`); }
		let attribute = {"name": _key, "default": _default, "results": []};

		let split_path 	= this.path_to_keys(_path);
		let tree_path 	= split_path.pop()[0].split("+");
		let root 		= this._recur(this.data_sets[_data_set].data, split_path);

		this._tree(root, tree_path, attribute);
		return attribute.results;
	},

	write_t: function(_data_set, _path, _key, _value) {
		let attribute = {"name": _key, "value": _value};

		let split_path 	= this.path_to_keys(_path);
		let tree_path 	= split_path.pop()[0].split("+");
		let root 		= this._recur(this.data_sets[_data_set].data, split_path);

		this._tree(root, tree_path, attribute);
		return _value;
	},

	delete_t: function(_data_set, _path, _key) {
		let attribute = {"name": _key, "cascade": true};

		let split_path 	= this.path_to_keys(_path);
		let tree_path 	= split_path.pop()[0].split("+");
		let root 		= this._recur(this.data_sets[_data_set].data, split_path);

		this._tree(root, tree_path, attribute);
		return true;
	},
})
</script>

<script>
const heap_regex = /(?<delimited><(?<key>[$\.\w]+)>)/g;
const heap = Object({
	actions: ["h_get", "h_pop", "h_push", "h_put", "watch", "ignore"],

	heap: {},
	watch_heap: {},
	watchers: {},

	set: function(_states) {
		if (_states.watchers) {
			Object.values(_states.watchers).forEach(function(_w) { this.watch(_w["key"], _w["pattern"], _w["path"], _w["at"]) }.bind(this));
		}
	},

	get: function() {
		return { "watchers": this.watchers };
	},

	on_state: function(_data_set, _path, _delta) {
		if (_data_set == "save_d") {
			for(let watcher of Object.values(this.watchers)) {
				if (_path.match(watcher.regex) != null) {
					this.watch_heap[watcher.key] = (watcher.at != null) ? _delta[watcher.at] : _delta;
				}
			}
		}
	},

	event_handler: function(_action, _args, _resolve, _reject) {
		logger.func("heap", "heap.event_handler", arguments);

		switch(_action) {
			case("h_get"):
				var result = this.h_get(..._args);
				if (result == null || result == undefined) { logger.warn("heap", `There is no value for key: ${_args[0]} in the heap.`); }
				return _resolve(this.h_get(..._args));
			case("h_pop"):
				var result = this.h_get(..._args, true);
				if (result == null || result == undefined) { logger.warn("heap", `There is no value for key: ${_args[0]} in the heap.`); }
				return _resolve(this.h_get(..._args));
			case("h_put"):
				return _resolve(this.h_put(..._args));
			case("h_push"):
				return _resolve(this.h_push(..._args));
			case("watch"):
				return _resolve(this.watch(..._args));
			case("ignore"):
				return _resolve(this.ignore(..._args));
			default:
				_reject(new Error(`heap.${_action} is not a valid command`));
		}
	},

	h_has: function(_key) {
		let cleaned_key = _key.replaceAll("$", "")
		return ((Object.keys(this.heap).includes(cleaned_key) || Object.keys(this.watchers).includes(cleaned_key)));
	},

	h_get: function(_key, _default=null) {
		let result = this.heap[_key];
		if (result != null && result != undefined) { return result; }

		if (_default != null && _default != undefined) {
			this.heap[_key] = _default;
			return _default;
		}

		if(this.watchers[_key] != undefined) {
			result = this.watch_heap[_key];
			result = io.read("save_d", this._replace_tokens(`${this.watchers[_key].path}`));

			if (this.watchers[_key].at != null) { 
				result = result[this.watchers[_key].at];
			}

			this.watch_heap[_key] = result;
			return result
		}
	},

	h_pop: function(_key, _default=null) {
		let result = this.h_get(_key, _default)
		delete this.heap[_key];
		return result;
	},

	h_put: function(_key, _value) {
		this.heap[_key] = _value;
		return true;
	},

	h_push: function(_key, _value) {
		let data_set = this.h_get(_key);

		if (data_set != null && data_set != undefined) {
			data_set.push(_value);
		} else {
			data_set = [_value];
		}
		
		this.heap[_key] = data_set;
		return true;
	},

	watch: function(_h_key, _pattern, _path, _at=null) {
		if (Object.keys(this.watchers).includes(_h_key)) { return false; }
		this.watchers[_h_key] = {"key": _h_key, "pattern": _pattern, "regex": new RegExp(_pattern, "g"), "path": _path, "at": _at};
		return true;
	},

	ignore: function(_h_key) {
		delete this.watchers[_h_key];
		delete this.watch_heap[_h_key];
		return true;
	},

	purge: function(_watched=false) {
		this.heap = {};
		if (_watched == true) {	this.watch_heap = {};	}
	},

	_replace_tokens: function(_path) {
		if(typeof _path != "string") { return; }

		for (const match of Array.from(_path.matchAll(heap_regex)).toReversed()) {
			if (match.groups.key.indexOf("$") < 0) { continue; }
			let keys = match.groups.key.split(".");

			// Resolve variable post processing
			for (const k_idx in keys) {
				if (keys[k_idx].indexOf("$") >= 0) { 
					let value = keys[k_idx].replaceAll("$", "");
					keys[k_idx] = heap.h_get(value);
				} else {
					continue; 
				}
			}

			if (match.groups.delimited.length == _path.length) {
				_path = keys.join(".");
			} else {
				_path = _path.substring(0, match.index) + keys.join(".") + _path.substring(match.index + match.groups.delimited.length);
			}
		}

		return _path;
	},
})
</script>

<script>
const ops = Object({
	actions: ["roll", "math", "clamp", "format", "reduce", "filter", "remove", "shift", "get", "pop", "set", "ifelse", "range", "includes", "at", "split", "reverse", "replace", "palindrome", "entries"],

	event_handler: function(_action, _args, _resolve, _reject) {
		logger.func("ops", "ops.event_handler", arguments);

		switch(_action) {
			case("roll"):
				return _resolve(this.roll(..._args));
			case("math"):
				return _resolve(this.math(..._args));
			case("clamp"):
				return _resolve(this.clamp(..._args));
			case("reduce"):
				return _resolve(Vector.reduce(..._args));
			case("filter"):
				return _resolve(Vector.filter(..._args));
			case("remove"):
				return _resolve(Vector.remove(..._args));
			case("shift"):
				return _resolve(Vector.shift(..._args));
			case("get"):
				return _resolve((_args[0][_args[1]] != undefined && _args[0][_args[1]] != null) ? _args[0][_args[1]] : _args[2]);
			case("pop"):
				var result = _args[0][_args[1]];
				delete _args[0][_args[1]];
				return _resolve(result);
			case("set"):
				_args[0][_args[1]] = _args[2];
				return _resolve(_args[0]);
			case("ifelse"):
				return _resolve(this.ifelse(..._args));
			case("range"):
				return _resolve(Array.from({length: _args}, (v, i) => i).toReversed());
			case("includes"):
				return _resolve(this.includes(..._args));
			case("at"):
				return _resolve(this.at(..._args));
			case("format"):
				return _resolve(this.format(..._args));
			case("split"):
				return _resolve(_args[0].split(_args[1]));
			case("reverse"):
				return _resolve(_args[0].toReversed());
			case("replace"):
				return _resolve(_args[0].replaceAll(_args[1], _args[2]));
			case("palindrome"):
				return _resolve(this.palindrome(_args[0]));
			case("entries"):
				return _resolve(Object.entries(_args[0]));
			default:
				_reject(new Error(`ops.${_action} is not a valid command`));
		}
	},

	roll: function(_faces, _roll=null) {
		return (_roll == null) ? Math.floor(Math.random() * _faces) : this.clamp(_roll, 0, _faces);
	},

	math: function(_value_1, _operator, _value_2) {
		if (_operator == undefined) {
			if (Array.isArray(_value_1)) {
				throw new Error(`ops.math remove extra brackets surrounding args: ${JSON.stringify(arguments)}`);
			} else {
				throw new Error(`ops.math no operator was passed in for args: ${JSON.stringify(arguments)}`);
			}
		}

		if (Vector.operations[_operator] == undefined) {
			throw new Error(`ops.math invalid operator: ${_operator}, for args: ${JSON.stringify(arguments)}`);
		}

		if ((typeof _value_1 != typeof _value_2) && !(Array.isArray(_value_1) || Array.isArray(_value_2))) {
			logger.warn("ops", "ops.math", `${_value_1}:${typeof _value_1} != ${_value_2}:${typeof _value_2}`);
		}

		if(Array.isArray(_value_1) && _value_1.length == 3 && Vector.operations[_value_1[1]]) {
			_value_1 = this.math(..._value_1);
		}

		if(Array.isArray(_value_2) && _value_2.length == 3 && Vector.operations[_value_2[1]]) {
			_value_2 = this.math(..._value_2);
		}

		return (Array.isArray(_value_1) || Array.isArray(_value_2)) ? Vector.transform(_value_1, _operator, _value_2) : Vector.operations[_operator](_value_1, _value_2);
	},

	clamp: function(_value, _min, _max) {
		return Math.min(Math.max(_value, _min), _max);
	},

	ifelse: function(_is, _outcome_1, outcome_2){
		_is = (Array.isArray(_is)) ? ops.math(..._is) : _is;
		return (_is) ? _outcome_1 : outcome_2;
	},

	includes: function(_object, _value) {
		return (Array.isArray(_object)) ? _object.includes(_value) : Object.keys(_object).includes(_value);
	},

	at: function(_delimited, _idx, _delimiter=".") {
		return _delimited.split(_delimiter).at(_idx);
	},

	format: function() {
		let args = Array.from(arguments);
		let text = args.shift();

		for(let idx in args) {
			text = text.replaceAll(`__${idx}__`, args[idx])
		}

		return text
	},

	palindrome: function(_value) {
		let value = `${_value}`;
		let i = 0;
		let j = value.length - 1;

		if (j == i) {
			return false;
		}

		while(i < j) {
			if(value[i] != value[j]) {
				return false
			}

			i += 1;
			j -= 1;
		}

		return true;
	},
});
</script>

<script>
const stack = Object({
	actions: ["result", "goto", "inject", "template", "loop", "branch", "return", "resolve", "step_result", "var_sub"],

	result_idx: 0,
	results: [],
	processes: [],

	get_process: function(_idx=0) {
		if (arguments.length > 0) {	logger.func("stack", "stack.get_process", arguments); };

		if (this.processes.length == 0) { return null; }
		let process = this.processes.at(_idx);

		if ([State.None, State.Waiting].includes(process.state)) { return process; }

		_idx = (_idx == 0 || _idx == -this.processes.length) ? 0 : _idx;
		if (_idx != 0) { throw new Error(`Attempted to get process: ${_idx} rule which is not available.`); }

		while (this.processes.length > 0 && [State.Failed, State.Skipped, State.Finished].includes(process.state)) {
			this.processes.at(_idx).destructor();
			this.processes.shift();
			process = this.processes.at(_idx);
		}

		return process;
	},

	event_handler: function(_action, _args, _resolve, _reject) {
		logger.func("stack", "stack.event_handler", arguments);

		switch(_action) {
			case("result"):
				return _resolve(this.push_result(_args));
			case("inject"):
				return _resolve(this.inject(..._args));
			case("branch"):
				return _resolve(this.branch(..._args));
			case("loop"):
				return _resolve(this.loop(..._args));
			case("template"):
				return _resolve(this.template(..._args));
			case("return"):
				return _resolve((_args.length < 2) ? this.return(0, ..._args) : this.return(..._args));
			case("goto"):
				return _resolve((_args.length < 2) ? this.goto(0, ..._args) : this.goto(..._args));
			case("step_result"):
				return _resolve((_args.length < 3) ? this.step_result(0, ..._args) : this.step_result(..._args));
			case("process"):
				return _resolve(this.new_process(..._args));
			case("resolve"):
				return _resolve(..._args);
			case("var_sub"):
				return _resolve(this.var_sub(..._args));
			default:
				_reject(new Error(`stack.${_action} is not a valid command`));
		}
	},

	push_result: function(_result) {
		//this.results.push(_result);
		return true;
	},

	new_process: function(_parent_idx=null) {
		logger.func("stack", "stack.new_process", arguments);
		let right_idx = -(this.processes.length + 1);
		this.processes.unshift(new Process(_parent_idx, right_idx));
		return right_idx;
	},

	branch: function(_is, _true, _false) {
		logger.func("stack", "stack.branch", arguments);
		_is = (Array.isArray(_is)) ? ops.math(..._is) : _is;
		let outcome = (_is) ? _true : (_false == "null") ? null : _false;

		if (outcome) {
			return new Promise(function (_resolve, _reject) {
				let args = (outcome.args) ? outcome.args : [];

				if ("inject" == outcome.action && (!Array.isArray(args) || args.length > 2 || args.length == 0)) { 
					throw new Error(`branch.inject requires 1-2 args: [rule, args], not ${JSON.stringify(args)}`)
				} else if ("loop" == outcome.action && ((!Array.isArray(args) || args.length > 3 || args.length < 2))) {
					throw new Error(`branch.loop requires 3 args: [rule, iter, args]: ${JSON.stringify(args)}`)
				}

				publisher.publish(Action_Targets[outcome.action], [outcome.action, args, _resolve, _reject]);
			}).then(function(_result) {
				return {"action": outcome.action, "result": _result};
			});
		}
	},

	loop: function(_rule_id, _indices, _args) {
		logger.func("stack", "stack.loop", arguments);
		let iter_idx = _args.indexOf("$idx$");
		let rule_ids = [];

		if (_indices.length == 0) {
			logger.warn("stack", `Loop was called with empty indices: ${_indices} for rule_id: ${_rule_id}`)
		}

		for (let idx = 0; idx < _indices.length; ++idx) {
			let arg_copy = _args.slice()
			if (iter_idx > -1) {
				arg_copy[iter_idx] = _indices[idx];
			}

			rule_ids.push(stack.inject(this.template(_rule_id, arg_copy)));
		}

		return rule_ids;
	},

	inject: function(_rule, _data=null, _process=0, _at=0) {
		logger.func("stack", "stack.inject", arguments);
		let process = this.processes.at(_process);
		let rule = undefined;
		
		if (typeof _rule == "string" && Array.isArray(_data)) {
			let template_check = _data.at(-1);
			template_check = (template_check) ? template_check["id"] : template_check;

			if (template_check && typeof template_check == "object" && Array.isArray(template_check) == false) {
				rule = new Rule(_rule, _data, this.result_idx, process.right_idx, process.parent_idx); // An unpacked filled out template rule

			} else {
				let template = this.template(_rule, _data);
				rule = new Rule(...template, this.result_idx, process.right_idx, process.parent_idx); // A template with args 
			}

		} else if (typeof _rule == "string" && _data == null) {
			rule = new Rule(_rule, rule_data.get(_rule), this.result_idx, process.right_idx, process.parent_idx); // A rule id

		} else if (Array.isArray(_rule) && _data == null) {
			rule = new Rule(..._rule, this.result_idx, process.right_idx, process.parent_idx); // A packed filled out template rule
		}

		if (rule != undefined) {
			if (process != null && process != undefined) {
				process.insert(rule, _at);
			} else {
				throw new Error(`Unable to inject rule: ${rule} into process: ${_process} at: ${_at}`, { "cause": { "code": "Null_Ref", "value": this.processes}});
			}
			
			this.result_idx += 1;
			return rule.rule_stack_id();
		} else {
			throw new Error(`Unable to inject rule: ${rule} with args:`, { "cause": { "code": "Invalid_Args", "value": Array.from(arguments)}});
		}
	},

	template: function(_rule_id, _args, _steps=null) {
		logger.func("stack", "stack.template", arguments);
		let rule = JSON.parse(JSON.stringify((_steps == null) ? rule_data.get(_rule_id) : _steps));
		let arg_keys = rule[0];
		
		if (_args && Array.isArray(arg_keys)) {
			if (_args.length > arg_keys.length) {
				logger.warn("stack", `stack.template, for rule_id:${_rule_id} there are more arguments: ${_args.length} than required: ${arg_keys.length}.`);
			} else if (_args.length < arg_keys.length) {
				throw new Error(`stack.template, rule_id: ${_rule_id} requires: [${arg_keys.length}, ${arg_keys}] not: [${_args.length}, ${_args}]`);
			}
	
			arg_keys = arg_keys.slice();
			_args = _args.slice();
	
			for(let idx = 0; idx < _args.length; ++idx) {
				if (arg_keys.length > idx) {
					arg_keys[idx] = [arg_keys[idx], _args[idx]];
				}
			}
	
			rule[0] = arg_keys;
		}
	
		return [_rule_id, rule];
	},

	return: function(_process_idx, _value=null) {
		logger.func("stack", "stack.return", arguments);
		let process = this.get_process(_process_idx);
		return process.get_rule().return(_value);
	},

	step_result: function(_process_idx, _step_idx, _value) {
		logger.func("stack", "stack.step_result", arguments);
		let process = this.get_process(_process_idx);
		return process.get_rule().set_result_for_step_at_idx(_step_idx, _value);
	},

	var_sub: function(_process_idx, _args) {
		logger.func("stack", "stack.var_sub", arguments);
		let process = this.get_process(_process_idx);
		return process.get_rule().substitute(_args);
	},

	goto: function(_process_idx, _to_step) {
		logger.func("stack", "stack.goto", arguments);
		let process = this.get_process(_process_idx);
		let rule = process.get_rule();
		let split = _to_step.split(".");

		if (split.length == 3) { 
			step_idx = rule.get_step_idx_by(...split);
		} else {
			throw new Error(`stack.goto requires at least two args delimited by . ex: (<id>.<direction>) not: ${_to_step}`);
		};

		if(step_idx > -1) {
			return rule.to_step_idx(step_idx);
		} else {
			throw new Error(`For process(${_process_idx}).rule(${rule.id}).step(${rule.step_idx}) there is no step of type: ${split[0]} matching: ${split[1]} using logic: ${split[2]}`);
		}
	},
});
</script>

<script>
class Process {
	parent_idx = undefined;
	right_idx  = undefined;

	state = State.None;
	rules = undefined;
	at_rule = undefined;

	constructor(parent_idx, right_idx) {
		this.parent_idx  = (parent_idx != null) ? parent_idx : -1;
		this.right_idx   = right_idx;

		this.rules 	= [];
		this.target = new EventTarget();

		publisher.subscribe(this.target, "game_loop.processed", publisher.pass_through(this.on_processed()));
	};

	on_processed = function() {
		return function(_resolve, _reject) {
			if (this.state == State.Waiting) {
				this.state = State.None;
				_resolve(true);

				if ([State.Failed, State.Skipped, State.Finished].includes(this.at_rule.state)) {
					if (this.at_rule.state == State.Failed) {
						this.state = State.Failed;
					}

					this.remove();
				}

				if (this.rules.length == 0) {
					this.state = State.Finished;
				}
			}
		}.bind(this);
	};

	get_rule = function(_at=0) {
		if (this.state == State.None) {
			this.at_rule = (this.rules.length > _at) ? this.rules[_at] : null;
			this.state = (this.at_rule != null) ? State.Waiting : State.Finished;
		}

		return this.at_rule;
	};

	cancel = function() {
		this.state = State.Skipped;
	};

	insert = function(_rule, _at=0) {
		this.rules.splice(_at, 0, _rule);
	};

	remove = function(_at=0) {
		if (this.rules[_at].state == State.Waiting) {
			this.rules[_at].return();
		}

		this.rules.splice(_at, 1);
	};

	destructor = function() {
		publisher.unsubscribe(this.target, "game_loop.processed");
	};
}
</script>

<script>
class Rule {
	id 				= undefined;
	rule_idx		= undefined;

	process_idx 	= undefined;
	parent_idx		= undefined;

	arguments 		= undefined;
	rule_args		= undefined;

	steps 			= undefined;
	step_idx 		= undefined;

	state  			= undefined;
	result 			= undefined;
	
	constructor(_id, _steps, _rule_idx, _process_idx, _parent_idx) {
		this.id 			= _id;
		this.rule_idx 		= _rule_idx;

		this.process_idx 	= _process_idx;
		this.parent_idx  	= _parent_idx;

		this.arguments 		= (Array.isArray(_steps[0])) ? _steps.shift(): [];
		this.rule_args		= Object.assign({
			"this_process": 	this.process_idx, 
			"parent_process": this.parent_idx
		}, Object.fromEntries(this.arguments));

		this.steps			= _steps.map((step) => new Step(this.rule_stack_id(), step));
		this.step_keys		= _steps.map((step) => step.id);
		this.step_idx 		= 0

		this.state 			= State.None;
	};

	rule_stack_id = function() {
		return `${this.id}_${this.rule_idx}`;
	}

	get = function(_key) {
		return this[_key];
	};

	get_finished_step_results = function() {
		return this.steps.reduce(function (_map, _step) { 
			if (_step.state == State.Finished) { 
				_map[_step.id] = _step.result; 
			}

			_map["step_idx"] = this.step_idx; 
			return _map;
		}.bind(this), Object.assign({}, this.rule_args));
	};

	static From = Object.freeze({"start": 0, "end": 1, "prev": 2, "next": 3});
	get_step_idx_by = function(_step_key, _step_value, _from) {

		let comparator;
		switch(_step_key) {
			case("id"):
				comparator = (_steps, _idx, _value) => _steps[_idx].id == _value;
				break;
			case("action"):
				comparator = (_steps, _idx, _value) => _steps[_idx].action == _value;
				break;
			default:
				throw new Error(`Rule.get_step_idx_by can only search by (id, action) not ${_step_key}`)
		}

		let at = 0;
		let to = 0;
		let direction = 0;
		let condition = null;
		switch(Rule.From[_from]) {
			case(Rule.From.start):
				at = 0;
				to = this.steps.length;
				direction = 1;
				condition = function(_at, _to) { return _at < _to; }
				break;
			case(Rule.From.end):
				at = this.steps.length;
				to = 0;
				direction = -1;
				condition = function(_at, _to) { return _at >= _to; }
				break;
			case(Rule.From.prev):
				at = this.step_idx - 1;
				to = 0;
				direction = -1;
				condition = function(_at, _to) { return _at >= _to; }
				break;
			case(Rule.From.next):
				at = this.step_idx + 1;
				to = this.steps.length;
				direction = 1;
				condition = function(_at, _to) { return _at < _to; }
				break;
			default:
				throw new Error(`Rule.get_step_idx_by must be passed a directional ex: ${Object.keys(Rule.From)}, not: ${_from}`);
		}

		while(condition(at, to)) {
			if (comparator(this.steps, at, _step_value)) {
				return at;
			}

			at += direction;
		}

		return -1;
	};

	set_result_for_step_at_idx = function(_idx, _result) {
		if (this.steps.length > _idx && _idx > -1) {
			if (this.steps[_idx] instanceof Step) {
				this.steps[_idx].result = _result;
				this.steps[_idx].state = State.Finished;

				return this.steps[_idx].result;
			}
		}
	};

	next = function() {
		let step = this.steps[this.step_idx];

		if (step != null) {
			if (step.state == State.Finished) {
				this.step_idx += 1;
				step = this.steps[this.step_idx];
			}

			if (step != null && step != undefined) {
				return step.run((step.state == State.None) ? this.get_finished_step_results() : [], this.step_idx);
			}
		}

		if (this.step_idx >= this.steps.length && this.state == State.None) {
			this.state = State.Finished;
			publisher.publish("rule", [this.rule_stack_id(), this.result]);
		}

		return Promise.resolve([this.rule_stack_id(), this.state]);
	};

	substitute = function(_args) {
		return Step.replace_tokens(this.get_finished_step_results(), _args.slice());
	};

	return = function(_value) {
		this.step_idx += 1;

		if (this.step_idx < this.steps.length) {
			this.to_step_idx(this.steps.length);
		}

		this.result = _value;
		return this.rule_stack_id();
	};

	to_step_idx = function(_idx) {
		_idx = (_idx < 0) ? this.step_idx + _idx : _idx;
		_idx = ops.clamp(_idx, 0, this.steps.length);
		if (_idx == this.step_idx) { return this.step_idx; }

		if (this.step_idx < _idx) { 
			while(this.step_idx < _idx) {
				if (this.steps[this.step_idx] != null && this.steps[this.step_idx].state != State.Finished) {
					this.steps[this.step_idx].state = State.Skipped;
				}

				this.step_idx += 1;
			}
		} else {
			while(this.step_idx >= _idx) {
				this.steps[this.step_idx].reset();
				
				if(this.step_idx > _idx) {
					this.step_idx -= 1;
				} else {
					break;
				}
			}

			this.step_idx = ops.clamp(this.step_idx, 0, this.steps.length);
		}

		return this.step_idx;
	};

	dict = function() {
		return {
			"id": 			this.id,
			"rule_idx": 	this.rule_idx,
			"steps": 		((this.arguments) ? [Object.entries(this.arguments)] : []) + this.steps.map((step) => step.dict()),
			"step_idx":		this.step_idx,
			"state": 		this.state,
			"result":		this.result
		}
	};
};
</script>

<script>
const Action_Targets = {};
const step_regex = /(?<delimited><(?<root>[$\w]+)\.*(?<path>[$\.\w]+)*>)/g;

class Step {
	rule_id			= undefined;
	id 				= undefined;
	action			= undefined;
	template		= undefined;

	args			= undefined;
	result			= undefined;
	state			= State.None;

	process			= undefined;

	constructor(_rule_id, _dict) {
		this.rule_id	= _rule_id;
		this.id			= _dict.id;
		this.action		= _dict.action;
		this.template	= Object.freeze(JSON.parse(JSON.stringify(_dict.args)));

		this.reset();
	};

	static replace_tokens (_results, _args) {
		if (_args == null) { return };

		if(Array.isArray(_args)) {
			for (let idx = 0; idx < _args.length; ++idx) {
				_args[idx] = Step.replace_tokens(_results, _args[idx]);
			}
		} else if(typeof _args == "object") {
			for (const[_key, _value] of Object.entries(_args)) {
				let key = Step.replace_tokens(_results, _key);
				_args[key] = Step.replace_tokens(_results, _value);

				if (key != _key) {
					delete _args[_key];
				}
			}

		} else if(typeof _args == "string") {
			const matches = Array.from(_args.matchAll(step_regex)).toReversed();

			for (const match of matches) {
				let root = match.groups.root;
				let path = (match.groups.path ?? false) ? match.groups.path.split(".") : [];
				let new_arg;

				if (!Object.keys(_results).includes(root) && !heap.h_has(root)) {
					throw new Error(`Unable to find a replacement for variable: ${match.groups.root}`);
				}

				// Add the root to the list
				path.unshift(root);
				
				// Resolve variable post processing
				while (path.length) {
					let key = path.shift();

					if (new_arg == null) {
						new_arg = (key.indexOf("$") >= 0) ? heap.h_get(key.replaceAll("$", "")) : _results[key];
					} else {
						new_arg = (key.indexOf("$") >= 0) ? new_arg[heap.h_get(key.replaceAll("$", ""))] : new_arg[key];
					}
				}

				if (match.groups.delimited.length == _args.length) {
					_args = new_arg;
				} else {
					_args = _args.substring(0, match.index) + new_arg + _args.substring(match.index + match.groups.delimited.length);
				}
			}
		}

		return _args;
	};

	get = function(_key) {
		return (this.hasOwnProperty(_key) && _key != "process") ? this[_key] : null;
	};

	set = function (_key, _value) {
		if (this.hasOwnProperty(_key) && _key != "process") {
			this[_key] = _value;
		}
	};

	run = function(_step_results, _step_idx) {
		if (State.Waiting == this.state) 			{ return this.process; }
		else if (State.Finished == this.state) 		{ return Promise.resolve([`${this.rule_id}-${this.id}`, this.state]); }
		else if (State.Skipped == this.state) 		{ return Promise.resolve([`${this.rule_id}-${this.id}`, this.state]); }
		else if (State.Failed == this.state) 		{ return Promise.reject([`${this.rule_id}-${this.id}`, this.state]);  }
	
		return new Promise(function (_resolve, _reject) {//	--------------------------------------------------- Publish Action
			try {
				let args = JSON.parse(JSON.stringify(this.template));

				switch(this.action) {
					case("watch"):
						this.set("args", args);
						break;
					case("event"):
						this.set("args", Step.replace_tokens(_step_results, args));
						this.result = this.args[1];
						this.args[1] = [_step_idx].concat(this.args[1]);
						break;
					default:
						this.set("args", Step.replace_tokens(_step_results, args));
			}
		} catch(e) {
			e.message = `In step: ${this.rule_id}.${this.id}, ${e.message}`;
			throw e;
		}

			let action_target = Action_Targets[this.action];
			if (!action_target) { throw new Error(`Action: ${this.action} does not have an associated target.`); }
			publisher.publish(Action_Targets[this.action], [this.action, this.args, _resolve, _reject]);
	
		}.bind(this))
		.then(function(_result) {// --------------------------------------------------------------------------- Format Results
			let action = this.action;
			let result = _result;

			if (this.action == "branch" && _result != null && _result != undefined) {
				action = _result.action;

				if (action == "inject") {
					result = [_result.result];
				}
				else  {
					result = _result.result;
				}
			} else if (this.action == "inject") {
				result = [result];
			}

			let payload = {"action": action, "result": result};
			return payload
	
		}.bind(this))
		.then(function(_kwargs) {// --------------------------------------------------------------------------- Branch Promise
			if (["inject", "loop"].includes(_kwargs.action) && Array.isArray(_kwargs.result) && _kwargs.result.length > 0) {
				this.set("state", State.Waiting);
				
				this.process = this._wait(_kwargs.action, _kwargs.result)
				.then(function(_result) { 
					return this._save(_kwargs.action, _result);
				}.bind(this));

			} else {
				return this._save(_kwargs.action, (this.action == "event") ? this.result : _kwargs.result);
			}

		}.bind(this))
		.then(function() {//----------------------------------------------------------------------------------- Return Id/State
			return [`${this.rule_id}-${this.id}`, this.state];
		}.bind(this))
	};
	
	_wait = function(_action, _result_keys) {
		return new Promise(async function (_resolve, _reject) {
			let target_type = _result_keys.reduce((type, curr) => `${type}-${curr}`, this.action);
			let target = new EventTarget(target_type);
			let results;
	
			publisher.subscribe(target, "rule", async function(_payload) {
				let args = publisher.get_payload_data(_payload);

				if (_result_keys.includes(args[0])) {
					let key = args[0];
					if (key instanceof Promise) {
						key = await key;
					}

					let value = args[1]
					if (_action == "inject") {
						results = value
					} else if (Array.isArray(results)) {
						results.push(value)
					} else {
						results = [value]
					}

					_result_keys.splice(_result_keys.indexOf(args[0]), 1);
				}

				if (_result_keys.length == 0) {
					publisher.unsubscribe(target, "rule");
					_resolve(results);
				}
			}.bind(this))
		}.bind(this))
	}
	
	_save = function(_action, _result) {
		return new Promise(function (_resolve, _reject) {
			this.result = _result;
			this.state = State.Finished;
			publisher.publish("stack", ["result", this.dict(), _resolve, _reject]);
		}.bind(this))
	};
	
	reset = function () {
		this.args 	= JSON.parse(JSON.stringify(this.template));
		this.result	= undefined; 
		this.state	= State.None;
	};

	dict = function() {
		return {
			"rule_id":	this.rule_id,
			"id": 		this.id,
			"action":	this.action,
			"template":	this.template,
			"args": 	(typeof this.args == "object" && this.args != null) ? JSON.stringify(this.args) : this.args,
			"result": 	this.result,
			"state": 	this.state,
		}
	};
};
</script>

<script>
const Event_Key = "event";

class Subscriber {
	target 		= undefined;
	controller  = undefined;

	constructor(_target, _event, _func) {
		this.target = _target;
		this.controller = new AbortController();

		let option = {signal: this.controller.signal};
		this.target.addEventListener(_event, _func, option);
		option.signal.addEventListener("abort", () => _target.removeEventListener(_event, _func, option), true);
	};

	destructor = function() {
		this.controller.abort();
	}
};

const publisher = Object({
	actions: ["audience", "bind", "context", "event", "listen"],

	subscriptions: 	{},
	contexts: 			{},

	get: function() {
		if (this.contexts) {
			return Object.entries(this.contexts).map(([_k,_v]) => _v.dict() );
		} else {
			return [];
		}
	},

	set: function(_contexts) {
		for(let context of _contexts) {
			this.context(context.context_id, "+", context);
		}

		for(let context_1 of Object.values(this.contexts)) {
			for(let context_2 of context_1.bound) {
				Context.Bind(context_1, context_2, false);
			}
		}
	},

	publish: function(_event, _payload={}) {
		let subscribers = this.subscriptions[_event];

		if (subscribers) {
			let event = new CustomEvent(_event, { bubbles: false, detail: _payload});

			for (let subscriber of subscribers) {
				subscriber.target.dispatchEvent(event);
			}
		}
	},

	subscribe: function(_subscriber, _event, _func) {
		logger.func("publisher", "publisher.subscribe", arguments, true);

		if (this.subscriptions[_event] == null) {
			this.subscriptions[_event] = []
		}
		
		this.subscriptions[_event].push(new Subscriber(_subscriber, _event, _func));
	},

	unsubscribe: function(_subscriber, _event) {
		let subscribers = this.subscriptions[_event];

		if(Array.isArray(subscribers) == true) {
			let idx = subscribers.findIndex((_s) => _s.target == _subscriber);

			if (idx > -1) {
				subscribers.splice(idx,1).forEach((_s) => _s.destructor());
			}
		}
	},

	pass_through: function(_node, _method="event_handler") {
		if (typeof _node === 'function') {
			return function(e) { 				
				if (Array.isArray(e.detail)) {
					_node(...e.detail);
				} else {
					_node(e.detail);
				};
			}
		} else {
			return function(e) { 
				if (Array.isArray(e.detail)) {
					_node[_method](...e.detail);
				} else {
					_node[_method](e.detail);
				};
			}
		}
	},

	get_payload_data(_payload) {
		return _payload["detail"]
	},

	clean_input: function(_composite, _operation, _required) {
		if (!(["+","-"].includes(_operation))) { throw new Error(`composite: ${_composite} is missing a valid:[+, -] _operation: ${_operation}.`); }
		let split = _composite.split(":");
		if (split.length < _required) { throw new Error(`composite: ${_composite} requires ${_required} keys delimited by a ':'.`); }
		return split;
	},

	event_handler: function(_action, _args, _resolve, _reject) {
		logger.func("publisher", "publisher.event_handler", arguments);

		switch(_action) {
			case("event"):
				return this.event(_args, _resolve, _reject);
			case("listen"):
				return _resolve(this.listener(..._args));
			case("audience"):
				return _resolve(this.audience(..._args));
			case("context"):
				return _resolve(this.context(..._args));
			case("filter"):
				return _resolve(this.filter(..._args));
			case("bind"):
				return _resolve(this.bind(..._args));
			default:
				_reject(new Error(`publisher.${_action} is not a valid command`));
		}
	},

	event: function(_payload, _resolve, _reject) {
		let promises = [];

		if (this.contexts) {
			for (let context of Object.values(this.contexts)) {
				promises.push(new Promise(function(_resolve, _reject) {
					context.filter(new CustomEvent(Event_Key, { 
								bubbles: false, 
								cancelable: true, 
								detail: [_payload[0], _payload[1], _resolve, _reject]
							}
						)
					);
				}))
			}
		}

		return Promise.allSettled(promises).then((_results) => _resolve(_payload));
	},

	context: function(_composite_id, _operation, _args) {
		let composite = this.clean_input(_composite_id, _operation, 1);

		if (_operation == "+") {
			if (composite[0] in this.contexts) {
				if (_args) { 
					this.contexts[composite[0]].add_filter(..._args); 
				}
			} else {
				this.contexts[composite[0]] = new Context(...((Array.isArray(_args)) ? [composite[0], _args] : Context.Dict_To_Args(_args)));
			}

			return composite[0];

		} else if (_operation == "-") {
			if (typeof composite[0] != "string") { throw new Error(`publisher.context for operation: ${_operation} requires the context_id not: ${composite[0]}`); }

			if (composite[0] in this.contexts) {
				if (_args) { 
					this.contexts[composite[0]].remove_filter(..._args); 
				} else {
					let context = this.contexts[composite[0]];
					for(let other of context.bound) {
						context.unbind(other);
						
						if (this.contexts[other]) {
							this.contexts[other].unbind(context.context_id);
						}
					}

					context.destroy();
					delete this.contexts[composite[0]];
				}
			}
		}
	},

	bind: function(_composite_id, _operation, _other_id, _both=true) {
		let composite = this.clean_input(_composite_id, _operation, 1);

		let context_1 = this.contexts[composite[0]];
		if (context_1 == undefined) { throw new Error(`Context: ${composite[0]} does not exist to ${_operation} a bind to ${_other_id}.`) };
		let context_2 = this.contexts[_other_id];
		if (context_2 == undefined) { throw new Error(`Context: ${_other_id} does not exist to ${_operation} a bind to ${composite[0]}.`) };

		if (_operation == "+") {
			context_1.bind(context_2);
			if (!_both) { return; }
			context_2.bind(context_1);

		} else if (_operation == "-") {
			context_1.unbind(context_2.context_id);
			if (!_both) { return; }
			context_2.unbind(context_1.context_id);

		}
	},

	audience: function(_composite_id, _operation, _args) {
		let composite = this.clean_input(_composite_id, _operation, 2);

		let context = this.contexts[composite[0]];
		if (context == undefined) { throw new Error(`Context: ${composite[0]} does not exist to ${_operation} an audience to.`) };

		if (_operation == "+") {
			return context.add_audience(composite[1], _args);
		} else if (_operation == "-") {
			context.remove_audience(composite[1]);
		}
	},

	listener: function(_composite_id, _operation, _events=[], _limit, _rule, _args=[]) {
		let composite = this.clean_input(_composite_id, _operation, 3);

		let context = this.contexts[composite[0]];
		if (context == undefined) { throw new Error(`Context: ${composite[0]} does not exist to ${_operation} a listener to.`) };

		if (_operation == "+") {
			return context.add_listener(composite[1], [composite[2], _events, _limit, _rule, _args]);
		} else if (_operation == "-") {
			context.remove_listener(composite[1], composite[2]);
		}
	},
});
</script>

<script>
class Context {
	static Dict_To_Args(_context) {
		if (_context instanceof Context) { return new Error(`Cannot call Context.Dict_To_Args on an instance of a Context.`)}
		if (typeof _context == "string") { _context = JSON.parse(_context); }

		return [_context["context_id"], _context["_filters"], _context["_audiences"], _context["_bound"]];
	};

	context_id	= undefined;
	audiences	= undefined;

	filters		= undefined;
	regex		= undefined;
	bound		= undefined;

	default_target	= undefined;
	bound_target	= undefined;
	controllers		= undefined;

	constructor(_context_id, _filters=[], _audiences=[], _bound=[]) {
		this.context_id 		= _context_id;

		let deserialize 		= function([_id, _a]) { return [_id, this.add_audience(...Audience.Dict_To_Args(_a))]; }.bind(this);
		this.audiences			= Object.fromEntries(_audiences.map(deserialize));

		this.filters			= _filters;
		this.regex				= _filters.map((_f) => RegExp(_f) );
		this.bound				= _bound;
		this.controllers		= {};

		this.default_target		= new EventTarget();
		this.bound_target		= new EventTarget();
	};

	filter = async function(_event) {
		let payload 	= publisher.get_payload_data(_event);
		let event_id 	= payload[0];
		let resolve 	= payload[2];
		let reject 		= payload[3];

		for (let filter of this.regex) {
			if (filter.test(event_id)) { 
				this.default_target.dispatchEvent(_event);
				return resolve(true);
			}
		}

		reject(false);
	};

	bind = function(_context_2) {
		let abort  = new AbortController();
		let option = { signal: abort.signal };
		let method = function (_event) {_context_2.bound_target.dispatchEvent(new CustomEvent(Event_Key, { bubbles: false, detail: publisher.get_payload_data(_event)}))};

		this.bound.push(_context_2.context_id);
		this.controllers[_context_2.context_id] = abort;
		this.default_target.addEventListener(Event_Key, method, option);

		abort.signal.addEventListener("abort", function() {
			this.default_target.removeEventListener(Event_Key, method, option);
			delete this.bound[_context_2.context_id];
			delete this.controllers[_context_2.context_id];
		}.bind(this), true);
	};

	unbind(_other_id) {
		if(_other_id in this.controllers) {
			this.controllers[_other_id].abort();
		}
	};

	add_filter = function(_filter, _idx=-1) {
		if (this.filters.indexOf(_filter) == -1) {
			if (_idx > -1) {
				this.filters.splice(_idx, 0, _filter);
				this.regex.splice(_idx, 0, RegExp(_filter));
			} else {
				this.filters.push(_filter);
				this.regex.push(RegExp(_filter));
			}
		}
	};

	remove_filter = function(_filter) {
		let at = this.filters.indexOf(_filter);
		if (at > -1) {
			this.filters = this.filters.splice(at, 1);
			this.regex = this.regex.splice(at, 1)
		}
	};

	add_audience = function(_audience_id, _events, _listeners=[], _state=State.None) {
		if (_audience_id in this.audiences) {
			let audience = this.audiences[_audience_id];
			for(const [key, pattern] of Object.entries(_events)) {
				audience[`${key}_id`] = pattern;
			}
			
		} else {
			let audience = new Audience(_audience_id, _events, _listeners, _state);
			this.audiences[_audience_id] = audience;

			let controller = new AbortController();
			let options = { signal: controller.signal };

			let method = audience.on_event(function(_state) {
				if (_state == State.Finished) {
					controller.abort();
					this.default_target.removeEventListener(Event_Key, method, options); 
					this.bound_target.removeEventListener(Event_Key, method, options); 
					delete this.audiences[_audience_id];
				}
			}.bind(this));

			this.default_target.addEventListener(Event_Key,	method, options);
			this.bound_target.addEventListener(Event_Key,	method, options);
		}

		return `${this.context_id}:${_audience_id}`;
	};

	remove_audience = function(_audience_id) {
		if (_audience_id in this.audiences) {
			this.audiences[_audience_id].destroy();
			delete this.audiences[_audience_id];
			
		} else {
			throw new Error(`Context: ${this.context_id} does not have audience_id: ${_audience_id} to remove.`);
		}
	};

	add_listener = function(_audience_id, _listener) {
		if (_audience_id in this.audiences) {
			let audience = this.audiences[_audience_id];
			let listener_id = (Array.isArray(_listener)) ? _listener[0] : _listener["listener_id"];

			if (listener_id in audience.listener_ids) {
				let events = (Array.isArray(_listener)) ? _listener[1] : _listener["events"];
				let listener = audience.listeners.at(audience.listener_ids[listener_id]);
				for(const [key, pattern] of Object.entries(events)) {
					listener[`${key}_id`] = pattern;
				}

			} else {
				this.audiences[_audience_id].register_listener(_listener);
			}

			return `${this.context_id}:${_audience_id}:${listener_id}`;

		} else {
			throw new Error(`Context: ${this.context_id} does not have audience_id: ${_audience_id} to attach a listener to.`);
		}
	};

	remove_listener = function(_audience_id, _listener_id) {
		if (_audience_id in this.audiences) {
			let audience = this.audiences[_audience_id];

			if (audience && _listener_id in audience.listeners) { 
				audience.listeners[_listener_id].destructor();
			} else {
				logger.warn("context", `There is no listener: ${_listener_id} in ${this.context_id}:${_audience_id}`);
			}

		} else {
			throw new Error(`Context: ${this.context_id} does not have audience_id: ${_audience_id} to remove a listener from.`);
		}
	};

	destroy = function(_others) {
		for (let audience of Object.values(this.audiences)) {
			audience.destroy();
		}

		delete this.default_target;
		delete this.bound_target;
	};

	dict = function() {
		return {
			"context_id":	this.context_id,
			"filters":		this.filters,
			"audiences":	Object.entries(this.audiences).map(([_k, _a]) => [_k, _a.dict()]),
			"bound":			this.bound,
		}
	};
}


</script>

<script>
class Audience {
	static Dict_To_Args(_audience) {
		if (_audience instanceof Audience) { return new Error(`Cannot call Audience.Dict_To_Args on an instance of a Audience.`)}
		if (typeof _audience == string) { _audience = JSON.parse(_audience); }

		return [_audience["audience_id"], _audience["events"], _audience["listeners"], _audience["state"]];
	}

	audience_id 	= undefined;
	events 			= undefined;

	start_regex 	= undefined;
	stop_regex		= undefined;
	delete_regex	= undefined;

	state			= undefined;
	listeners		= undefined;

	target			= undefined;
	controller		= undefined;
	options			= undefined;
	destructor		= undefined;

	constructor(_audience_id, _events, _listeners=[], _state=State.None) {
		let deserialize = function([_l]) { return this.register_listener(Listener(...Listener.Dict_To_Args(_l))) }.bind(this);

		this.audience_id 	= _audience_id;
		
		this.events			= _events;
		this.start_regex 	= (_events["start"]) 	? RegExp(_events["start"]) 	: undefined;
		this.stop_regex 	= (_events["stop"]) 	? RegExp(_events["stop"]) 	: undefined;
		this.delete_regex 	= (_events["delete"]) ? RegExp(_events["delete"]) : undefined;

		this.listeners		= _listeners.map(deserialize);
		this.listener_ids 	= Object.fromEntries(this.listeners.map((_idx, _l) => [_l.listener_id, -this.listeners.length + _idx]));
		this.state			= _state;

		this.target 		= new EventTarget();

		if (this.state == State.Waiting) {
			this.controller 	= new AbortController();
			this.options		= { signal: this.controller.signal };
			this.counter		= 0;
		}
	};

	set_events = function(_events) {
		this.events			= _events;

		this.start_regex 	= (_events["start"]) 	? RegExp(_events["start"]) 	: undefined;
		this.stop_regex 	= (_events["stop"]) 	? RegExp(_events["stop"]) 	: undefined;
		this.delete_regex	= (_events["delete"]) ? RegExp(_events["delete"]) : undefined;
	};

	register_listener = function(_listener) {
		if (!_listener) { throw new Error(`Cannot instantiate null listener in audience:${this.audience_id}`)};

		_listener = (Array.isArray(_listener)) ? _listener : Listener.Dict_To_Args(_listener);
		let listener = new Listener(..._listener);

		if (this.state == State.Waiting) {
			listener.wire(this.target, this.options, this.deregister_listener.bind(this));
		}

		this.listeners.push(listener);
		this.listener_ids[listener.listener_id] = -this.listeners.length;
		return listener;
	};

	deregister_listener = function(_listener_id) {
		if (_listener_id in this.listener_ids) {
			// convert the idx back to a left index and base 0 it
			let l_idx = (this.listener_ids[_listener_id] + 1) * -1;

			this.listeners = this.listeners.splice(l_idx, 1);
			delete this.listener_ids[_listener_id];
		}
	};

	_fifo_to_lifo_resolver = function() {
		return function(_method) {
			if (_method) {
				this.filo_queue.unshift(_method);
			}
	
			this.count += 1;
			if (this.count >= this.length) {
				this.filo_queue.forEach((_m) => _m());
			}
		}.bind({"length": this.listeners.length, "count": 0, "filo_queue": []}); 
	};

	wire = function(_target, _options, _state_callback) {
		if (!this.start_regex) {
			throw new Error(`Audience cannot listen for an event with a null/undefined/empty start: ${this.start_regex}`);
		}

		if (!this.stop_regex) {
			throw new Error(`Audience cannot listen for an event with a null/undefined/empty stop: ${this.stop_regex}`);
		}

		if (this.state = state.Waiting) {
			throw new Error(`Cannot wire audience: ${this.audience_id}, it is already wired.`);
		}

		_target.addEventListener(
			_target, 
			this.on_trigger(
				() => _target.removeEventListener(_target, method, _options),
				_state_callback
			),
			_options
		);

		this.state = state.Waiting;
	};

	on_event = function(_callback, _event) {
		this.destructor = _callback;

		return function(_event) {
			let payload = publisher.get_payload_data(_event);
			let event_id 	= payload[0];

			if (this.delete_regex && this.delete_regex.test(event_id)) {
				logger.log("audience", `${this.audience_id} has found a match for the delete event: ${this.delete_regex}`);

				this.controller.abort();
				this.listeners = null;
				delete this.target;

				this.state = State.Finished;
				_callback(this.state);

			} else if (this.state == State.Waiting) {
				if (this.stop_regex && this.stop_regex.test(event_id)) {
					logger.log("audience", `${this.audience_id} has found a match for the stop event: ${this.stop_regex}`);

					this.state = State.None;
					this.controller.abort()

					for (let listener of this.listeners) {
						listener.state = State.None;
					}

				} else {
					payload = [event_id, payload[1], this._fifo_to_lifo_resolver()];
					this.target.dispatchEvent(new CustomEvent(Event_Key, { bubbles: false, detail: payload}));
				}

			} else if (this.state == State.None) {
				 if (this.start_regex && (this.start_regex.test(event_id))) {
					logger.log("audience", `${this.audience_id} has found a match for the start event: ${this.start_regex}`);

					this.state 			= State.Waiting;
					this.controller 	= new AbortController();
					this.options		= { signal: this.controller.signal };
					this.counter 		= 0;

					for (let listener of this.listeners) {
						listener.wire(this.target, this.options, this.deregister_listener.bind(this));
					}
				}
			} 
		}.bind(this);
	};

	destroy = function() {
		if (this.controller) { this.controller.abort(); }
		this.listeners = null;
		this.listener_ids = null;

		this.state = State.Finished;
		delete this.target;
		this.destructor(this.state);
	};

	dict = function() {
		return {
			"audience_id":	this.audience_id,
			"events":		this.events,
			"listeners":	this.listeners.map((_l) => _l.dict()),
			"state":		this.state,
		}
	};
}
</script>

<script>

class Listener {
	static Event = {"Trigger": "trigger", "Reset": "reset", "Delete": "delete"};
	static Action = {"Pattern": 0, "Method": 1, "Args": 2};

	static Dict_To_Args(_listener) {
		if (_listener instanceof Listener) { return new Error(`Cannot call Listener.Dict_To_Args on an instance of a Listener.`)}
		if (typeof _listener == string) { _listener = JSON.parse(_listener); }

		return [_listener["listener_id"], _listener["events"], _listener["limit"], _listener["state"]];
	}

	listener_id 	= undefined;
	events			= undefined;

	trigger_regex	= undefined;
	delete_regex	= undefined;
	reset_regex		= undefined;

	limit			= undefined;
	state			= undefined;
	destructor		= undefined;

	constructor(_listener_id, _events, _limit="*", _state=State.None) {
		this.set_events(_events);

		this.listener_id 	= _listener_id;
		this.limit			= (Array.isArray(_limit)) ? _limit : [0, _limit];
		this.state			= _state;
	};

	set_events = function(_events) {
		this.events			= _events;
		this.trigger_regex 	= (_events[Listener.Event.Trigger]) ? RegExp(_events[Listener.Event.Trigger][Listener.Action.Pattern])	: undefined;
		this.delete_regex 	= (_events[Listener.Event.Delete]) 	? RegExp(_events[Listener.Event.Delete][Listener.Action.Pattern]) 	: undefined;
		this.reset_regex 	= (_events[Listener.Event.Reset]) 	? RegExp(_events[Listener.Event.Reset][Listener.Action.Pattern]) 		: undefined;
	};

	wire = function(_target, _options, _deregister_callback) {
		if (!this.trigger_regex) {
			throw new Error(`Cannot listen for an event with a null/undefined/empty trigger: ${this.trigger_regex}`);
		}

		if (this.state == State.Waiting) {
			throw new Error(`Cannot wire listener: ${this.trigger_regex}, it is already wired.`);
		}

		let method = this.on_event(function _tear_down() { 
			_target.removeEventListener(_target, method, _options); 
			_deregister_callback(this.listener_id);
		}.bind(this));

		_target.addEventListener(Event_Key, method, _options);
		this.state = State.Waiting;
	};

	on_event = function(_destructor) {
		this.destructor = _destructor;

		return function(_event) {
			let payload 	= publisher.get_payload_data(_event);
			let event_id 	= payload[0];
			let args 		= payload[1];
			let resolve 	= payload[2];

			console.log(this.events)
			console.log(_event)
			if (this.state == State.Waiting && this.trigger_regex.test(event_id)) {
				if (this.limit[1] != "*") {
					this.limit[0] += 1;

					if (this.limit[0] >= this.limit[1]) {
						this.state = State.Finished;
					}
				}

				if (this.events[Listener.Event.Trigger][Listener.Action.Method] != undefined && this.events[Listener.Event.Trigger][Listener.Action.Method] != null) {
					logger.log("listener", `Event: ${this.listener_id}.${Listener.Event.Trigger}`, this.events[Listener.Event.Trigger]);
					return resolve(this._create_callback(Listener.Event.Trigger, args));
				}

			} else if (this.reset_regex && this.reset_regex.test(event_id) && this.limit[1] != "*") {
					this.limit[0] = 0;
					this.state = State.Waiting;

					if (this.events[Listener.Event.Reset][Listener.Action.Method] != undefined && this.events[Listener.Event.Reset][Listener.Action.Method] != null) {
						logger.log("listener", `Event: ${this.listener_id}.${Listener.Event.Reset}`, this.events[Listener.Event.Reset]);
						return resolve(this._create_callback(Listener.Event.Reset, args));
					}

			} else if (this.delete_regex && ((this.state == State.Finished && this.events[Listener.Event.Delete] == "$limit$") || this.delete_regex.test(event_id))) {
				if (this.events[Listener.Event.Delete][Listener.Action.Method] != undefined && this.events[Listener.Event.Delete][Listener.Action.Method] != null) {
					logger.log("listener", `Event: ${this.listener_id}.${Listener.Event.Delete}`, this.events[Listener.Event.Delete]);
					return resolve(this._create_callback(Listener.Event.Delete, args));
				}

				_destructor();
			
			}

			resolve();
		}.bind(this)
	};

	// Pass back to a middle man function to execute in reverse order of firing.
	// This is needed since the stack is a LIFO queue and events are FIFO.
	_create_callback = function(_event_id, _args) {
		return function() {
			try {
				let args = this.events[_event_id][Listener.Action.Args];
				args = (args != undefined && args != null) ? args : []; 

				stack.inject(this.events[_event_id][Listener.Action.Method], this._format_args(args, _args), stack.new_process(stack.get_process().right_idx));
			} catch(e) {
				game_loop.state = State.Failed;
				throw e;
			}
		}.bind(this)
	};

	_format_args = function(_listener_args, _event_args=[]) {
		let stringified = JSON.stringify(_listener_args);

		let limit_delta = (this.limit != "*") ? this.limit[1] - this.limit[0] : Infinity
		stringified = stringified.replaceAll(`"$limit$"`, limit_delta).replaceAll(`$limit$`, limit_delta);
		stringified = stringified.replaceAll(`"$event_idx$"`, _event_args[0]);

		for(let idx = 1; idx < _event_args.length; ++idx) {
			stringified = stringified.replaceAll((typeof p_arg == "string") ? `"$${idx - 1}$"`: `$${idx - 1}$`, _event_args[idx]);
		}
	
		return JSON.parse(stringified);
	};

	dict = function() {
		return {
			"listener_id":	this.listener_id,
			"events": 		this.events,
			"limit":		this.limit,
			"state":		this.state
		}
	};
}
</script>

<script>
const game_loop = Object({
	actions: ["action"],

	action: "start",
	state: State.None,

	event_handler: function(_action, _args, _resolve, _reject) {
		logger.func("game_loop", "game_loop.event_handler", arguments);

		switch(_action) {
			case("action"):
				if (rule_data.get(_args[0]) == undefined) {	throw new Error(`There is no rule set for action: ${_args[0]}`) }
				this.action = _args[0];
				return (_resolve) ? _resolve(this.action) : this.action;
			default:
				_reject(new Error(`game_loop.${_action} is not a valid command`));
		}
	},

	run: async function() {
		if (this.state == State.Waiting) {
			logger.log("game_loop", "The game loop has already been started.");
			logger.log("game_loop", "stack.processes", stack.processes, true);
			return;
		}

		let process = stack.get_process();
		let rule = (process != null) ? process.get_rule() : null;
		this.state = State.Waiting;

		while (rule && this.state) {
			await Promise.resolve(rule.next())
			.catch(function(_rejected) {
				if (_rejected instanceof Error) {
					this.state = State.Failed;
					logger.error("game_loop", _rejected);
					return
				}

				logger.log("game_loop", `game_loop has been interrupted to run action: ${_rejected}.`);
				return new Promise(function (_resolve, _reject) {
					publisher.publish("stack", ["process", [stack.get_process().right_idx], _resolve, _reject]);
				})
				.then(new Promise(function (_resolve, _reject) {
					publisher.publish("stack", ["inject", _rejected, _resolve, _reject]);
				}))
				.catch(function() { 
					this.state = State.Failed;
					logger.error("game_loop", arguments);
				}.bind(this));

			}.bind(this))
			.finally(
				new Promise(function(_resolve, _reject) {
					publisher.publish("game_loop.processed", [_resolve, _reject]);
				})
				.catch(function(_rejected) {
					this.state = State.Failed;
					logger.error("game_loop", arguments);
				}.bind(this))
			);

			process = stack.get_process();
			rule = (process != null) ? process.get_rule() : null;
		}

		this.state = (this.state == State.Waiting) ? State.Finished : this.state;
		if (this.state == State.Finished) {
			await profile.save_data();
			this.state = State.None;

			publisher.publish("game_loop.finished");
			logger.log("game_loop", `game_loop has finished all actions, restarting with action: ${this.action}.`);

			await new Promise(function (_resolve, _reject) {
				publisher.publish("stack", ["process", [-Math.min(stack.processes.length, 1)], _resolve, _reject]);
			})
			.then(new Promise(function (_resolve, _reject) {
				publisher.publish("stack", ["inject", [this.action], _resolve, _reject]);
			}.bind(this)))
			.catch(function() { 
				this.state = State.Failed;
				logger.error("game_loop", arguments);
			}.bind(this))
		}
	},
});
</script>

<script>
const html_factory = Object({
	root_elements: {
		"button_group": document.getElementById("button_group"),
		"session_log": document.getElementById("log"),
	},

	get_log: function(_data) {
		return `<div class="left-justify">${_data}</div>`
	},

	get_button: function(_id, _data, _disabled, _css) {
		return `<button id=${_id} type="button" class="button ${_css}" ${(_disabled) ? "disabled" : ""}><p class="center capitalize">${_data}</p></button>`;
	},

	get_button_css: function(_idx, _count) {
		_idx += 1
		if (_count < 4) {
			return (_idx == 1) ? "btn-1" : `btn-${_idx}`;
		} else if (_count < 9) {
			return `btn-${_idx}`; 
		} else {
			return `btn-${_idx}`; 
		}
	},

	set_button_group_css: function(_count) {
		let group = this.root_elements["button_group"];
		group_css = group.className.split("-");

		let grid_css = parseInt(group_css.pop());
		if (grid_css == _count) { return }

		group_css.push(ops.clamp(_count, 0, 9));
		group.className = group_css.join("-");
	},

	event_handler: function(_elements, _resolve=null, _reject=null) {
		logger.func("html_factory", "html_factory.event_handler", arguments);

		let button_idx = 0;
		let button_count = _elements.filter((ele) => ele[0] == "button_group").length;
		
		if (button_count > 0) {
			let button_root = this.root_elements["button_group"];
			while(button_root.firstChild) { button_root.removeChild(button_root.firstChild); };
			this.set_button_group_css(button_count);
		}

		for(let element of _elements) {
			let root_node = this.root_elements[element.shift()];
			let type = element.shift();
			let elem_attrs = element.shift();

			switch (type) {
				case("log"):
					root_node.insertAdjacentHTML('beforeend', this.get_log(elem_attrs.data));
					root_node.scrollTop = root_node.scrollHeight; //Auto scroll
					break;
				case("button"):
					var html = this.get_button(elem_attrs.id, elem_attrs.data, elem_attrs.disabled, this.get_button_css(button_idx, button_count));
					root_node.insertAdjacentHTML('beforeend', html);
					document.getElementById(elem_attrs.id).addEventListener("click", elem_attrs.click)
					button_idx += 1;
					break;
			}
		}

		if (_resolve != null) {
			_resolve(true)
		}
	},

	build: function(_template_id, _root_id, _data) {
    let template = document.getElementById(_template_id);
		if (template == null) { throw new Error(`Could not find the template for id: ${_template_id}`) }
		let root = this.get_and_clear_element(_root_id);

		template = template.innerHTML;
		if (_data instanceof Array) {
			_data.forEach(function (_v, _i, _d) {
				template = template.replace(new RegExp(`##${_i}##`, 'g'), _v);
			});
		} else if(_data instanceof Map) {
			_data.forEach(function (_v, _k, _d) {
				template = template.replace(new RegExp(`##${_k.toUpperCase()}##`, 'g'), _v);
			});
		} else {
			throw new Error(`${_template_id}._data has to be of type Array or Map not ${_data} to be used for templates`);
		}

		root.insertAdjacentHTML('beforeend', template);
	},

	get_and_clear_element: function(_root_id) {
		let root = document.getElementById(_root_id);
		if (root == null)  	{ throw new Error(`Cannot root: ${_root_id} in page.`) }
		while(root.firstChild) { root.removeChild(root.firstChild); };
		return root;
	}
});
</script>

<script>
// Copyright  2013-2017 David Caldwell <david@porkrind.org>
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
// SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
// OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
// CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
// https://github.com/caldwell/renderjson

// Usage
// -----
// The module exports one entry point, the `renderjson()` function. It takes in
// the JSON you want to render as a single argument and returns an HTML
// element.
//
// Options
// -------
// renderjson.set_icons("+", "-")
//   This Allows you to override the disclosure icons.
//
// renderjson.set_show_to_level(level)
//   Pass the number of levels to expand when rendering. The default is 0, which
//   starts with everything collapsed. As a special case, if level is the string
//   "all" then it will start with everything expanded.
//
// renderjson.set_max_string_length(length)
//   Strings will be truncated and made expandable if they are longer than
//   `length`. As a special case, if `length` is the string "none" then
//   there will be no truncation. The default is "none".
//
// renderjson.set_sort_objects(sort_bool)
//   Sort objects by key (default: false)
//
// renderjson.set_replacer(replacer_function)
//   Equivalent of JSON.stringify() `replacer` argument when it's a function
//
// renderjson.set_collapse_msg(collapse_function)
//   Accepts a function (len:number):string => {} where len is the length of the
//   object collapsed.  Function should return the message displayed when a
//   object is collapsed.  The default message is "X items"
//
// renderjson.set_property_list(property_list)
//   Equivalent of JSON.stringify() `replacer` argument when it's an array
//
// Theming
// -------
// The HTML output uses a number of classes so that you can theme it the way
// you'd like:
//     .disclosure    ("", "")
//     .syntax        (",", ":", "{", "}", "[", "]")
//     .string        (includes quotes)
//     .number
//     .boolean
//     .key           (object key)
//     .keyword       ("null", "undefined")
//     .object.syntax ("{", "}")
//     .array.syntax  ("[", "]")

var module, window, define, renderjson=(function() {
var themetext = function(/* [class, text]+ */) {
	var spans = [];
	while (arguments.length) {
		spans.push(
			append(
				span(Array.prototype.shift.call(arguments)),
				text(Array.prototype.shift.call(arguments))
			)
		);
	}

	return spans;
};

var append = function(/* el, ... */) {
	var el = Array.prototype.shift.call(arguments);
	for (var a=0; a<arguments.length; a++)
		if (arguments[a].constructor == Array) {
			append.apply(this, [el].concat(arguments[a]));
		} else {
			el.appendChild(arguments[a]);
		}
	return el;
};

var prepend = function(el, child) {
	el.insertBefore(child, el.firstChild);
	return el;
}

var isempty = function(obj, pl) { 
	var keys = pl || Object.keys(obj);									
	for (var i in keys) {
		if (Object.hasOwnProperty.call(obj, keys[i])) { 
			return false 
		}
	}

	return true; 
}

var text = function(txt)				{ return document.createTextNode(txt) };
var div =  function() 					{ return document.createElement("div") };
var span = function(classname)	{ 
	var s = document.createElement("span");
	if (classname) { s.className = classname; };
	return s; 
};

var A = function A(txt, classname, callback) { 
	var a = document.createElement("a");
	if (classname) { a.className = classname; }

	a.appendChild(text(txt));
	a.href = '#';
	a.onclick = function(e) { callback(); };

	return a; 
};

var _disclosure = function(show_level, options, indent, open, placeholder, close, type, builder) {
	var content;
	var empty = span(type);
	var show = function() {
		if (!content) {
			append(
				empty.parentNode,
				content = prepend(builder(), A(
					options.hide, 
					"disclosure", 
					function() { content.style.display="none"; empty.style.display="inline"; }
				))
			)
		}

		content.style.display="inline";
		empty.style.display="none"; 
	};

	append(
		empty,
		A(options.show, "disclosure", show),
		themetext(`${type} syntax`, open),
		A(placeholder, null, show),
		themetext(`${type} syntax`, close)
	);

	var el = append(span(), text(indent.slice(0, indent.length)), empty);
	if (show_level > 0 && type != "string") {
		show();
	}

	return el;
};

function get_indent_by_level(level, dont_indent=false) {
	return "".padStart(((dont_indent == false) ? 2 - level : 0) * renderjson.options.indent.length, " ");
}

function _renderjson(json, indent, dont_indent, show_level, options) {
	var my_indent = (dont_indent) ? "" : indent;
	var disclosure = _disclosure.bind(this, show_level, options, my_indent);
	let type = "unknown";

	if (json === null) 		return themetext(null, my_indent, "keyword", "null");
	if (json === void 0) 	return themetext(null, my_indent, "keyword", "undefined");

	if (typeof(json) == "string" && json.length > options.max_string_length) {
		type = "string";

		return disclosure(
			options.disclosures[type].start, 
			json.slice(0,options.max_string_length)+" ...", 
			options.disclosures[type].stop, 
			type, 
			function () { 
				return append(
					span(type), 
					themetext(null, (dont_indent) ? "" : indent, type, JSON.stringify(json))
				);
		});
	}

	if (typeof(json) != "object" || [Number, String, Boolean, Date].indexOf(json.constructor) >= 0) {// Strings, numbers and bools
		return themetext(null, my_indent, typeof(json), JSON.stringify(json));
	}

	if (json.constructor == Array) {
		type = "array"
		if (json.length == 0) {
			return themetext(
				null, 
				get_indent_by_level(show_level, dont_indent), 
				`${type} syntax`, 
				`${options.disclosures[type].start}${options.disclosures[type].stop}`);
		}

		return disclosure(
			options.disclosures[type].start, 
			options.collapse_msg(json.length), 
			options.disclosures[type].stop, 
			type, 
			function () {
				var as = append(span(type), themetext(`${type} syntax`, options.disclosures[type].start, null, "\n"));

				for (var i=0; i < json.length; ++i)
					append(
						as,
						_renderjson(options.replacer.call(json, i, json[i]), get_indent_by_level(show_level), false, show_level - 1, options),
						(i != json.length - 1) ? themetext("syntax", ",") : [],
						text("\n")
				);

				append(as, themetext(null, get_indent_by_level(show_level + 1), `${type} syntax`, options.disclosures[type].stop));
				return as;
			}
		);
	}

	// object
	type = "object"
	if (isempty(json, options.property_list)) {
		return themetext(
			null, 
			get_indent_by_level(show_level, dont_indent), 
			`${type} syntax`, 
			`${options.disclosures[type].start}${options.disclosures[type].stop}`);
	}

	return disclosure(
		options.disclosures[type].start, 
		options.collapse_msg(Object.keys(json).length), 
		options.disclosures[type].stop,
		type,
		function () {
			var os = append(span(type), themetext(`${type} syntax`, options.disclosures[type].start, null, "\n"));
			var last = json[json.length - 1];
			var keys = options.property_list || Object.keys(json);

			if (options.sort_objects) {
				keys = keys.sort();
			}
					
			for (var i in keys) {
					var k = keys[i];
					if (!(k in json)) { continue; };
					
					append(os, 
								themetext(null, get_indent_by_level(show_level), "key", `"${k}"`, `${type} syntax`, ': '),
								_renderjson(options.replacer.call(json, k, json[k]), get_indent_by_level(show_level), true, show_level - 1, options),
								k != last ? themetext("syntax", ",") : [],
								text("\n"));
			}

			append(os, themetext(null, get_indent_by_level(show_level + 1), `${type} syntax`, options.disclosures[type].stop));

			return os;
		}
	);
}

var renderjson = function renderjson(json) {
	var options = new Object(renderjson.options);
	options.replacer = typeof(options.replacer) == "function" ? options.replacer : function(k,v) { return v; };
	
	var pre = append(document.createElement("pre"), _renderjson(json, options.indent, true, options.show_to_level, options));
	pre.className = "renderjson";
	return pre;
};

renderjson.set_icons = function(show, hide) { 
	renderjson.options.show = show;
	renderjson.options.hide = hide;
	return renderjson; 
};

renderjson.set_show_to_level = function(level) { 
	renderjson.options.show_to_level = (typeof level == "string" && level.toLowerCase() === "all") ? Number.MAX_VALUE : level;
	return renderjson; 
};

renderjson.set_max_string_length = function(length) { 
	renderjson.options.max_string_length = (typeof length == "string" && length.toLowerCase() === "none") ? Number.MAX_VALUE : length;
	return renderjson; 
};

renderjson.set_sort_objects = function(sort_bool) { 
	renderjson.options.sort_objects = sort_bool;
	return renderjson; 
};

renderjson.set_replacer = function(replacer) { 
	renderjson.options.replacer = replacer;
	return renderjson; 
};

renderjson.set_collapse_msg = function(collapse_msg) { 
	renderjson.options.collapse_msg = collapse_msg;
	return renderjson; 
};

renderjson.set_property_list = function(prop_list) { 
	renderjson.options.property_list = prop_list;
	return renderjson; 
};

// Backwards compatiblity. Use set_show_to_level() for new code.
renderjson.set_show_by_default = function(show) { 
	renderjson.options.show_to_level = show ? Number.MAX_VALUE : 0;
	return renderjson; 
};

renderjson.set_disclosures = function(disclosures) {
	renderjson.options.disclosures = {};
	for (let disclosure of Object.entries(disclosures)) {
		renderjson.options.disclosures[disclosure[0]] = disclosure[1]
	}
	return renderjson; 
};

renderjson.set_indent = function(indent) {
	renderjson.options.indent = indent;
	return renderjson; 
};

renderjson.options = {};
renderjson.set_icons('', '');
renderjson.set_show_by_default(false);
renderjson.set_sort_objects(false);
renderjson.set_max_string_length("none");
renderjson.set_replacer(void 0);
renderjson.set_property_list(void 0);
renderjson.set_collapse_msg(function(len) { return len + " item" + (len==1 ? "" : "s") });
renderjson.set_disclosures({"object": { "start": "{", "stop": "}" }, "array": { "start": "[", "stop": "]" }, "string": { "start": `"`, "stop": `"` }});
renderjson.set_indent("  ");

return renderjson;
})();

if (define) {
	define({renderjson:renderjson})
} else {
	(module||{}).exports = (window||{}).renderjson = renderjson;
}
</script>

<script>
async function open_sidebar() {
	let args =  Array(...arguments);
	let template = args.shift();

	let template_input = document.getElementById("sidebar_template_id");
	template_input.innerHTML = template;
	
	let html_template = `${template}_template`;
	let object_ref = `get_${template}_ref`;

	html_factory.build(html_template, "sidebar_content", args.slice());

	let result = window[object_ref]().initialize(args.slice());
	if (result instanceof Promise) {
		await result;
	}

	document.getElementById("sidebar").style.display = "block";
}

function close_sidebar() {
	document.getElementById("sidebar").style.display = "none";
	html_factory.get_and_clear_element("sidebar_body");
}
</script>

<script>
open_modal = function() {
  let args =  Array(...arguments);
  let template = args.shift();

  let template_input = document.getElementById("modal_template_id");
  template_input.innerHTML = template;
  
  window[`get_${template}_ref`]().initialize(...args);
  document.getElementById("modal").style.display = "flex";
}

close_modal = function() {
  let template_input = document.getElementById("modal_template_id");
	template_input.innerHTML = "";
  document.getElementById("modal").style.display = "none";
}
</script>

<script>
const map_controller = Object({
	area_lookup: {
		"1,0,0,0": ["end",	"rot-270"],
		"0,1,0,0": ["end",	"rot-180"],
		"0,0,1,0": ["end",	"rot-90"],
		"0,0,0,1": ["end",	"rot-0"],
		"1,0,1,0": ["bar",	"rot-90"],
		"0,1,0,1": ["bar",	"rot-0"],
		"1,1,0,0": ["turn", "rot-180"],
		"1,0,0,1": ["turn", "rot-270"],
		"0,1,1,0": ["turn", "rot-90"],
		"0,0,1,1": ["turn", "rot-0"],
		"1,1,1,0": ["tee",	"rot-90"],
		"1,1,0,1": ["tee",	"rot-180"],
		"0,1,1,1": ["tee",	"rot-0"],
		"1,0,1,1": ["tee",	"rot-270"],
		"1,1,1,1": ["plus", "rot-0"],
	},

	refresh: function() {
		let doors = document.getElementById("doors")
		Array.from(doors.getElementsByClassName("trapped-icon")).forEach(ele => ele.className = ele.className.replace("trapped-icon", ""));
		Array.from(doors.getElementsByClassName("locked-icon")).forEach(ele => ele.className = ele.className.replace("locked-icon", ""));
		this.update();
	},

	event_handler: function(_data_set, _path, _delta) {
		//logger.func("map_controller", "map_controller.event_handler", arguments);

		if (_data_set != "save_d") { return };
		if (_path.includes(".map")) {
			this.update();
		} else if (_path.includes(".party_coord")) {
			let doors = document.getElementById("doors")
			Array.from(doors.getElementsByClassName("trapped-icon")).forEach(ele => ele.className = ele.className.replace("trapped-icon", ""));
			Array.from(doors.getElementsByClassName("locked-icon")).forEach(ele => ele.className = ele.className.replace("locked-icon", ""));

			this.update();
		}
	},

	_rendered_range: function(_axis, _max) {
		let rendered = [0,0];
		rendered[0] = _axis - 2;
		rendered[1] = _axis + 2;
	
		let delta = [0,0]
		delta[0] = Math.max(rendered[0], 0) 	 - rendered[0];
		delta[1] = Math.min(rendered[1], _max) - rendered[1];

		rendered[0] = Math.max(rendered[0] - Math.abs(delta[1]), 0);
		rendered[1] = Math.min(rendered[1] + Math.abs(delta[0]), _max)

		return rendered;
	},

	update: function() {
		if (save_data.data.domains[save_data.data.domain_idx] == undefined) { return; }
		
		let coord = save_data.data.domains[save_data.data.domain_idx].party_coord
		let map = save_data.data.domains[save_data.data.domain_idx].map

		if (coord == null || coord == undefined) { return; }
		if (map == null || map == undefined) { return; }

		let areas = document.getElementById("areas");
		let doors = document.getElementById("doors").getElementsByClassName("cell-mini")

		let rendered_y = this._rendered_range(coord[1], map.length - 1);
		let rendered_x = this._rendered_range(coord[0], map.length - 1);

		for(let y=rendered_y[0]; y <= rendered_y[1]; ++y) {
			for(let x=rendered_x[0]; x <= rendered_x[1]; ++x) {
				let r_idx = ((y - rendered_y[0]) * 5) + (x - rendered_x[0]);
				let area_ele = areas.getElementsByClassName("cell")[r_idx];
				if (area_ele == null) { continue; }

				let area_data = map[y][x];
				let is_current = (coord[0] == x) && (coord[1] == y)

				if (area_data == null) {
					while(area_ele.firstChild) { area_ele.removeChild(area_ele.firstChild); };
					continue;
					
				} else {
					while(area_ele.firstChild) { area_ele.removeChild(area_ele.firstChild); };
					
					let tile = this.get_area_icon(area_data.type, Vector.clamp(area_data.doors, 0, 1), is_current);
					if (tile) { 
						area_ele.appendChild(tile); 
					
						let icon = this.get_contain_icon(area_data.flags, tile);
						if (icon) { tile.appendChild(icon); }

						//Handle doors
						let delta = Vector.transform(coord, "-", coord);
						delta = Vector.transform(delta, "*", [2, 18]);
		
						let d_idx = [(x - rendered_x[0]), (y - rendered_y[0])];
						d_idx = Vector.transform(d_idx, "*", [2, 18]);
						d_idx = Vector.transform(d_idx, "+", delta);
						d_idx = d_idx[0] + d_idx[1];
		
						if (d_idx < doors.length) {
							this.update_doors(d_idx, doors, area_data.doors);
						}
					}
				}

				if (is_current && (area_ele.firstChild == null)) {
					if (!area_ele.className.includes("current")) {
						area_ele.className += "current";
					}
				} else {
					area_ele.className = area_ele.className.replace("current", "");
				}
			}
		}
	},

	update_doors: function(_d_idx, _doors, _data) {
		let row_id = parseInt(_doors[_d_idx].className.split(" ")[0].split("-")[1]);
		let filters = [`row-${row_id - 1}`, `row-${row_id}`, `row-${row_id + 1}`, `row-${row_id}`];
		let r_doors = [_doors[_d_idx - 9], _doors[_d_idx - 1], _doors[_d_idx + 9], _doors[_d_idx + 1]];

		for (let idx = 0; idx < r_doors.length; ++idx) {
			r_doors[idx] = (r_doors[idx] && r_doors[idx].className.indexOf(filters[idx]) > -1) ? r_doors[idx] : undefined
		}

		for(let idx = 0; idx < r_doors.length; ++idx) {
			if (r_doors[idx] != null) {
				if (_data != null && _data[idx]) {
					r_doors[idx].className += this.get_door_icon(_data[idx], r_doors[idx].className);
				}
			}
		}
	},

	get_area_icon: function(_area_type, _doors, _is_current=false) {
		if (_doors.toString() != "0,0,0,0") {
			let area_icon_css = this.area_lookup[_doors.toString()];
			let div = document.createElement("div")
			div.className = `${_area_type}-${area_icon_css[0]}-fill-icon ${area_icon_css[1]} ${(_is_current) ? "current" : ""}`;
			return div;
		}
	},

	get_door_icon: function(_door, _css) {
		let door_css = ""
		if (!(_door & 8)) {
			if (_door & 1) {
				//door_css += "door-icon ";
				door_css += ((_door & 2) && !_css.includes("locked-icon")) ? " locked-icon " : "";
				door_css += ((_door & 4) && !_css.includes("trapped-icon")) ? " trapped-icon " : "";
			}
		}

		return door_css;
	},

	area_flags: {"is_event": 1, "is_encounter": 2, "is_exit_up": 4, "is_exit_down": 8, "is_layer": 16, "is_scavenge": 32, "is_trader": 64, "is_items": 128 },
	get_contain_icon: function(_flags, _parent) {
		let icon_css = null;

		if (_flags & this.area_flags.is_layer) {
			icon_css = "boss-icon"
		} else if (_flags & this.area_flags.is_encounter) {
			icon_css = "encounter-icon"
		} else if (_flags & this.area_flags.is_event) {
			icon_css = "event-icon"
		} else if (_flags & this.area_flags.is_exit_up) {
			icon_css = "stairs-up-icon"
		} else if (_flags & this.area_flags.is_exit_down) {
			icon_css = "stairs-down-icon"
		}

		if (icon_css) {
			let rotation_css = _parent.className.split(" ")[1];
			let degrees = (360 - parseInt(rotation_css.split("-")[1])) % 360;

			let div = document.createElement("div");
			div.className = `${icon_css} rot-${degrees}`;
			return div;
		}
	},
});
</script>

<script>
function toggleFullScreen() {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen();
  } else if (document.exitFullscreen) {
    document.exitFullscreen();
  }
}

</script>

<script>
// Wire up all the events to the publisher so that they can fire when called
publisher.subscribe(new EventTarget(), "ops",		publisher.pass_through(ops));
publisher.subscribe(new EventTarget(), "stack",		publisher.pass_through(stack));
publisher.subscribe(new EventTarget(), "io",		publisher.pass_through(io));
publisher.subscribe(new EventTarget(), "heap",		publisher.pass_through(heap));
publisher.subscribe(new EventTarget(), "input",		publisher.pass_through(input));
publisher.subscribe(new EventTarget(), "html",		publisher.pass_through(html_factory));
publisher.subscribe(new EventTarget(), "publisher",	publisher.pass_through(publisher));
publisher.subscribe(new EventTarget(), "game_loop",	publisher.pass_through(game_loop));

publisher.subscribe(new EventTarget(), "state",		publisher.pass_through(heap, "on_state"));
publisher.subscribe(new EventTarget(), "state",		publisher.pass_through(map_controller));
publisher.subscribe(new EventTarget(), "state",		publisher.pass_through(profile.on_state.bind(profile)));

publisher.subscribe(new EventTarget(), "profile",	publisher.pass_through(io, "refresh_data_set"));
publisher.subscribe(new EventTarget(), "profile",	publisher.pass_through(map_controller, "refresh"));

publisher.subscribe(new EventTarget(), "game_loop.finished",	heap.purge.bind(heap));

// Register the profile with all the state systems to save them to the indexdb
profile.register("save_data",		save_data.get.bind(save_data), save_data.set.bind(save_data));
profile.register("heap",			heap.get.bind(heap), heap.set.bind(heap));
profile.register("publisher",		publisher.get.bind(publisher), publisher.set.bind(publisher));

// Wire up all the programmable actions across all the files
ops.actions.reduce((acc, entry)			=>		{acc[`${entry}`] = "ops";			return acc}, Action_Targets);
stack.actions.reduce((acc, entry)		=>		{acc[`${entry}`] = "stack";			return acc}, Action_Targets);
io.actions.reduce((acc, entry)			=>		{acc[`${entry}`] = "io";			return acc}, Action_Targets);
heap.actions.reduce((acc, entry)		=>		{acc[`${entry}`] = "heap";			return acc}, Action_Targets);
input.actions.reduce((acc, entry)		=>		{acc[`${entry}`] = "input";			return acc}, Action_Targets);
game_loop.actions.reduce((acc, entry)	=>		{acc[`${entry}`] = "game_loop";		return acc}, Action_Targets);
publisher.actions.reduce((acc, entry)	=>		{acc[`${entry}`] = "publisher";		return acc}, Action_Targets);

// The entry point game loop
let entry_point = async function(e) {
	if (profile.name != null) {
		while(game_loop.state == State.None) {
			await game_loop.run();
		}
	} else {
		open_sidebar('sidebar_load');
	}
};
document.getElementById("start").addEventListener("click", entry_point);

</script>
</html>